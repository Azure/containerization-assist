name: 'Quality Checks'
description: 'Comprehensive code quality analysis including formatting, linting, static analysis, security scanning, and architecture validation'

inputs:
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  target-paths:
    description: 'Paths to analyze (space-separated)'
    required: false
    default: './pkg/mcp/... ./pkg/core/...'
  golangci-lint-version:
    description: 'golangci-lint version'
    required: false
    default: 'v2.2.2'
  staticcheck-version:
    description: 'staticcheck version'
    required: false
    default: '2024.1.1'
  govulncheck-version:
    description: 'govulncheck version'
    required: false
    default: 'v1.1.3'
  quality-config-path:
    description: 'Path to quality configuration file'
    required: false
    default: '.github/quality-config.json'

outputs:
  format-status:
    description: 'Code formatting status (pass/fail)'
    value: ${{ steps.format-check.outputs.status }}
  lint-status:
    description: 'Linting status (pass/fail)'
    value: ${{ steps.quality-analysis.outputs.lint-status }}
  static-analysis-status:
    description: 'Static analysis status (pass/fail)'
    value: ${{ steps.quality-analysis.outputs.static-analysis-status }}
  security-status:
    description: 'Security scan status (pass/fail)'
    value: ${{ steps.quality-analysis.outputs.security-status }}
  architecture-score:
    description: 'Architecture quality score (0-100)'
    value: ${{ steps.architecture-check.outputs.score }}
  architecture-status:
    description: 'Architecture quality status (excellent/good/needs-improvement)'
    value: ${{ steps.architecture-check.outputs.status }}
  ratchet-opportunity:
    description: 'Whether a ratcheting opportunity exists (true/false)'
    value: ${{ steps.quality-analysis.outputs.ratchet-opportunity }}
  suggested-budget:
    description: 'Suggested new error budget for ratcheting'
    value: ${{ steps.quality-analysis.outputs.suggested-budget }}
  current-issues:
    description: 'Current number of lint issues found'
    value: ${{ steps.quality-analysis.outputs.current-issues }}
  metrics-json-path:
    description: 'Path to quality metrics JSON file'
    value: 'quality-metrics.json'

runs:
  using: "composite"
  steps:
    - name: Install Quality Tools
      shell: bash
      run: |
        echo "ðŸ“¦ Installing quality analysis tools in parallel..."
        
        # Install all tools in parallel
        {
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin ${{ inputs.golangci-lint-version }} &
          go install honnef.co/go/tools/cmd/staticcheck@${{ inputs.staticcheck-version }} &
          go install golang.org/x/vuln/cmd/govulncheck@${{ inputs.govulncheck-version }} &
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest &
          go install github.com/google/wire/cmd/wire@latest &
          sudo apt-get update -qq && sudo apt-get install -y jq &
          wait
        }
        
        echo "âœ… All quality tools installed"
        
    - name: Format Check
      id: format-check
      shell: bash
      run: |
        echo "ðŸ“ Checking code formatting..."
        if [ -n "$(gofmt -s -l .)" ]; then
          echo "âŒ Code needs formatting"
          echo "Files that need formatting:"
          gofmt -s -l . | sed 's/^/  - /'
          echo "status=fail" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "âœ… Code formatting is correct"
          echo "status=pass" >> $GITHUB_OUTPUT
        fi
        
    - name: Quality Analysis (Parallel)
      id: quality-analysis
      shell: bash
      run: |
        echo "ðŸ” Running quality analysis tools in parallel..."
        
        # Run all checks in parallel and capture results
        {
          echo "Running golangci-lint with ratcheting error budget..."
          
          # Load error budget from config
          LINT_BUDGET=200  # Default budget
          RATCHETING_ENABLED=true
          if [ -f "${{ inputs.quality-config-path }}" ]; then
            LINT_BUDGET=$(jq -r '.linting.error_budgets.combined.errors // 200' ${{ inputs.quality-config-path }})
            RATCHETING_ENABLED=$(jq -r '.linting.ratcheting_enabled // true' ${{ inputs.quality-config-path }})
            echo "Using lint error budget: $LINT_BUDGET"
            echo "Ratcheting enabled: $RATCHETING_ENABLED"
          fi
          
          # Run golangci-lint and capture output
          lint_output=$($(go env GOPATH)/bin/golangci-lint run ${{ inputs.target-paths }} 2>&1 || true)
          
          # Count issues - look for "X issues:" pattern at the end
          issue_count=$(echo "$lint_output" | grep -oP '\d+(?= issues:)' | tail -1 || echo "0")
          
          echo "Found $issue_count lint issues (current budget: $LINT_BUDGET)"
          
          # Ratcheting logic: if current issues are significantly better than budget, suggest ratcheting
          if [ "$RATCHETING_ENABLED" = "true" ] && [ "$issue_count" -lt "$LINT_BUDGET" ]; then
            improvement_threshold=10  # Ratchet when 10+ issues better than budget
            if [ $((LINT_BUDGET - issue_count)) -ge $improvement_threshold ]; then
              # Calculate new suggested budget with 5-issue buffer
              suggested_budget=$((issue_count + 5))
              echo "ðŸŽ¯ RATCHETING OPPORTUNITY: Current issues ($issue_count) significantly below budget ($LINT_BUDGET)"
              echo "   ðŸ’¡ Suggested new budget: $suggested_budget (current + 5 buffer)"
              echo "   ðŸ“ To apply: Update 'linting.error_budgets.combined.errors' in ${{ inputs.quality-config-path }}"
              
              # Store ratcheting info for PR comments
              echo "RATCHET_OPPORTUNITY=true" >> lint_result.txt
              echo "CURRENT_ISSUES=$issue_count" >> lint_result.txt  
              echo "SUGGESTED_BUDGET=$suggested_budget" >> lint_result.txt
            fi
          fi
          
          # Determine pass/fail status
          if [ "$issue_count" -le "$LINT_BUDGET" ]; then
            echo "LINT_STATUS=pass" >> lint_result.txt
            echo "âœ… Linting within budget ($issue_count <= $LINT_BUDGET)"
          else
            echo "LINT_STATUS=fail" >> lint_result.txt
            echo "âŒ Linting over budget ($issue_count > $LINT_BUDGET)"
          fi
          
          # Always show the lint output for visibility (but filter Error: prefix to avoid GitHub Actions failures)
          echo "$lint_output" | sed 's/^Error: /Issue: /g'
          exit 0
        } &
        
        {
          echo "Running staticcheck..."
          if staticcheck ${{ inputs.target-paths }}; then
            echo "STATIC_STATUS=pass" > static_result.txt
            echo "âœ… Static analysis passed"
          else
            echo "STATIC_STATUS=fail" > static_result.txt
            echo "âš ï¸ Static analysis issues found but allowing CI to continue"
          fi
          exit 0
        } &
        
        {
          echo "Running govulncheck..."
          if govulncheck ./...; then
            echo "SECURITY_STATUS=pass" > security_result.txt
            echo "âœ… Security scan passed"
          else
            echo "SECURITY_STATUS=fail" > security_result.txt
            echo "âš ï¸ Security scan issues found but allowing CI to continue"
          fi
          exit 0
        } &
        
        
        # Wait for all parallel jobs to complete
        wait
        
        # Set outputs based on results
        source lint_result.txt 2>/dev/null || LINT_STATUS=unknown
        source static_result.txt 2>/dev/null || STATIC_STATUS=unknown  
        source security_result.txt 2>/dev/null || SECURITY_STATUS=unknown
        
        # Extract ratcheting information from lint results
        RATCHET_OPPORTUNITY=${RATCHET_OPPORTUNITY:-false}
        CURRENT_ISSUES=${CURRENT_ISSUES:-0}
        SUGGESTED_BUDGET=${SUGGESTED_BUDGET:-0}
        
        echo "lint-status=$LINT_STATUS" >> $GITHUB_OUTPUT
        echo "static-analysis-status=$STATIC_STATUS" >> $GITHUB_OUTPUT
        echo "security-status=$SECURITY_STATUS" >> $GITHUB_OUTPUT
        echo "ratchet-opportunity=$RATCHET_OPPORTUNITY" >> $GITHUB_OUTPUT
        echo "current-issues=$CURRENT_ISSUES" >> $GITHUB_OUTPUT
        echo "suggested-budget=$SUGGESTED_BUDGET" >> $GITHUB_OUTPUT
        
        # Add to GitHub Actions summary if ratcheting opportunity exists
        if [[ "$RATCHET_OPPORTUNITY" == "true" ]]; then
          {
            echo "## ðŸŽ¯ Quality Improvement Opportunity"
            echo ""
            echo "**ðŸŽ‰ Ratcheting Opportunity Detected!**"
            echo ""
            echo "Your code quality improvements have created an opportunity to tighten the error budget:"
            echo "- **Current issues**: $CURRENT_ISSUES"
            echo "- **Current budget**: 200"
            echo "- **Suggested new budget**: $SUGGESTED_BUDGET"
            echo ""
            echo "**To apply**: Update \`linting.error_budgets.combined.errors\` to \`$SUGGESTED_BUDGET\` in \`.github/quality-config.json\`"
            echo ""
            echo "This locks in your quality improvements and prevents regression! ðŸ”’âœ¨"
          } >> $GITHUB_STEP_SUMMARY
        fi
        
        # Clean up temp files
        rm -f lint_result.txt static_result.txt security_result.txt
    
    - name: Import Graph Validation
      id: import-validation
      shell: bash
      run: |
        echo "ðŸ” Validating import graph for clean architecture..."
        
        # Make script executable
        chmod +x ./scripts/validate-imports.sh
        
        # Run import validation
        if ./scripts/validate-imports.sh --json; then
          echo "âœ… Import validation passed"
          echo "import-status=pass" >> $GITHUB_OUTPUT
        else
          echo "âŒ Import validation failed"
          echo "import-status=fail" >> $GITHUB_OUTPUT
          # Don't fail the build yet - just report
        fi
        
    - name: Architecture Quality Check
      id: architecture-check
      shell: bash
      run: |
        set +e  # Don't exit on error
        echo "ðŸ—ï¸ Running architecture quality analysis..."
        
        # Load configuration from quality-config.json
        COMPLEXITY_THRESHOLD=15
        COMPLEXITY_BUDGET=1000
        LARGE_FILE_BUDGET=10
        
        if [ -f "${{ inputs.quality-config-path }}" ]; then
          echo "ðŸ“‹ Loading settings from ${{ inputs.quality-config-path }}..."
          COMPLEXITY_THRESHOLD=$(jq -r '.complexity.thresholds.target // 15' ${{ inputs.quality-config-path }})
          COMPLEXITY_BUDGET=$(jq -r '.complexity.current_baseline.over_15 // 1000' ${{ inputs.quality-config-path }})
          LARGE_FILE_BUDGET=$(jq -r '.architecture_quality.large_files.budget // 10' ${{ inputs.quality-config-path }})
          echo "Using config: complexity_threshold=$COMPLEXITY_THRESHOLD, complexity_budget=$COMPLEXITY_BUDGET, large_file_budget=$LARGE_FILE_BUDGET"
        else
          echo "ðŸ“‹ Using default settings"
        fi
        
        # Architecture pattern checks
        echo "ðŸ” Checking architecture patterns..."
        ADAPTERS=$(find pkg/mcp pkg/core -name "*adapter*.go" 2>/dev/null | wc -l | tr -d ' ')
        WRAPPERS=$(find pkg/mcp pkg/core -name "*wrapper*.go" 2>/dev/null | grep -v docker_operation | wc -l | tr -d ' ')
        
        # Check for exactly 4 top-level directories in pkg/mcp
        echo "ðŸ“‚ Checking pkg/mcp directory structure..."
        if [ -d "pkg/mcp" ]; then
          ACTUAL_DIRS=$(ls -1 pkg/mcp | wc -l | tr -d ' ')
          EXPECTED_DIRS=4
          DIR_LIST=$(ls -1 pkg/mcp | tr '\n' ', ' | sed 's/, $//')
          
          if [ "$ACTUAL_DIRS" -ne "$EXPECTED_DIRS" ]; then
            echo "âŒ pkg/mcp must contain exactly 4 directories (api, application, domain, infrastructure)"
            echo "   Found $ACTUAL_DIRS directories: $DIR_LIST"
            SCORE=$((SCORE - 20))  # Significant penalty for incorrect structure
          else
            echo "âœ… pkg/mcp has correct 4-layer structure: $DIR_LIST"
          fi
        fi
        
        # Large files check (>800 lines, excluding tests)
        echo "ðŸ“ Checking for large files..."
        LARGE_FILES=$(find pkg/mcp pkg/core -name "*.go" -not -path "*/test*" -exec wc -l {} \; | awk '$1 > 800 {count++} END {print count+0}')
        
        # Complexity analysis
        echo "ðŸ”„ Analyzing cyclomatic complexity..."
        COMPLEX_FUNCTIONS=$($(go env GOPATH)/bin/gocyclo -over $COMPLEXITY_THRESHOLD pkg/mcp pkg/core 2>/dev/null | wc -l | tr -d ' ')
        
        # Calculate architecture score (100 - deductions)
        SCORE=100
        SCORE=$((SCORE - ADAPTERS * 20))      # -20 points per adapter
        SCORE=$((SCORE - WRAPPERS * 15))      # -15 points per wrapper
        
        # Large files deduction with budget
        if [ "$LARGE_FILES" -gt "$LARGE_FILE_BUDGET" ]; then
          LARGE_FILE_EXCESS=$((LARGE_FILES - LARGE_FILE_BUDGET))
          SCORE=$((SCORE - LARGE_FILE_EXCESS * 5))
        fi
        
        # Complex functions deduction with budget
        if [ "$COMPLEX_FUNCTIONS" -gt "$COMPLEXITY_BUDGET" ]; then
          COMPLEXITY_EXCESS=$((COMPLEX_FUNCTIONS - COMPLEXITY_BUDGET))
          SCORE=$((SCORE - COMPLEXITY_EXCESS * 2))
        fi
        
        # Ensure score doesn't go below 0
        if [ $SCORE -lt 0 ]; then SCORE=0; fi
        
        # Determine status
        if [ $SCORE -ge 80 ]; then
          STATUS_EMOJI="âœ…"
          STATUS="excellent"
        elif [ $SCORE -ge 60 ]; then
          STATUS_EMOJI="âš ï¸"
          STATUS="good"
        else
          STATUS_EMOJI="âŒ"
          STATUS="needs-improvement"
        fi
        
        # Set outputs
        echo "score=$SCORE" >> $GITHUB_OUTPUT
        echo "status=$STATUS" >> $GITHUB_OUTPUT
        
        # Report results
        echo ""
        echo "$STATUS_EMOJI Architecture Quality Report"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "  Architecture Score: $SCORE/100 ($STATUS)"
        echo ""
        echo "  ðŸ“‚ pkg/mcp structure: $ACTUAL_DIRS directories (required: 4)"
        echo "  ðŸ“¦ Adapters: $ADAPTERS (target: 0)"
        echo "  ðŸ”§ Wrappers: $WRAPPERS (target: 0)"  
        echo "  ðŸ“„ Large files: $LARGE_FILES (budget: $LARGE_FILE_BUDGET)"
        echo "  ðŸ”„ Complex functions: $COMPLEX_FUNCTIONS (budget: $COMPLEXITY_BUDGET)"
        echo ""
        
        # Show details for violations
        if [ "$ADAPTERS" -gt 0 ]; then
          echo "Adapter files found:"
          find pkg/mcp pkg/core -name "*adapter*.go" 2>/dev/null | sed 's/^/  - /'
        fi
        
        if [ "$WRAPPERS" -gt 0 ]; then
          echo "Wrapper files found:"
          find pkg/mcp pkg/core -name "*wrapper*.go" 2>/dev/null | grep -v docker_operation | sed 's/^/  - /'
        fi
        
        if [ "$LARGE_FILES" -gt 0 ]; then
          echo "Large files (>800 lines):"
          find pkg/mcp pkg/core -name "*.go" -not -path "*/test*" -exec wc -l {} \; | awk '$1 > 800 {print "  - " $2 " (" $1 " lines)"}' | head -5
          if [ "$LARGE_FILES" -gt 5 ]; then
            echo "  ... and $((LARGE_FILES - 5)) more"
          fi
        fi
        
        if [ "$COMPLEX_FUNCTIONS" -gt 0 ]; then
          echo "Most complex functions (showing first 3):"
          $(go env GOPATH)/bin/gocyclo -over $COMPLEXITY_THRESHOLD pkg/mcp pkg/core 2>/dev/null | head -3 | sed 's/^/  - /'
          if [ "$COMPLEX_FUNCTIONS" -gt 3 ]; then
            echo "  ... and $((COMPLEX_FUNCTIONS - 3)) more"
          fi
        fi
        
        echo ""
        echo "âœ… Architecture analysis completed"
        
    - name: Collect Quality Metrics
      shell: bash
      run: |
        echo "ðŸ“Š Collecting comprehensive quality metrics..."
        
        # Make metrics script executable
        chmod +x ./scripts/quality-metrics.sh
        
        # Run metrics collection
        ./scripts/quality-metrics.sh --json
        
        # Add metrics to GitHub summary
        if [ -f quality-metrics.json ]; then
          # Extract metrics values
          TOTAL_LOC=$(jq -r '.code_size.total_loc' quality-metrics.json)
          TEST_LOC=$(jq -r '.code_size.test_loc' quality-metrics.json)
          AVG_LOC=$(jq -r '.code_size.avg_loc_per_file' quality-metrics.json)
          COMPLEX_30=$(jq -r '.complexity.over_30' quality-metrics.json)
          COMPLEX_20=$(jq -r '.complexity.over_20' quality-metrics.json)
          COMPLEX_15=$(jq -r '.complexity.over_15' quality-metrics.json)
          ARCH_SCORE=$(jq -r '.quality.architecture_score' quality-metrics.json)
          INTERFACES=$(jq -r '.abstractions.total_interfaces' quality-metrics.json)
          ADAPTERS=$(jq -r '.abstractions.adapters' quality-metrics.json)
          TOP_DIRS=$(jq -r '.structure.top_level_dirs' quality-metrics.json)
          
          {
            echo ""
            echo "## ðŸ“Š Quality Metrics Summary"
            echo ""
            echo "### Code Size"
            echo "- **Total LOC**: $TOTAL_LOC"
            echo "- **Test LOC**: $TEST_LOC"
            echo "- **Average LOC/file**: $AVG_LOC"
            echo ""
            echo "### Complexity Distribution"
            echo "- **Functions > 30**: $COMPLEX_30"
            echo "- **Functions > 20**: $COMPLEX_20"
            echo "- **Functions > 15**: $COMPLEX_15"
            echo ""
            echo "### Architecture Health"
            echo "- **Architecture Score**: $ARCH_SCORE/100"
            echo "- **Interfaces**: $INTERFACES"
            echo "- **Adapters**: $ADAPTERS"
            echo "- **Top-level dirs**: $TOP_DIRS (target: 4)"
            echo ""
          } >> $GITHUB_STEP_SUMMARY
        fi
        
        # Upload metrics as artifact
        echo "Uploading metrics artifact..."
        mkdir -p metrics-output
        cp quality-metrics.json metrics-output/
        echo "Metrics collected at $(date)" > metrics-output/timestamp.txt