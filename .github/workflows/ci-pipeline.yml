name: CI Pipeline

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write
  statuses: write

# Ensure only one pipeline runs at a time per branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Phase 1: Canary Validation - Fast checks that gate everything else
  canary:
    name: Canary Validation
    runs-on: ubuntu-latest
    outputs:
      should-continue: ${{ steps.canary-check.outputs.success }}
      test-mcp: ${{ steps.detect-paths.outputs.test_mcp }}
      test-core: ${{ steps.detect-paths.outputs.test_core }}
      test-cli: ${{ steps.detect-paths.outputs.test_cli }}

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install golangci-lint
      run: |
        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.1.6

    - name: Detect changed paths
      id: detect-paths
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # Get changed files
          changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..HEAD)
          echo "Changed files:"
          echo "$changed_files"

          # Check for MCP changes
          mcp_changes=$(echo "$changed_files" | grep -E "^(pkg/mcp|cmd/mcp-server)" || true)

          # Check for Core changes
          core_changes=$(echo "$changed_files" | grep -E "^(pkg/core|pkg/utils)" || true)

          # Check for CLI changes
          cli_changes=$(echo "$changed_files" | grep -E "^(pkg/ai|pkg/pipeline|cmd/)" || true)

          # Set outputs
          echo "test_mcp=$([ -n "$mcp_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "test_core=$([ -n "$core_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "test_cli=$([ -n "$cli_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "MCP changes: $([ -n "$mcp_changes" ] && echo "yes" || echo "no")"
          echo "Core changes: $([ -n "$core_changes" ] && echo "yes" || echo "no")"
          echo "CLI changes: $([ -n "$cli_changes" ] && echo "yes" || echo "no")"
        else
          # For non-PR events, test everything
          echo "test_mcp=true" >> $GITHUB_OUTPUT
          echo "test_core=true" >> $GITHUB_OUTPUT
          echo "test_cli=true" >> $GITHUB_OUTPUT
          echo "Non-PR event: testing all packages"
        fi

    - name: Canary validation
      id: canary-check
      run: |
        echo "🚀 Running canary validation..."

        # Test 1: Go mod tidy check
        echo "📝 Testing go mod tidy..."
        cp go.mod go.mod.bak
        cp go.sum go.sum.bak
        go mod tidy
        if ! diff -q go.mod go.mod.bak >/dev/null || ! diff -q go.sum go.sum.bak >/dev/null; then
          echo "❌ go mod tidy would make changes - dependencies are not tidy"
          echo "Run 'go mod tidy' locally and commit the changes"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Go mod tidy passed"

        # Test 2: Format check
        echo "🎨 Testing gofmt..."
        unformatted=$(gofmt -s -l .)
        if [ -n "$unformatted" ]; then
          echo "❌ Code formatting issues found:"
          echo "$unformatted"
          echo "Run 'gofmt -s -w .' to fix formatting"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Code formatting passed"

        # Test 3: Import formatting check
        echo "📋 Testing goimports..."
        go install golang.org/x/tools/cmd/goimports@latest
        goimports_output=$(goimports -l .)
        if [ -n "$goimports_output" ]; then
          echo "❌ Import formatting issues found:"
          echo "$goimports_output"
          echo "Run 'goimports -w .' to fix import formatting"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Import formatting passed"

        # Test 4: Build check
        echo "📦 Testing build..."
        if ! go build ./...; then
          echo "❌ Build failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Build passed"

        # Test 5: Basic lint check
        echo "🔍 Testing lint..."
        if ! golangci-lint run --timeout=5m ./...; then
          echo "❌ Lint failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Lint passed"

        # Test 6: Short tests
        echo "🧪 Testing short tests..."
        if ! go test -short ./...; then
          echo "❌ Short tests failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "✅ Short tests passed"

        echo "🎉 All canary checks passed!"
        echo "success=true" >> $GITHUB_OUTPUT

  # Phase 2: Parallel Unit Tests (only run if canary passes)
  unit-test-core:
    name: Unit Tests - Core Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-core == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/core/... ./pkg/pipeline/... ./pkg/utils/... ./pkg/docker/... ./pkg/k8s/... ./pkg/kind/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  unit-test-mcp:
    name: Unit Tests - MCP Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-mcp == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/mcp/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  unit-test-cli:
    name: Unit Tests - CLI Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-cli == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/ai/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  # Phase 3: Build Binaries (parallel with unit tests)
  build-cli:
    name: Build CLI Binary
    needs: canary
    if: needs.canary.outputs.should-continue == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './cmd/...'
      run-tests: false
      build-binary: true
      binary-output: 'container-kit'
      binary-main: './main.go'

  build-mcp:
    name: Build MCP Server
    needs: canary
    if: needs.canary.outputs.should-continue == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './cmd/mcp-server/...'
      run-tests: false
      build-binary: true
      binary-output: 'container-kit-mcp'
      binary-main: './cmd/mcp-server'

  # Phase 4: Coverage Enforcement & Ratchet (after unit tests)
  coverage-enforcement:
    name: Coverage Enforcement
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: go mod download

    - name: Run coverage enforcement for core packages
      run: |
        echo "📊 Running coverage enforcement..."

        # Define core packages that need coverage enforcement
        CORE_PACKAGES=(
          "./pkg/mcp/internal/core/..."
          "./pkg/mcp/internal/runtime/..."
          "./pkg/mcp/internal/orchestration/..."
          "./pkg/mcp/internal/session/..."
          "./pkg/mcp/internal/build/..."
          "./pkg/mcp/internal/deploy/..."
          "./pkg/mcp/internal/analyze/..."
          "./pkg/mcp/internal/server/..."
          "./pkg/mcp/types/..."
        )

        # Coverage thresholds (minimum required coverage percentages)
        declare -A COVERAGE_THRESHOLDS
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/core/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/runtime/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/orchestration/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/session/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/build/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/deploy/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/analyze/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/server/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/types/..."]=15

        FAILED_PACKAGES=()

        for package in "${CORE_PACKAGES[@]}"; do
          echo "Checking coverage for $package..."

          # Run tests with coverage
          coverage_file="/tmp/coverage-$(echo $package | tr '/' '-' | tr '.' '-').out"
          if go test -coverprofile="$coverage_file" "$package" 2>/dev/null; then
            if [ -f "$coverage_file" ]; then
              # Extract coverage percentage
              coverage_line=$(go tool cover -func="$coverage_file" | grep "total:" | tail -1)
              if [ -n "$coverage_line" ]; then
                coverage_percent=$(echo "$coverage_line" | awk '{print $3}' | sed 's/%//')
                threshold=${COVERAGE_THRESHOLDS[$package]}

                echo "Package $package: ${coverage_percent}% coverage (threshold: ${threshold}%)"

                # Compare coverage with threshold
                if (( $(echo "$coverage_percent < $threshold" | bc -l) )); then
                  echo "❌ $package coverage ${coverage_percent}% is below threshold ${threshold}%"
                  FAILED_PACKAGES+=("$package (${coverage_percent}% < ${threshold}%)")
                else
                  echo "✅ $package coverage ${coverage_percent}% meets threshold ${threshold}%"
                fi
              else
                echo "⚠️ Could not extract coverage for $package"
              fi
            else
              echo "⚠️ No coverage file generated for $package"
            fi
          else
            echo "⚠️ Tests failed for $package"
          fi
        done

        # Report results
        if [ ${#FAILED_PACKAGES[@]} -eq 0 ]; then
          echo "🎉 All packages meet coverage requirements!"
        else
          echo "❌ Coverage enforcement failed for the following packages:"
          for pkg in "${FAILED_PACKAGES[@]}"; do
            echo "  - $pkg"
          done
          echo ""
          echo "Please add tests to increase coverage for the failing packages."
          exit 1
        fi

    - name: Generate global coverage report
      run: |
        echo "📊 Generating global coverage report..."
        
        # Run full test suite with coverage
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html
        
        # Install coverage tools
        go install github.com/axw/gocov/gocov@latest
        go install github.com/AlekSi/gocov-xml@latest
        
        # Convert coverage to XML
        gocov convert coverage.out | gocov-xml > coverage.xml
        
        # Generate coverage summary
        go tool cover -func=coverage.out > coverage-summary.txt
        echo "## Global Coverage Summary" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        cat coverage-summary.txt >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    - name: Check global coverage thresholds
      run: |
        # Extract total coverage
        TOTAL_COV=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "Total coverage: ${TOTAL_COV}%"
        
        # Set default thresholds (can be overridden with config file)
        MIN_THRESHOLD=10    # Minimum acceptable coverage
        TARGET_THRESHOLD=25 # Target coverage goal
        
        # Try to load from config file if it exists
        if [ -f .github/coverage-thresholds.json ]; then
          MIN_THRESHOLD=$(jq -r '.global.line_coverage.minimum' .github/coverage-thresholds.json 2>/dev/null || echo "10")
          TARGET_THRESHOLD=$(jq -r '.global.line_coverage.target' .github/coverage-thresholds.json 2>/dev/null || echo "25")
        fi
        
        echo "Minimum threshold: ${MIN_THRESHOLD}%"
        echo "Target threshold: ${TARGET_THRESHOLD}%"
        
        # Check if coverage meets minimum
        if (( $(echo "$TOTAL_COV < $MIN_THRESHOLD" | bc -l) )); then
          echo "❌ Global coverage ${TOTAL_COV}% is below minimum threshold ${MIN_THRESHOLD}%"
          exit 1
        fi
        
        # Check if coverage meets target
        if (( $(echo "$TOTAL_COV >= $TARGET_THRESHOLD" | bc -l) )); then
          echo "✅ Global coverage ${TOTAL_COV}% meets target threshold ${TARGET_THRESHOLD}%"
        else
          echo "⚠️ Global coverage ${TOTAL_COV}% meets minimum but is below target ${TARGET_THRESHOLD}%"
        fi

    - name: Check coverage ratchet (PR only)
      if: github.event_name == 'pull_request'
      run: |
        echo "🔄 Checking coverage ratchet..."
        
        # Get base branch coverage
        git checkout ${{ github.event.pull_request.base.sha }}
        go test -coverprofile=base-coverage.out ./... > /dev/null 2>&1 || true
        
        if [ -f base-coverage.out ]; then
          BASE_COV=$(go tool cover -func=base-coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          git checkout ${{ github.event.pull_request.head.sha }}
          CURRENT_COV=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          
          echo "Base coverage: ${BASE_COV}%"
          echo "Current coverage: ${CURRENT_COV}%"
          
          # Calculate difference
          DIFF=$(echo "$CURRENT_COV - $BASE_COV" | bc -l)
          
          # Set default tolerance (can be overridden with config file)
          TOLERANCE=2.0
          if [ -f .github/coverage-thresholds.json ]; then
            TOLERANCE=$(jq -r '.ratchet.regression_tolerance' .github/coverage-thresholds.json 2>/dev/null || echo "2.0")
          fi
          
          echo "Coverage change: ${DIFF}% (tolerance: -${TOLERANCE}%)"
          
          if (( $(echo "$DIFF < -$TOLERANCE" | bc -l) )); then
            echo "❌ Coverage regression detected: ${DIFF}% (tolerance: -${TOLERANCE}%)"
            echo "## Coverage Ratchet Failed ❌" >> $GITHUB_STEP_SUMMARY
            echo "Coverage decreased by ${DIFF}% which exceeds tolerance of -${TOLERANCE}%" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "✅ Coverage ratchet passed: ${DIFF}%"
            echo "## Coverage Ratchet Passed ✅" >> $GITHUB_STEP_SUMMARY
            echo "Coverage change: ${DIFF}%" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "⚠️ Could not determine base coverage, skipping ratchet check"
          echo "## Coverage Ratchet Skipped ⚠️" >> $GITHUB_STEP_SUMMARY
          echo "Base coverage could not be determined" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: global-coverage-reports
        path: |
          coverage.out
          coverage.html
          coverage.xml
          coverage-summary.txt
          base-coverage.out
        retention-days: 30

  # Phase 5: Security Scanning (parallel with coverage)
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install Security Scanners
      run: |
        echo "🔒 Installing security scanners..."
        sudo apt-get update
        sudo apt-get install -y wget apt-transport-https gnupg lsb-release bc

        # Install Trivy
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install -y trivy

        # Install GitLeaks
        wget https://github.com/zricethezav/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz
        tar xzf gitleaks_8.18.0_linux_x64.tar.gz
        sudo mv gitleaks /usr/local/bin/
        chmod +x /usr/local/bin/gitleaks

    - name: Run GitLeaks (Secret Detection)
      run: |
        echo "🔍 Scanning for secrets..."
        
        # Create gitleaks config to exclude test files and known test patterns
        cat > .gitleaks.toml << 'EOF'
        [allowlist]
          description = "Test secrets and known safe patterns"
          
          # Exclude test files
          files = [
            '''.*_test\.go''',
            '''.*test.*\.go''',
            '''test/.*''',
            '''.*testdata.*''',
            '''examples/.*''',
            '''repomix-output\.xml'''
          ]
          
          # Exclude known test patterns
          regexes = [
            '''sk-1234567890abcdef''',
            '''AKIAFAKETEST12345678''',
            '''AKIAIOSFODNN7EXAMPLE''',
            '''test-api-key-123456''',
            '''zN8BP6lnPUDpumenHCZLVwZkFcSIGPr0''',
            '''dGhpcyBpcyBhIHNlY3JldCBtZXNzYWdl''',
            '''4e1243bd22c66e76c2ba9bef8c5e8f8a''',
            '''YOUR_PRIVATE_KEY_CONTENT_HERE_REPLACE_WITH_ACTUAL_KEY''',
            '''eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE''',
            '''dXNlcjpwYXNzd29yZA==''',
            '''abc123def456''',
            '''sk_test_abcdef123456'''
          ]
        EOF
        
        # Run gitleaks with config
        gitleaks detect --config .gitleaks.toml --report-format json --report-path gitleaks-report.json --verbose

        if [ -f gitleaks-report.json ]; then
          leak_count=$(jq '. | length' gitleaks-report.json 2>/dev/null || echo "0")
          echo "Found $leak_count potential secrets"

          if [ "$leak_count" -gt 0 ]; then
            echo "❌ Potential secrets found!"
            jq -r '.[] | "- \(.RuleID): \(.File):\(.StartLine) - \(.Description)"' gitleaks-report.json
            exit 1
          else
            echo "✅ No secrets detected"
          fi
        else
          echo "✅ No secrets detected"
        fi

    - name: Run Trivy (Vulnerability Scanning)
      run: |
        echo "🛡️ Scanning for vulnerabilities..."

        # Scan filesystem for vulnerabilities
        trivy fs --format json --output trivy-fs-report.json .

        # Scan for configuration issues
        trivy config --format json --output trivy-config-report.json .

        # Process results
        fs_vulns=$(jq '.Results[]?.Vulnerabilities? // [] | length' trivy-fs-report.json | awk '{sum += $1} END {print sum+0}')
        config_issues=$(jq '.Results[]?.Misconfigurations? // [] | length' trivy-config-report.json | awk '{sum += $1} END {print sum+0}')

        echo "Found $fs_vulns filesystem vulnerabilities"
        echo "Found $config_issues configuration issues"

        # Report critical/high severity issues
        critical_vulns=$(jq '.Results[]?.Vulnerabilities? // [] | map(select(.Severity == "CRITICAL" or .Severity == "HIGH")) | length' trivy-fs-report.json | awk '{sum += $1} END {print sum+0}')

        if [ "$critical_vulns" -gt 0 ]; then
          echo "❌ Found $critical_vulns critical/high severity vulnerabilities!"
          jq -r '.Results[]?.Vulnerabilities? // [] | map(select(.Severity == "CRITICAL" or .Severity == "HIGH")) | .[] | "- \(.Severity): \(.VulnerabilityID) in \(.PkgName) - \(.Title)"' trivy-fs-report.json
          exit 1
        else
          echo "✅ No critical or high severity vulnerabilities found"
        fi

    - name: Upload security reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          gitleaks-report.json
          trivy-fs-report.json
          trivy-config-report.json
        retention-days: 30

  # Phase 6: Quality Gates (after coverage and security)
  quality-gates:
    name: Quality Gate Checks
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, coverage-enforcement, security-scan]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Quality gates summary
      run: |
        echo "🎯 Quality Gates Summary"
        echo "✅ All unit tests passed"
        echo "✅ All builds completed successfully"
        echo "✅ Coverage enforcement passed"
        echo "✅ Security scanning passed"
        echo "🎉 All quality gates passed!"

  # Phase 5: Integration Tests (after everything else)
  integration-tests:
    name: Integration Tests
    needs: [canary, unit-test-core, unit-test-cli, build-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure() && needs.canary.outputs.test-cli == 'true'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download CLI binary
      uses: actions/download-artifact@v4
      with:
        name: container-kit-ubuntu-latest
        path: ./

    - name: Run integration tests
      run: |
        chmod +x container-kit
        echo "🧪 Running integration tests..."
        echo "Integration tests would run here with the built binary"

  # Phase 6: MCP Integration Tests (parallel with integration tests)
  mcp-integration-tests:
    name: MCP Integration Tests
    needs: [canary, unit-test-mcp, build-mcp]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure() && needs.canary.outputs.test-mcp == 'true'
    runs-on: ubuntu-latest

    services:
      docker:
        image: docker:dind
        options: --privileged

    steps:
    - uses: actions/checkout@v4

    - uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install Kind
      run: |
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run MCP unit tests
      run: go test -v ./pkg/mcp/... -short

    - name: Run MCP unit tests with race detector
      run: go test -race -v ./pkg/mcp/... -short

    - name: Build MCP server
      run: go build -o container-kit-mcp ./cmd/mcp-server

    - name: Run MCP integration tests
      run: |
        export CONTAINER_KIT_TEST_WORKSPACE="/tmp/container-kit-test"
        export CONTAINER_KIT_LOG_LEVEL="debug"
        mkdir -p "$CONTAINER_KIT_TEST_WORKSPACE"
        go test -v ./test/integration/...

  # Phase 7: Testing Dashboard (after all tests complete)
  testing-dashboard:
    name: Testing Dashboard
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, quality-gates]
    if: github.event_name == 'pull_request' && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: |
        go mod download
        go mod tidy

    - name: Make scripts executable
      run: chmod +x scripts/generate-testing-report.sh

    - name: Generate testing dashboard
      env:
        CI: true
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_PR_NUMBER: ${{ github.event.number }}
      run: |
        # Install gh CLI if not present
        if ! command -v gh &> /dev/null; then
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh
        fi

        # Run the consolidated testing dashboard generator
        ./scripts/generate-testing-report.sh

    - name: Upload test coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-reports
        path: |
          /tmp/coverage-*.out
          coverage.out
        retention-days: 7

    - name: Upload testing report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: testing-report
        path: /tmp/testing-report.md
        retention-days: 30

  # Final Phase: Pipeline Summary
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, build-cli, build-mcp, quality-gates, integration-tests, mcp-integration-tests, testing-dashboard]
    if: always()

    steps:
    - name: Pipeline Summary
      run: |
        echo "## 🚀 CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Phase Results" >> $GITHUB_STEP_SUMMARY
        echo "| Phase | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Canary Validation | ${{ needs.canary.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Core Unit Tests | ${{ needs.unit-test-core.result == 'success' && '✅ Passed' || needs.unit-test-core.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Unit Tests | ${{ needs.unit-test-mcp.result == 'success' && '✅ Passed' || needs.unit-test-mcp.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| CLI Unit Tests | ${{ needs.unit-test-cli.result == 'success' && '✅ Passed' || needs.unit-test-cli.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| CLI Build | ${{ needs.build-cli.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Build | ${{ needs.build-mcp.result == 'success' && '✅ Passed' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Quality Gates | ${{ needs.quality-gates.result == 'success' && '✅ Passed' || needs.quality-gates.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Integration Tests | ${{ needs.integration-tests.result == 'success' && '✅ Passed' || needs.integration-tests.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Integration Tests | ${{ needs.mcp-integration-tests.result == 'success' && '✅ Passed' || needs.mcp-integration-tests.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Testing Dashboard | ${{ needs.testing-dashboard.result == 'success' && '✅ Passed' || needs.testing-dashboard.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Overall result
        if [ "${{ needs.canary.result }}" = "success" ]; then
          echo "### Overall Result: ✅ Pipeline Completed Successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "### Overall Result: ❌ Pipeline Failed at Canary Stage" >> $GITHUB_STEP_SUMMARY
        fi
