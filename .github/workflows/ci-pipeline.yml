name: CI Pipeline

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Quick validation and path detection
  setup:
    name: Setup & Path Detection
    runs-on: ubuntu-latest
    outputs:
      test-mcp: ${{ steps.detect-paths.outputs.test_mcp }}
      test-cli: ${{ steps.detect-paths.outputs.test_cli }}
      go-cache-key: ${{ steps.cache-keys.outputs.go-cache-key }}
      tools-cache-key: ${{ steps.cache-keys.outputs.tools-cache-key }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect changed paths
      id: detect-paths
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "üîç Detecting changes for PR #${{ github.event.number }}"
          
          changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..HEAD)
          echo "üìù Changed files: $(echo "$changed_files" | wc -l) total"
          
          # Check for MCP changes (cmd/mcp-server/, pkg/common/, pkg/core/, pkg/mcp/)
          mcp_count=$(echo "$changed_files" | grep -E "^(cmd/mcp-server/|pkg/(common|core|mcp)/)" | wc -l)
          echo "test_mcp=$([ $mcp_count -gt 0 ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "MCP changes: $([ $mcp_count -gt 0 ] && echo "yes ($mcp_count files)" || echo "no")"
        else
          echo "test_mcp=true" >> $GITHUB_OUTPUT
          echo "Non-PR event: testing all packages"
        fi
        
    - name: Generate cache keys
      id: cache-keys
      run: |
        echo "go-cache-key=${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}" >> $GITHUB_OUTPUT
        echo "tools-cache-key=${{ runner.os }}-quality-tools-v3" >> $GITHUB_OUTPUT

  # Build job - fast and parallel
  build:
    name: Build Binaries
    runs-on: ubuntu-latest
    needs: setup
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Go Environment
      uses: ./.github/actions/setup-go
      
    - name: Build MCP Server
      run: |
        GOFLAGS=-trimpath go build -o container-kit-mcp ./cmd/mcp-server
        ./container-kit-mcp --version

  # Quality checks - parallel with build
  quality:
    name: Quality Analysis
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      format-status: ${{ steps.quality-checks.outputs.format-status }}
      lint-status: ${{ steps.quality-checks.outputs.lint-status }}
      static-analysis-status: ${{ steps.quality-checks.outputs.static-analysis-status }}
      security-status: ${{ steps.quality-checks.outputs.security-status }}
      architecture-score: ${{ steps.quality-checks.outputs.architecture-score }}
      architecture-status: ${{ steps.quality-checks.outputs.architecture-status }}
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Go Environment
      uses: ./.github/actions/setup-go
          
    - name: Cache Quality Tools
      uses: actions/cache@v4
      with:
        path: ~/go/bin
        key: ${{ needs.setup.outputs.tools-cache-key }}
        restore-keys: |
          ${{ runner.os }}-quality-tools-
        
    - name: Quality Checks
      id: quality-checks
      uses: ./.github/actions/quality-checks
      with:
        go-version: '1.24.4'
        target-paths: './pkg/mcp/... ./pkg/core/...'
        
    - name: Upload Quality Metrics
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: quality-metrics-${{ github.run_id }}
        path: |
          quality-metrics.json
          metrics-output/
        retention-days: 30

  # Unit tests - depends on build completion
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: [setup, build]
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Go Environment
      uses: ./.github/actions/setup-go
        
    - name: Unit Tests with Race Detection
      run: |
        echo "üèÉ Running unit tests with race detection..."
        
        # Run tests with race detection and capture output
        set -o pipefail
        go test -race -coverprofile=coverage.out -v ./... 2>&1 | tee test-output.log
        
        # Check for race conditions in test output
        if grep -q "WARNING: DATA RACE" test-output.log; then
          echo "‚ùå Data races detected in tests!"
          echo "Race condition details:"
          grep -A 10 -B 5 "WARNING: DATA RACE" test-output.log || true
          exit 1
        else
          echo "‚úÖ No data races detected"
        fi
        
        # Also run our dedicated race detection test suite
        echo "üèÉ Running dedicated race detection test suite..."
        go test -race -timeout=90s ./pkg/mcp/infrastructure/ -run TestRaceDetectionSuite -v
      
    - name: Test Coverage Analysis
      run: |
        echo "üìä Analyzing test coverage..."
        
        # Generate coverage report
        go tool cover -func=coverage.out > coverage-report.txt
        go tool cover -html=coverage.out -o coverage.html
        
        # Extract overall coverage percentage
        OVERALL_COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "Overall coverage: ${OVERALL_COVERAGE}%"
        
        # Load coverage thresholds from config
        OVERALL_TARGET=70
        OVERALL_MINIMUM=50
        if [ -f ".github/quality-config.json" ]; then
          OVERALL_TARGET=$(jq -r '.test_coverage.overall_target // 70' .github/quality-config.json)
          OVERALL_MINIMUM=$(jq -r '.test_coverage.overall_minimum // 50' .github/quality-config.json)
        fi
        
        echo "Coverage targets: minimum=${OVERALL_MINIMUM}%, target=${OVERALL_TARGET}%"
        
        # Check against minimum threshold
        if (( $(echo "$OVERALL_COVERAGE < $OVERALL_MINIMUM" | bc -l 2>/dev/null || echo 0) )); then
          echo "‚ùå Coverage ${OVERALL_COVERAGE}% below minimum threshold ${OVERALL_MINIMUM}%"
          exit 1
        elif (( $(echo "$OVERALL_COVERAGE < $OVERALL_TARGET" | bc -l 2>/dev/null || echo 0) )); then
          echo "‚ö†Ô∏è Coverage ${OVERALL_COVERAGE}% below target ${OVERALL_TARGET}% but above minimum"
        else
          echo "‚úÖ Coverage ${OVERALL_COVERAGE}% meets target ${OVERALL_TARGET}%"
        fi
        
        # Store coverage for status reporting
        echo "COVERAGE_PERCENTAGE=${OVERALL_COVERAGE}" >> $GITHUB_ENV
        
    - name: Upload Coverage Report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report-${{ github.run_id }}
        path: |
          coverage.out
          coverage.html
          test-output.log
        retention-days: 30

  # MCP Integration tests - lightweight and fast
  mcp-integration:
    name: MCP Integration Tests
    runs-on: ubuntu-latest
    needs: [build, quality, setup]
    steps:
    - name: Debug Integration Test Conditions
      run: |
        echo "üîç MCP Integration Test Debug:"
        echo "  test-mcp: '${{ needs.setup.outputs.test-mcp }}'"
        echo "  architecture-score: '${{ needs.quality.outputs.architecture-score }}'"
        
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup Docker
      uses: docker/setup-buildx-action@v3
      
    - name: Setup Kind
      uses: helm/kind-action@v1
      with:
        install_only: true
        
    - name: MCP Integration Tests
      run: |
        chmod +x ./test/integration/run_tests.sh
        ./test/integration/run_tests.sh

  # Post PR comment with beautiful summary
  pr-comment:
    name: Post PR Summary
    runs-on: ubuntu-latest
    needs: [build, quality, test, mcp-integration]
    if: always() && github.event_name == 'pull_request'
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Create PR Comment
      uses: ./.github/actions/pr-comment
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        build-status: ${{ needs.build.result }}
        quality-status: ${{ needs.quality.result }}
        test-status: ${{ needs.test.result }}
        mcp-integration-status: ${{ needs.mcp-integration.result }}
        architecture-score: ${{ needs.quality.outputs.architecture-score || '0' }}
        architecture-status: ${{ needs.quality.outputs.architecture-status || 'unknown' }}
        format-status: ${{ needs.quality.outputs.format-status || 'unknown' }}
        lint-status: ${{ needs.quality.outputs.lint-status || 'unknown' }}
        static-analysis-status: ${{ needs.quality.outputs.static-analysis-status || 'unknown' }}
        security-status: ${{ needs.quality.outputs.security-status || 'unknown' }}

  # Final status check for branch protection
  ci-status:
    name: CI Status Check
    runs-on: ubuntu-latest
    needs: [build, quality, test, mcp-integration ]
    if: always()
    
    steps:
    - name: Check CI Status
      run: |
        echo "üîç Checking overall CI status..."
        echo "Build: ${{ needs.build.result }}"
        echo "Quality: ${{ needs.quality.result }}"
        echo "Tests: ${{ needs.test.result }}"
        echo "MCP Integration: ${{ needs.mcp-integration.result }}"
        
        # Required checks
        if [[ "${{ needs.build.result }}" != "success" ]]; then
          echo "‚ùå Build failed"
          exit 1
        fi
        
        if [[ "${{ needs.quality.result }}" != "success" ]]; then
          echo "‚ùå Quality checks failed"
          exit 1
        fi
        
        if [[ "${{ needs.test.result }}" != "success" ]]; then
          echo "‚ùå Unit tests failed"
          exit 1
        fi
        
        # MCP integration is required
        if [[ "${{ needs.mcp-integration.result }}" == "failure" ]]; then
          echo "‚ùå MCP integration tests failed"
          exit 1
        fi
        
        echo "‚úÖ All CI checks passed!"