name: CI Pipeline

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write
  statuses: write

# Ensure only one pipeline runs at a time per branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Phase 1: Canary Validation - Fast checks that gate everything else
  canary:
    name: Canary Validation
    runs-on: ubuntu-latest
    outputs:
      should-continue: ${{ steps.canary-check.outputs.success }}
      test-mcp: ${{ steps.detect-paths.outputs.test_mcp }}
      test-core: ${{ steps.detect-paths.outputs.test_core }}
      test-cli: ${{ steps.detect-paths.outputs.test_cli }}

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install golangci-lint
      run: |
        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.1.6

    - name: Detect changed paths
      id: detect-paths
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # Get changed files
          changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..HEAD)
          echo "Changed files:"
          echo "$changed_files"

          # Check for MCP changes
          mcp_changes=$(echo "$changed_files" | grep -E "^(pkg/mcp|cmd/mcp-server)" || true)

          # Check for Core changes
          core_changes=$(echo "$changed_files" | grep -E "^(pkg/core|pkg/utils)" || true)

          # Check for CLI changes
          cli_changes=$(echo "$changed_files" | grep -E "^(pkg/ai|pkg/pipeline|cmd/)" || true)

          # Set outputs
          echo "test_mcp=$([ -n "$mcp_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "test_core=$([ -n "$core_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
          echo "test_cli=$([ -n "$cli_changes" ] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

          echo "MCP changes: $([ -n "$mcp_changes" ] && echo "yes" || echo "no")"
          echo "Core changes: $([ -n "$core_changes" ] && echo "yes" || echo "no")"
          echo "CLI changes: $([ -n "$cli_changes" ] && echo "yes" || echo "no")"
        else
          # For non-PR events, test everything
          echo "test_mcp=true" >> $GITHUB_OUTPUT
          echo "test_core=true" >> $GITHUB_OUTPUT
          echo "test_cli=true" >> $GITHUB_OUTPUT
          echo "Non-PR event: testing all packages"
        fi

    - name: Canary validation
      id: canary-check
      run: |
        echo "ðŸš€ Running canary validation..."

        # Test 1: Go mod tidy check
        echo "ðŸ“ Testing go mod tidy..."
        cp go.mod go.mod.bak
        cp go.sum go.sum.bak
        go mod tidy
        if ! diff -q go.mod go.mod.bak >/dev/null || ! diff -q go.sum go.sum.bak >/dev/null; then
          echo "âŒ go mod tidy would make changes - dependencies are not tidy"
          echo "Run 'go mod tidy' locally and commit the changes"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Go mod tidy passed"

        # Test 2: Format check
        echo "ðŸŽ¨ Testing gofmt..."
        unformatted=$(gofmt -s -l .)
        if [ -n "$unformatted" ]; then
          echo "âŒ Code formatting issues found:"
          echo "$unformatted"
          echo "Run 'gofmt -s -w .' to fix formatting"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Code formatting passed"

        # Test 3: Import formatting check
        echo "ðŸ“‹ Testing goimports..."
        go install golang.org/x/tools/cmd/goimports@latest
        goimports_output=$(goimports -l .)
        if [ -n "$goimports_output" ]; then
          echo "âŒ Import formatting issues found:"
          echo "$goimports_output"
          echo "Run 'goimports -w .' to fix import formatting"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Import formatting passed"

        # Test 4: Build check
        echo "ðŸ“¦ Testing build..."
        if ! go build ./...; then
          echo "âŒ Build failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Build passed"

        # Test 5: Basic lint check
        echo "ðŸ” Testing lint..."
        if ! golangci-lint run --timeout=5m ./...; then
          echo "âŒ Lint failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Lint passed"

        # Test 6: Short tests
        echo "ðŸ§ª Testing short tests..."
        if ! go test -short ./...; then
          echo "âŒ Short tests failed"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        echo "âœ… Short tests passed"

        echo "ðŸŽ‰ All canary checks passed!"
        echo "success=true" >> $GITHUB_OUTPUT

  # Phase 2: Parallel Unit Tests (only run if canary passes)
  unit-test-core:
    name: Unit Tests - Core Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-core == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/core/... ./pkg/pipeline/... ./pkg/utils/... ./pkg/docker/... ./pkg/k8s/... ./pkg/kind/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  unit-test-mcp:
    name: Unit Tests - MCP Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-mcp == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/mcp/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  unit-test-cli:
    name: Unit Tests - CLI Packages
    needs: canary
    if: needs.canary.outputs.should-continue == 'true' && needs.canary.outputs.test-cli == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './pkg/ai/...'
      run-tests: true
      run-race-tests: true
      run-lint: false
      coverage: true

  # Phase 3: Build Binaries (parallel with unit tests)
  build-cli:
    name: Build CLI Binary
    needs: canary
    if: needs.canary.outputs.should-continue == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './cmd/...'
      run-tests: false
      build-binary: true
      binary-output: 'container-kit'
      binary-main: './main.go'

  build-mcp:
    name: Build MCP Server
    needs: canary
    if: needs.canary.outputs.should-continue == 'true'
    uses: ./.github/workflows/reusable-go-build.yml
    with:
      go-version: '1.24'
      packages: './cmd/mcp-server/...'
      run-tests: false
      build-binary: true
      binary-output: 'container-kit-mcp'
      binary-main: './cmd/mcp-server'

  # Phase 4: Coverage Enforcement & Ratchet (after unit tests)
  coverage-enforcement:
    name: Coverage Enforcement
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: go mod download

    - name: Run coverage enforcement for core packages
      run: |
        echo "ðŸ“Š Running coverage enforcement..."

        # Define core packages that need coverage enforcement
        CORE_PACKAGES=(
          "./pkg/mcp/internal/core/..."
          "./pkg/mcp/internal/runtime/..."
          "./pkg/mcp/internal/orchestration/..."
          "./pkg/mcp/internal/session/..."
          "./pkg/mcp/internal/build/..."
          "./pkg/mcp/internal/deploy/..."
          "./pkg/mcp/internal/analyze/..."
          "./pkg/mcp/internal/server/..."
          "./pkg/mcp/types/..."
        )

        # Coverage thresholds (minimum required coverage percentages)
        declare -A COVERAGE_THRESHOLDS
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/core/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/runtime/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/orchestration/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/session/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/build/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/deploy/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/analyze/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/internal/server/..."]=15
        COVERAGE_THRESHOLDS["./pkg/mcp/types/..."]=15

        FAILED_PACKAGES=()

        for package in "${CORE_PACKAGES[@]}"; do
          echo "Checking coverage for $package..."

          # Run tests with coverage
          coverage_file="/tmp/coverage-$(echo $package | tr '/' '-' | tr '.' '-').out"
          if go test -coverprofile="$coverage_file" "$package" 2>/dev/null; then
            if [ -f "$coverage_file" ]; then
              # Extract coverage percentage
              coverage_line=$(go tool cover -func="$coverage_file" | grep "total:" | tail -1)
              if [ -n "$coverage_line" ]; then
                coverage_percent=$(echo "$coverage_line" | awk '{print $3}' | sed 's/%//')
                threshold=${COVERAGE_THRESHOLDS[$package]}

                echo "Package $package: ${coverage_percent}% coverage (threshold: ${threshold}%)"

                # Compare coverage with threshold
                if (( $(echo "$coverage_percent < $threshold" | bc -l) )); then
                  echo "âŒ $package coverage ${coverage_percent}% is below threshold ${threshold}%"
                  FAILED_PACKAGES+=("$package (${coverage_percent}% < ${threshold}%)")
                else
                  echo "âœ… $package coverage ${coverage_percent}% meets threshold ${threshold}%"
                fi
              else
                echo "âš ï¸ Could not extract coverage for $package"
              fi
            else
              echo "âš ï¸ No coverage file generated for $package"
            fi
          else
            echo "âš ï¸ Tests failed for $package"
          fi
        done

        # Report results
        if [ ${#FAILED_PACKAGES[@]} -eq 0 ]; then
          echo "ðŸŽ‰ All packages meet coverage requirements!"
        else
          echo "âŒ Coverage enforcement failed for the following packages:"
          for pkg in "${FAILED_PACKAGES[@]}"; do
            echo "  - $pkg"
          done
          echo ""
          echo "Please add tests to increase coverage for the failing packages."
          exit 1
        fi

    - name: Generate global coverage report
      run: |
        echo "ðŸ“Š Generating global coverage report..."
        
        # Run full test suite with coverage
        go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
        go tool cover -html=coverage.out -o coverage.html
        
        # Install coverage tools
        go install github.com/axw/gocov/gocov@latest
        go install github.com/AlekSi/gocov-xml@latest
        
        # Convert coverage to XML
        gocov convert coverage.out | gocov-xml > coverage.xml
        
        # Generate coverage summary
        go tool cover -func=coverage.out > coverage-summary.txt
        echo "## Global Coverage Summary" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        cat coverage-summary.txt >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

    - name: Check global coverage thresholds
      run: |
        # Extract total coverage
        TOTAL_COV=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "Total coverage: ${TOTAL_COV}%"
        
        # Set default thresholds (can be overridden with config file)
        MIN_THRESHOLD=10    # Minimum acceptable coverage
        TARGET_THRESHOLD=25 # Target coverage goal
        
        # Try to load from config file if it exists
        if [ -f .github/coverage-thresholds.json ]; then
          MIN_THRESHOLD=$(jq -r '.global.line_coverage.minimum' .github/coverage-thresholds.json 2>/dev/null || echo "10")
          TARGET_THRESHOLD=$(jq -r '.global.line_coverage.target' .github/coverage-thresholds.json 2>/dev/null || echo "25")
        fi
        
        echo "Minimum threshold: ${MIN_THRESHOLD}%"
        echo "Target threshold: ${TARGET_THRESHOLD}%"
        
        # Check if coverage meets minimum
        if (( $(echo "$TOTAL_COV < $MIN_THRESHOLD" | bc -l) )); then
          echo "âŒ Global coverage ${TOTAL_COV}% is below minimum threshold ${MIN_THRESHOLD}%"
          exit 1
        fi
        
        # Check if coverage meets target
        if (( $(echo "$TOTAL_COV >= $TARGET_THRESHOLD" | bc -l) )); then
          echo "âœ… Global coverage ${TOTAL_COV}% meets target threshold ${TARGET_THRESHOLD}%"
        else
          echo "âš ï¸ Global coverage ${TOTAL_COV}% meets minimum but is below target ${TARGET_THRESHOLD}%"
        fi

    - name: Check coverage ratchet (PR only)
      if: github.event_name == 'pull_request'
      run: |
        echo "ðŸ”„ Checking coverage ratchet..."
        
        # Get base branch coverage
        git checkout ${{ github.event.pull_request.base.sha }}
        go test -coverprofile=base-coverage.out ./... > /dev/null 2>&1 || true
        
        if [ -f base-coverage.out ]; then
          BASE_COV=$(go tool cover -func=base-coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          git checkout ${{ github.event.pull_request.head.sha }}
          CURRENT_COV=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          
          echo "Base coverage: ${BASE_COV}%"
          echo "Current coverage: ${CURRENT_COV}%"
          
          # Calculate difference
          DIFF=$(echo "$CURRENT_COV - $BASE_COV" | bc -l)
          
          # Set default tolerance (can be overridden with config file)
          TOLERANCE=2.0
          if [ -f .github/coverage-thresholds.json ]; then
            TOLERANCE=$(jq -r '.ratchet.regression_tolerance' .github/coverage-thresholds.json 2>/dev/null || echo "2.0")
          fi
          
          echo "Coverage change: ${DIFF}% (tolerance: -${TOLERANCE}%)"
          
          if (( $(echo "$DIFF < -$TOLERANCE" | bc -l) )); then
            echo "âŒ Coverage regression detected: ${DIFF}% (tolerance: -${TOLERANCE}%)"
            echo "## Coverage Ratchet Failed âŒ" >> $GITHUB_STEP_SUMMARY
            echo "Coverage decreased by ${DIFF}% which exceeds tolerance of -${TOLERANCE}%" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "âœ… Coverage ratchet passed: ${DIFF}%"
            echo "## Coverage Ratchet Passed âœ…" >> $GITHUB_STEP_SUMMARY
            echo "Coverage change: ${DIFF}%" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "âš ï¸ Could not determine base coverage, skipping ratchet check"
          echo "## Coverage Ratchet Skipped âš ï¸" >> $GITHUB_STEP_SUMMARY
          echo "Base coverage could not be determined" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: global-coverage-reports
        path: |
          coverage.out
          coverage.html
          coverage.xml
          coverage-summary.txt
          base-coverage.out
        retention-days: 30

  # Phase 5: Security Scanning (parallel with coverage)
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install Security Scanners
      run: |
        echo "ðŸ”’ Installing security scanners..."
        sudo apt-get update
        sudo apt-get install -y wget apt-transport-https gnupg lsb-release bc

        # Install Trivy
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install -y trivy

        # Install GitLeaks
        wget https://github.com/zricethezav/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz
        tar xzf gitleaks_8.18.0_linux_x64.tar.gz
        sudo mv gitleaks /usr/local/bin/
        chmod +x /usr/local/bin/gitleaks

    - name: Run GitLeaks (Secret Detection)
      run: |
        echo "ðŸ” Scanning for secrets..."
        
        # Create gitleaks config to exclude test files and known test patterns
        cat > .gitleaks.toml << 'EOF'
        [allowlist]
          description = "Test secrets and known safe patterns"
          
          # Exclude test files
          files = [
            '''.*_test\.go''',
            '''.*test.*\.go''',
            '''test/.*''',
            '''.*testdata.*''',
            '''examples/.*''',
            '''repomix-output\.xml'''
          ]
          
          # Exclude known test patterns
          regexes = [
            '''sk-1234567890abcdef''',
            '''AKIAFAKETEST12345678''',
            '''AKIAIOSFODNN7EXAMPLE''',
            '''test-api-key-123456''',
            '''zN8BP6lnPUDpumenHCZLVwZkFcSIGPr0''',
            '''dGhpcyBpcyBhIHNlY3JldCBtZXNzYWdl''',
            '''4e1243bd22c66e76c2ba9bef8c5e8f8a''',
            '''YOUR_PRIVATE_KEY_CONTENT_HERE_REPLACE_WITH_ACTUAL_KEY''',
            '''eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE''',
            '''dXNlcjpwYXNzd29yZA==''',
            '''abc123def456''',
            '''sk_test_abcdef123456'''
          ]
        EOF
        
        # Run gitleaks with config
        gitleaks detect --config .gitleaks.toml --report-format json --report-path gitleaks-report.json --verbose

        if [ -f gitleaks-report.json ]; then
          leak_count=$(jq '. | length' gitleaks-report.json 2>/dev/null || echo "0")
          echo "Found $leak_count potential secrets"

          if [ "$leak_count" -gt 0 ]; then
            echo "âŒ Potential secrets found!"
            jq -r '.[] | "- \(.RuleID): \(.File):\(.StartLine) - \(.Description)"' gitleaks-report.json
            exit 1
          else
            echo "âœ… No secrets detected"
          fi
        else
          echo "âœ… No secrets detected"
        fi

    - name: Run Trivy (Vulnerability Scanning)
      run: |
        echo "ðŸ›¡ï¸ Scanning for vulnerabilities..."

        # Scan filesystem for vulnerabilities
        trivy fs --format json --output trivy-fs-report.json .

        # Scan for configuration issues
        trivy config --format json --output trivy-config-report.json .

        # Process results
        fs_vulns=$(jq '.Results[]?.Vulnerabilities? // [] | length' trivy-fs-report.json | awk '{sum += $1} END {print sum+0}')
        config_issues=$(jq '.Results[]?.Misconfigurations? // [] | length' trivy-config-report.json | awk '{sum += $1} END {print sum+0}')

        echo "Found $fs_vulns filesystem vulnerabilities"
        echo "Found $config_issues configuration issues"

        # Report critical/high severity issues
        critical_vulns=$(jq '.Results[]?.Vulnerabilities? // [] | map(select(.Severity == "CRITICAL" or .Severity == "HIGH")) | length' trivy-fs-report.json | awk '{sum += $1} END {print sum+0}')

        if [ "$critical_vulns" -gt 0 ]; then
          echo "âŒ Found $critical_vulns critical/high severity vulnerabilities!"
          jq -r '.Results[]?.Vulnerabilities? // [] | map(select(.Severity == "CRITICAL" or .Severity == "HIGH")) | .[] | "- \(.Severity): \(.VulnerabilityID) in \(.PkgName) - \(.Title)"' trivy-fs-report.json
          exit 1
        else
          echo "âœ… No critical or high severity vulnerabilities found"
        fi

    - name: Upload security reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          gitleaks-report.json
          trivy-fs-report.json
          trivy-config-report.json
        retention-days: 30

  # Phase 6: Quality Gates (after coverage and security)
  quality-gates:
    name: Quality Gate Checks
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, coverage-enforcement, security-scan]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Quality gates summary
      run: |
        echo "ðŸŽ¯ Quality Gates Summary"
        echo "âœ… All unit tests passed"
        echo "âœ… All builds completed successfully"
        echo "âœ… Coverage enforcement passed"
        echo "âœ… Security scanning passed"
        echo "ðŸŽ‰ All quality gates passed!"

  # Phase 5: Integration Tests (after everything else)
  integration-tests:
    name: Integration Tests
    needs: [canary, unit-test-core, unit-test-cli, build-cli]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure() && needs.canary.outputs.test-cli == 'true'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download CLI binary
      uses: actions/download-artifact@v4
      with:
        name: container-kit-ubuntu-latest
        path: ./

    - name: Run integration tests
      run: |
        chmod +x container-kit
        echo "ðŸ§ª Running integration tests..."
        echo "Integration tests would run here with the built binary"

  # Phase 6: MCP Integration Tests (parallel with integration tests)
  mcp-integration-tests:
    name: MCP Integration Tests
    needs: [canary, unit-test-mcp, build-mcp]
    if: always() && needs.canary.outputs.should-continue == 'true' && !failure() && needs.canary.outputs.test-mcp == 'true'
    runs-on: ubuntu-latest

    services:
      docker:
        image: docker:dind
        options: --privileged

    steps:
    - uses: actions/checkout@v4

    - uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Install Kind
      run: |
        curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
        chmod +x ./kind
        sudo mv ./kind /usr/local/bin/kind

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Run MCP unit tests
      run: go test -v ./pkg/mcp/... -short

    - name: Run MCP unit tests with race detector
      run: go test -race -v ./pkg/mcp/... -short

    - name: Build MCP server
      run: go build -o container-kit-mcp ./cmd/mcp-server

    - name: Run MCP integration tests
      run: |
        export CONTAINER_KIT_TEST_WORKSPACE="/tmp/container-kit-test"
        export CONTAINER_KIT_LOG_LEVEL="debug"
        mkdir -p "$CONTAINER_KIT_TEST_WORKSPACE"
        go test -v ./test/integration/...

  # Phase 7: Testing Dashboard (after all tests complete)
  testing-dashboard:
    name: Testing Dashboard
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, quality-gates]
    if: github.event_name == 'pull_request' && needs.canary.outputs.should-continue == 'true' && !failure()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: |
        go mod download
        go mod tidy

    - name: Make scripts executable
      run: chmod +x scripts/generate-testing-report.sh

    - name: Generate testing dashboard
      env:
        CI: true
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_PR_NUMBER: ${{ github.event.number }}
      run: |
        # Install gh CLI if not present
        if ! command -v gh &> /dev/null; then
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh
        fi

        # Run the consolidated testing dashboard generator
        ./scripts/generate-testing-report.sh

    - name: Upload test coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-reports
        path: |
          /tmp/coverage-*.out
          coverage.out
        retention-days: 7

    - name: Upload testing report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: testing-report
        path: /tmp/testing-report.md
        retention-days: 30

  # Final Phase: Pipeline Summary
  pipeline-summary:
    name: Pipeline Summary
    runs-on: ubuntu-latest
    needs: [canary, unit-test-core, unit-test-mcp, unit-test-cli, build-cli, build-mcp, quality-gates, integration-tests, mcp-integration-tests, testing-dashboard]
    if: always()

    steps:
    - name: Pipeline Summary
      run: |
        echo "## ðŸš€ CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Phase Results" >> $GITHUB_STEP_SUMMARY
        echo "| Phase | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Canary Validation | ${{ needs.canary.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Core Unit Tests | ${{ needs.unit-test-core.result == 'success' && 'âœ… Passed' || needs.unit-test-core.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Unit Tests | ${{ needs.unit-test-mcp.result == 'success' && 'âœ… Passed' || needs.unit-test-mcp.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| CLI Unit Tests | ${{ needs.unit-test-cli.result == 'success' && 'âœ… Passed' || needs.unit-test-cli.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| CLI Build | ${{ needs.build-cli.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Build | ${{ needs.build-mcp.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Quality Gates | ${{ needs.quality-gates.result == 'success' && 'âœ… Passed' || needs.quality-gates.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Integration Tests | ${{ needs.integration-tests.result == 'success' && 'âœ… Passed' || needs.integration-tests.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| MCP Integration Tests | ${{ needs.mcp-integration-tests.result == 'success' && 'âœ… Passed' || needs.mcp-integration-tests.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Testing Dashboard | ${{ needs.testing-dashboard.result == 'success' && 'âœ… Passed' || needs.testing-dashboard.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Overall result
        if [ "${{ needs.canary.result }}" = "success" ]; then
          echo "### Overall Result: âœ… Pipeline Completed Successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "### Overall Result: âŒ Pipeline Failed at Canary Stage" >> $GITHUB_STEP_SUMMARY
        fi
