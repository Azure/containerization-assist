name: Quality Gates (Reusable)

on:
  workflow_call:
    inputs:
      source-ref:
        required: true
        type: string
      package-filter:
        required: false
        type: string
        default: './...'
    outputs:
      passed:
        description: "Whether all quality gates passed"
        value: ${{ jobs.quality-checks.outputs.passed }}
      results:
        description: "Detailed results as JSON"
        value: ${{ jobs.quality-checks.outputs.results }}
      summary:
        description: "Markdown summary of results"
        value: ${{ jobs.quality-checks.outputs.summary }}

jobs:
  quality-checks:
    runs-on: ubuntu-latest
    outputs:
      passed: ${{ steps.evaluate.outputs.passed }}
      results: ${{ steps.evaluate.outputs.results }}
      summary: ${{ steps.evaluate.outputs.summary }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.source-ref }}
          fetch-depth: 0  # For proper git history

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.1'
          cache: true

      - name: Install Tools
        run: |
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
          go install golang.org/x/tools/cmd/goimports@latest
          go install github.com/client9/misspell/cmd/misspell@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: File Length Check
        id: file-length
        continue-on-error: true
        run: |
          echo "## Checking file lengths (max 800 lines)..."
          violations=""
          count=0
          while IFS= read -r file; do
            if [[ "$file" == *_test.go ]]; then
              continue
            fi
            lines=$(wc -l < "$file")
            if [ $lines -gt 800 ]; then
              if [ $count -gt 0 ]; then violations="$violations,"; fi
              violations="$violations{\"file\": \"$file\", \"lines\": $lines}"
              count=$((count + 1))
            fi
          done < <(find ${{ inputs.package-filter }} -name "*.go" -type f 2>/dev/null || find . -name "*.go" -type f)

          violations="[$violations]"
          echo "file_length_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "❌ Found $count files exceeding 800 lines"
            exit 1
          else
            echo "✅ All files within length limit"
          fi

      - name: Complexity Check
        id: complexity
        continue-on-error: true
        run: |
          echo "## Checking cyclomatic complexity (max 15)..."
          violations=""
          count=0

          # Run gocyclo and capture output
          output=$(gocyclo -over 15 ${{ inputs.package-filter }} 2>&1 || true)

          if [ -n "$output" ]; then
            while IFS= read -r line; do
              if [[ "$line" =~ ^([0-9]+)[[:space:]]+(.*) ]]; then
                complexity="${BASH_REMATCH[1]}"
                function="${BASH_REMATCH[2]}"
                if [ $count -gt 0 ]; then violations="$violations,"; fi
                violations="$violations{\"complexity\": $complexity, \"function\": \"$function\"}"
                count=$((count + 1))
              fi
            done <<< "$output"
          fi

          violations="[$violations]"
          echo "complexity_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "❌ Found $count functions exceeding complexity 15"
            exit 1
          else
            echo "✅ All functions within complexity limit"
          fi

      - name: Import Cycle Detection
        id: cycles
        continue-on-error: true
        run: |
          echo "## Checking for import cycles..."

          # Try to detect cycles using go list
          cycles=""
          if output=$(go list -f '{{.ImportPath}}' ${{ inputs.package-filter }} 2>&1); then
            # Check for import cycles in the output
            if echo "$output" | grep -q "import cycle"; then
              cycles="Import cycles detected"
              echo "import_cycles=$cycles" >> $GITHUB_OUTPUT
              echo "❌ Found import cycles"
              exit 1
            fi
          fi

          echo "import_cycles=" >> $GITHUB_OUTPUT
          echo "✅ No import cycles detected"

      - name: Package Depth Check
        id: depth
        continue-on-error: true
        run: |
          echo "## Checking package depth (max 5 levels)..."
          violations=""
          count=0

          while IFS= read -r dir; do
            # Count slashes to determine depth (adjust base depth as needed)
            depth=$(echo "$dir" | awk -F/ '{print NF-1}')
            # Subtract base depth for pkg/mcp
            base_depth=3
            relative_depth=$((depth - base_depth))

            if [ $relative_depth -gt 5 ]; then
              if [ $count -gt 0 ]; then violations="$violations,"; fi
              violations="$violations{\"path\": \"$dir\", \"depth\": $relative_depth}"
              count=$((count + 1))
            fi
          done < <(find pkg/mcp -type d 2>/dev/null || true)

          violations="[$violations]"
          echo "depth_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "❌ Found $count packages exceeding depth 5"
            exit 1
          else
            echo "✅ All packages within depth limit"
          fi

      - name: Constructor Parameter Check
        id: constructors
        continue-on-error: true
        run: |
          echo "## Checking constructor parameters (max 5)..."
          violations=""
          count=0

          while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([0-9]+):(.*)$ ]]; then
              file="${BASH_REMATCH[1]}"
              lineno="${BASH_REMATCH[2]}"
              func="${BASH_REMATCH[3]}"

              # Count commas to estimate parameters (simple heuristic)
              # Extract content between parentheses
              if [[ "$func" =~ \(([^)]*)\) ]]; then
                params_content="${BASH_REMATCH[1]}"
                # Count commas, but skip if empty
                if [ -n "$params_content" ]; then
                  comma_count=$(echo "$params_content" | tr -cd ',' | wc -c)
                  param_count=$((comma_count + 1))

                  if [ $param_count -gt 5 ]; then
                    if [ $count -gt 0 ]; then violations="$violations,"; fi
                    violations="$violations{\"file\": \"$file:$lineno\", \"params\": $param_count, \"function\": \"${func//\"/\\\"}\"}"
                    count=$((count + 1))
                  fi
                fi
              fi
            fi
          done < <(grep -Hn "^func New" ${{ inputs.package-filter }} --include="*.go" 2>/dev/null || grep -Hn "^func New" . --include="*.go")

          violations="[$violations]"
          echo "constructor_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "❌ Found $count constructors with >5 parameters"
            exit 1
          else
            echo "✅ All constructors within parameter limit"
          fi

      - name: Context Propagation Check
        id: context
        continue-on-error: true
        run: |
          echo "## Checking context propagation..."
          violations=""
          count=0

          while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([0-9]+):(.*)$ ]]; then
              file="${BASH_REMATCH[1]}"
              lineno="${BASH_REMATCH[2]}"
              code="${BASH_REMATCH[3]}"

              if [ $count -gt 0 ]; then violations="$violations,"; fi
              violations="$violations{\"location\": \"$file:$lineno\", \"line\": \"${code//\"/\\\"}\"}"
              count=$((count + 1))
            fi
          done < <(grep -rn "context\.Background()" ${{ inputs.package-filter }} --include="*.go" --exclude="*_test.go" 2>/dev/null || true)

          violations="[$violations]"
          echo "context_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "⚠️  Found $count context.Background() usages in non-test files"
          else
            echo "✅ Proper context propagation"
          fi

      - name: Print Statement Check
        id: print
        continue-on-error: true
        run: |
          echo "## Checking for print statements..."
          violations=""
          count=0

          # Search for various print statements
          patterns="fmt\.Print|log\.Print|println"

          while IFS= read -r line; do
            if [[ "$line" =~ ^([^:]+):([0-9]+):(.*)$ ]]; then
              file="${BASH_REMATCH[1]}"
              lineno="${BASH_REMATCH[2]}"
              statement="${BASH_REMATCH[3]}"

              if [ $count -gt 0 ]; then violations="$violations,"; fi
              violations="$violations{\"location\": \"$file:$lineno\", \"statement\": \"${statement//\"/\\\"}\"}"
              count=$((count + 1))
            fi
          done < <(grep -rn -E "$patterns" ${{ inputs.package-filter }} --include="*.go" --exclude="*_test.go" 2>/dev/null || true)

          violations="[$violations]"
          echo "print_violations=$violations" >> $GITHUB_OUTPUT

          if [ $count -gt 0 ]; then
            echo "❌ Found $count print statements in non-test files"
            exit 1
          else
            echo "✅ No print statements found"
          fi

      - name: Documentation Check
        id: docs
        continue-on-error: true
        run: |
          echo "## Checking documentation coverage..."

          # Count exported identifiers
          total_exports=0
          documented=0

          while IFS= read -r file; do
            if [[ "$file" == *_test.go ]]; then
              continue
            fi

            # Count exported functions, types, consts, vars
            file_exports=$(grep -c "^func [A-Z]\|^type [A-Z]\|^const [A-Z]\|^var [A-Z]" "$file" 2>/dev/null || echo 0)
            total_exports=$((total_exports + file_exports))

            # Count those with comments (simplified check)
            file_documented=$(grep -B1 "^func [A-Z]\|^type [A-Z]\|^const [A-Z]\|^var [A-Z]" "$file" 2>/dev/null | grep -c "^//" || echo 0)
            documented=$((documented + file_documented))
          done < <(find ${{ inputs.package-filter }} -name "*.go" -type f 2>/dev/null || find . -name "*.go" -type f)

          if [ $total_exports -gt 0 ]; then
            coverage=$((documented * 100 / total_exports))
          else
            coverage=100
          fi

          echo "doc_coverage=$coverage" >> $GITHUB_OUTPUT
          echo "doc_total=$total_exports" >> $GITHUB_OUTPUT
          echo "doc_documented=$documented" >> $GITHUB_OUTPUT

          if [ $coverage -lt 80 ]; then
            echo "⚠️  Documentation coverage: $coverage% (target: 80%)"
          else
            echo "✅ Documentation coverage: $coverage%"
          fi

      - name: Evaluate Results
        id: evaluate
        run: |
          # Create results JSON
          cat > results.json << EOF
          {
            "file_length": {
              "passed": ${{ steps.file-length.outcome == 'success' }},
              "violations": ${{ steps.file-length.outputs.file_length_violations || '[]' }}
            },
            "complexity": {
              "passed": ${{ steps.complexity.outcome == 'success' }},
              "violations": ${{ steps.complexity.outputs.complexity_violations || '[]' }}
            },
            "import_cycles": {
              "passed": ${{ steps.cycles.outcome == 'success' }},
              "cycles": "${{ steps.cycles.outputs.import_cycles || '' }}"
            },
            "package_depth": {
              "passed": ${{ steps.depth.outcome == 'success' }},
              "violations": ${{ steps.depth.outputs.depth_violations || '[]' }}
            },
            "constructors": {
              "passed": ${{ steps.constructors.outcome == 'success' }},
              "violations": ${{ steps.constructors.outputs.constructor_violations || '[]' }}
            },
            "context": {
              "passed": ${{ steps.context.outcome == 'success' }},
              "violations": ${{ steps.context.outputs.context_violations || '[]' }}
            },
            "print_statements": {
              "passed": ${{ steps.print.outcome == 'success' }},
              "violations": ${{ steps.print.outputs.print_violations || '[]' }}
            },
            "documentation": {
              "coverage": ${{ steps.docs.outputs.doc_coverage || 0 }},
              "total": ${{ steps.docs.outputs.doc_total || 0 }},
              "documented": ${{ steps.docs.outputs.doc_documented || 0 }}
            }
          }
          EOF

          # Determine overall pass/fail
          passed=$(jq '
            .file_length.passed and
            .complexity.passed and
            .import_cycles.passed and
            .package_depth.passed and
            .constructors.passed and
            .print_statements.passed
          ' results.json)

          echo "passed=$passed" >> $GITHUB_OUTPUT
          echo "results=$(cat results.json | jq -c)" >> $GITHUB_OUTPUT

          # Generate summary
          ./.github/scripts/generate-quality-summary.sh results.json > summary.md
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          cat summary.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: quality-gate-results
          path: |
            results.json
            summary.md
