name: Test Containerization Capability

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository URL to containerize (e.g., https://github.com/konveyor-ecosystem/coolstore)'
        required: false
        type: string
        default: 'https://github.com/konveyor-ecosystem/coolstore'

jobs:
  test-containerization:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    env:
      AZURE_OPENAI_DEPLOYMENT_ID: ${{ secrets.AZURE_OPENAI_DEPLOYMENT_ID }}
      AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
      AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
      # If triggered manually, allow overriding the repo; else default to Coolstore
      CONTAINERIZE_REPO: ${{ github.event_name == 'workflow_dispatch' && inputs.repo || 'https://github.com/konveyor-ecosystem/coolstore' }}
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          
      - name: Setup Docker and Kubernetes tools
        run: |
          # Verify Docker is working
          docker --version
          docker info
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client
          
          # Install kind (Kubernetes in Docker)
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind version
          
          # Install jq for JSON parsing used by hooks
          sudo apt-get update -y
          sudo apt-get install -y jq
          
      - name: Install mcphost
        run: |
          echo "Installing mcphost binary..."
          # Use specific version v0.29.0 - download the correct Linux x86_64 archive
          VERSION="v0.29.0"
          echo "Installing mcphost version: $VERSION"
          
          # Download and extract mcphost binary from tar.gz
          curl -L -o mcphost.tar.gz "https://github.com/mark3labs/mcphost/releases/download/${VERSION}/mcphost_Linux_x86_64.tar.gz"
          tar -xzf mcphost.tar.gz
          chmod +x mcphost
          sudo mv mcphost /usr/local/bin/
          rm -f mcphost.tar.gz
          mcphost --version
          echo "✅ mcphost v0.29.0 installed successfully"
          
      - name: Build MCP Server from PR
        run: |
          echo "Building Container Kit MCP Server from PR code..."
          go build -tags mcp -o container-kit-mcp ./cmd/mcp-server
          chmod +x container-kit-mcp
          ls -la container-kit-mcp
          echo "✅ MCP Server binary ready"
          
      - name: Create mcphost configuration
        run: |
          echo "Creating mcphost configuration..."
          mkdir -p ~/.config/mcphost
          
          # Copy the main configuration template
          cp .github/workflows/mcphost/config.yml ~/.mcphost.yml

          # Install hooks config and tracking script
          mkdir -p .mcphost
          if [ -f ".github/workflows/mcphost/hooks.yml" ]; then
            cp .github/workflows/mcphost/hooks.yml .mcphost/hooks.yml
            echo "Installed hooks.yml"
            # Also install hooks to user config dir to ensure discovery
            cp .github/workflows/mcphost/hooks.yml ~/.config/mcphost/hooks.yml
            echo "Installed hooks.yml to ~/.config/mcphost/hooks.yml"
          fi
          if [ -f ".github/workflows/mcphost/track-tools.sh" ]; then
            cp .github/workflows/mcphost/track-tools.sh /tmp/track-tools.sh
            chmod +x /tmp/track-tools.sh
            echo "Installed track-tools.sh"
          fi

          echo "Configuration created successfully"
          
          # Create workspace directory and copy MCP binary there
          mkdir -p /tmp/test-workspace
          cp ./container-kit-mcp /tmp/test-workspace/
          
          # Also ensure the binary is in the current directory for mcphost
          ls -la ./container-kit-mcp
          
          # Show the full configuration
          echo "=== mcphost configuration ==="
          cat ~/.mcphost.yml
          echo ""
          
      - name: Test MCP Server and LLM connection
        run: |
          echo "Testing MCP Server and LLM connection..."
          echo "Current working directory: $(pwd)"
          echo "MCP Server binary location:"
          ls -la ./container-kit-mcp
          echo ""
          
          # Simple test to verify MCP tools are loaded
          set +e
          HELLO_RESULT=$(timeout 30s mcphost --quiet --stream=false -p "If you have access to containerization tools (mcp_containerkit tools), respond with 'successful'. If you do not have access to containerization tools, respond with 'unsuccessful' and nothing else." 2>&1)
          HELLO_EXIT_CODE=$?
          set -e
          
          echo "=== MCP TOOLS TEST OUTPUT ==="
          echo "$HELLO_RESULT"
          echo "=== END TOOLS TEST ==="
          echo ""
          
          # Check for explicit unsuccessful response
          if echo "$HELLO_RESULT" | grep -i "unsuccessful" > /dev/null; then
            echo "❌ CRITICAL: MCP server failed - LLM responded 'unsuccessful'"
            echo "This means containerization tools are not available."
            echo "Stopping execution."
            exit 1
          elif echo "$HELLO_RESULT" | grep -i "successful" > /dev/null; then
            echo "✅ MCP tools test PASSED - Container tools are available"
          else
            echo "❌ MCP tools test FAILED - Unexpected response"
            echo "Expected 'successful' or 'unsuccessful' but got different response"
            echo "Full response for analysis:"
            echo "\"$HELLO_RESULT\""
            exit 1
          fi
          echo ""
          
      - name: Run containerization test
        id: test
        run: |
          echo "Running containerization test..."
          echo "Current working directory: $(pwd)"
          echo "MCP Server will be started by mcphost via stdio"
          echo ""

          echo "Target repository to containerize: $CONTAINERIZE_REPO"
          if [ -z "$CONTAINERIZE_REPO" ]; then
            echo "No CONTAINERIZE_REPO provided; exiting."
            exit 1
          fi

          # Test with the Konveyor Coolstore application using mcphost
          # mcphost will start the MCP server via stdio and communicate directly
          echo "Starting mcphost with containerization request..."
          echo "MCP server will be started automatically by mcphost via stdio"
          echo ""

          # Capture both stdout and stderr, and don't exit on failure
          set +e
          # Reduce interactive/TTY output noise and allow more time for deploy/debug loops
          export NO_COLOR=1
          export TERM=dumb
          RESULT=$(timeout 900s mcphost --quiet --stream=false -p "Please containerize this repository: ${CONTAINERIZE_REPO}. This is an automated test - do NOT ask for user input." 2>&1)
          EXIT_CODE=$?
          set -e
          
          echo ""
          echo "Test completed with exit code: $EXIT_CODE"
          echo ""
          echo "=== MCPHOST OUTPUT ==="
          echo "$RESULT"
          echo "=== END OUTPUT ==="
          echo ""
          
          # Save result and exit code for next step
          echo "RESULT<<EOF" >> $GITHUB_ENV
          echo "$RESULT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "EXIT_CODE=$EXIT_CODE" >> $GITHUB_ENV
          # Persist full output to a file for artifacts and summary
          echo "$RESULT" > /tmp/mcphost-output.txt

      - name: Collect Kubernetes diagnostics on failure
        if: always()
        run: |
          if [ -n "${EXIT_CODE:-}" ] && [ "${EXIT_CODE}" -ne 0 ]; then
            echo "=== Collecting Kubernetes diagnostics (failure path) ==="
            if command -v kubectl &> /dev/null; then
              : > /tmp/k8s-diagnostics.txt
              {
                echo "\n--- get all (default) ---"
                kubectl get all -o wide || true
                echo "\n--- get all (all namespaces) ---"
                kubectl get all -A -o wide || true
                echo "\n--- describe deployments (all namespaces) ---"
                kubectl get deploy -A -o name | xargs -r -L1 kubectl describe || true
                echo "\n--- recent events ---"
                kubectl get events -A --sort-by=.lastTimestamp | tail -n 100 || true
              } | tee -a /tmp/k8s-diagnostics.txt
            else
              echo "kubectl not available for diagnostics"
            fi
          else
            echo "Diagnostics skipped: EXIT_CODE indicates success"
          fi
          
      - name: Analyze results and report
        run: |
          echo "=== Artifact-Based Analysis (no phrases) ==="

          # Immediate failure if mcphost exited non-zero
          if [ -n "$EXIT_CODE" ] && [ "$EXIT_CODE" -ne 0 ]; then
            echo "❌ mcphost returned non-zero exit code: $EXIT_CODE"
            echo "SUMMARY_EXIT_CODE=$EXIT_CODE" >> $GITHUB_ENV
            exit 1
          fi

          # Determine repo name for context
          REPO_NAME=$(basename "$CONTAINERIZE_REPO"); REPO_NAME=${REPO_NAME%.git}
          echo "Analyzing artifacts for repo: $REPO_NAME"

          # Locate Dockerfile
          DOCKERFILE_PATH=""
          if [ -f "Dockerfile" ]; then
            DOCKERFILE_PATH="$(pwd)/Dockerfile"
          elif [ -f "/tmp/test-workspace/Dockerfile" ]; then
            DOCKERFILE_PATH="/tmp/test-workspace/Dockerfile"
          else
            DF_CANDIDATE=$(find /tmp -type f -name "Dockerfile" 2>/dev/null | head -1)
            if [ -n "$DF_CANDIDATE" ]; then
              DOCKERFILE_PATH="$DF_CANDIDATE"
            fi
          fi

          if [ -z "$DOCKERFILE_PATH" ]; then
            echo "❌ No Dockerfile found"
            echo "Full output:"; echo "$RESULT"
            echo "SUMMARY_DOCKERFILE_FOUND=false" >> $GITHUB_ENV
            echo "SUMMARY_DOCKERFILE_HAS_FROM=false" >> $GITHUB_ENV
            exit 1
          fi

          echo "Found Dockerfile at: $DOCKERFILE_PATH"
          echo "SUMMARY_DOCKERFILE_FOUND=true" >> $GITHUB_ENV
          echo "SUMMARY_DOCKERFILE_PATH=$DOCKERFILE_PATH" >> $GITHUB_ENV
          if ! grep -Ei '^\s*FROM\s+' "$DOCKERFILE_PATH" >/dev/null; then
            echo "❌ Dockerfile missing FROM instruction"
            echo "SUMMARY_DOCKERFILE_HAS_FROM=false" >> $GITHUB_ENV
            exit 1
          fi
          echo "SUMMARY_DOCKERFILE_HAS_FROM=true" >> $GITHUB_ENV

          # Locate at least one Kubernetes Deployment manifest with an image
          MANIFEST_OK=false
          while IFS= read -r -d '' mf; do
            if grep -Ei '^\s*kind:\s*Deployment\b' "$mf" >/dev/null && grep -Ei '^\s*image:\s*' "$mf" >/dev/null; then
              echo "Found Deployment manifest with image: $mf"
              MANIFEST_OK=true
              break
            fi
          done < <(find /tmp -type f \( -name "*.yaml" -o -name "*.yml" \) 2>/dev/null -print0)

          if [ "$MANIFEST_OK" != true ]; then
            echo "❌ No Kubernetes Deployment manifest with image found"
            echo "Searched under /tmp for *.yaml/*.yml"
            echo "SUMMARY_MANIFEST_PRESENT=false" >> $GITHUB_ENV
            exit 1
          fi

          echo "✅ Concrete checks passed: Dockerfile valid and Deployment manifest present"
          echo "SUMMARY_MANIFEST_PRESENT=true" >> $GITHUB_ENV
          echo "SUMMARY_EXIT_CODE=0" >> $GITHUB_ENV
          exit 0

      - name: Verify all container tools executed successfully
        if: always()
        run: |
          echo "Verifying required tool calls via hooks log..."
          REQUIRED=(
            analyze_repository
            generate_dockerfile
            build_image
            scan_image
            tag_image
            push_image
            generate_k8s_manifests
            prepare_cluster
            deploy_application
            verify_deployment
          )

          if [ ! -f /tmp/tool-success.log ]; then
            echo "❌ Hooks log not found; required tool success list is empty"
            echo "SUMMARY_TOOLS_OK=false" >> $GITHUB_ENV
            echo "SUMMARY_TOOLS_MISSING=all" >> $GITHUB_ENV
            exit 1
          fi

          MISSING=()
          for t in "${REQUIRED[@]}"; do
            if ! grep -q "^${t}$" /tmp/tool-success.log; then
              MISSING+=("$t")
            fi
          done

          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "❌ Missing successful calls for tools: ${MISSING[*]}"
            echo "Logged successes:"; sort -u /tmp/tool-success.log || true
            echo "SUMMARY_TOOLS_OK=false" >> $GITHUB_ENV
            echo "SUMMARY_TOOLS_MISSING=${MISSING[*]}" >> $GITHUB_ENV
            exit 1
          fi

          echo "✅ All required tools had at least one successful call"
          echo "SUMMARY_TOOLS_OK=true" >> $GITHUB_ENV
          
      - name: Show generated artifacts and deployment status
        if: always()
        run: |
          echo "=== POST-TEST ARTIFACTS AND STATUS ==="
          echo ""
          
          echo "=== mcphost Output Analysis ==="
          if [ -n "$RESULT" ]; then
            echo "mcphost execution summary:"
            echo "$RESULT" | grep -E "(✅|❌|success|fail|error|complete)" | head -10 || echo "No clear status indicators found"
          else
            echo "No mcphost output captured"
          fi
          echo ""
          
          echo "=== Kubernetes Pods Status ==="
          if command -v kubectl &> /dev/null; then
            # Try to get pods from default namespace and any detected namespaces
            echo "Checking pods in default namespace:"
            kubectl get pods -o wide 2>/dev/null || echo "No pods found or kubectl not configured"
            echo ""
            
            # Check for any pods related to the target repo across all namespaces
            echo "Searching for application pods across all namespaces:"
            REPO_NAME=$(basename "$CONTAINERIZE_REPO"); REPO_NAME=${REPO_NAME%.git}
            kubectl get pods --all-namespaces | grep -i "${REPO_NAME}\|coolstore\|java\|servlet" 2>/dev/null || echo "No application pods found"
            echo ""
            
            # Show services as well
            echo "Services:"
            kubectl get services -o wide 2>/dev/null || echo "No services found"
            echo ""
          else
            echo "kubectl not available"
          fi
          
          echo "=== Generated Dockerfile ==="
          # Look for Dockerfile in common locations
          if [ -f "Dockerfile" ]; then
            echo "Found Dockerfile in root:"
            cat Dockerfile
          elif [ -f "/tmp/test-workspace/Dockerfile" ]; then
            echo "Found Dockerfile in test workspace:"
            cat /tmp/test-workspace/Dockerfile
          elif find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1 | xargs test -f; then
            DOCKERFILE_PATH=$(find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1)
            echo "Found Dockerfile at: $DOCKERFILE_PATH"
            cat "$DOCKERFILE_PATH"
          else
            echo "No Dockerfile found"
          fi
          echo ""
          
          echo "=== Generated Kubernetes Manifests ==="
          # Look for manifest files in common locations
          MANIFEST_FOUND=false
          for pattern in "*.yaml" "*.yml" "*manifest*" "*deployment*" "*service*"; do
            if find /tmp -name "$pattern" -type f 2>/dev/null | grep -v mcphost-config | head -5; then
              MANIFEST_FOUND=true
              echo ""
              find /tmp -name "$pattern" -type f 2>/dev/null | grep -v mcphost-config | head -5 | while read -r manifest; do
                echo "=== Manifest: $manifest ==="
                cat "$manifest"
                echo ""
              done
            fi
          done
          
          if [ "$MANIFEST_FOUND" = false ]; then
            echo "No Kubernetes manifest files found"
          fi
          
          echo "=== Docker Images ==="
          echo "Available Docker images:"
          docker images | head -10 || echo "Unable to list Docker images"
          echo ""
          
          echo "=== Working Directory Contents ==="
          ls -la
          echo ""
          
          echo "=== Temp Directory Structure ==="
          find /tmp -type f -name "*.yaml" -o -name "*.yml" -o -name "Dockerfile" 2>/dev/null | head -10 || echo "No relevant files found in temp"

      - name: Collect containerization artifacts
        if: always()
        run: |
          set -e
          ART_DIR="containerization-artifacts"
          rm -rf "$ART_DIR" && mkdir -p "$ART_DIR/manifests"

          # Resolve Dockerfile path (same logic as above)
          DOCKERFILE_PATH=""
          if [ -f "Dockerfile" ]; then
            DOCKERFILE_PATH="$(pwd)/Dockerfile"
          elif [ -f "/tmp/test-workspace/Dockerfile" ]; then
            DOCKERFILE_PATH="/tmp/test-workspace/Dockerfile"
          else
            CANDIDATE=$(find /tmp -type f -name "Dockerfile" 2>/dev/null | head -1)
            if [ -n "$CANDIDATE" ]; then
              DOCKERFILE_PATH="$CANDIDATE"
            fi
          fi

          if [ -n "$DOCKERFILE_PATH" ] && [ -f "$DOCKERFILE_PATH" ]; then
            cp "$DOCKERFILE_PATH" "$ART_DIR/"
            echo "Dockerfile: $(basename "$DOCKERFILE_PATH")" >> "$ART_DIR/index.txt"
          fi

          # Collect manifests (limit to 50 to avoid oversized artifacts)
          COUNT=0
          while IFS= read -r -d '' mf; do
            base=$(basename "$mf")
            cp "$mf" "$ART_DIR/manifests/$base" || true
            COUNT=$((COUNT+1))
            [ $COUNT -ge 50 ] && break
          done < <(find /tmp -type f \( -name "*.yaml" -o -name "*.yml" \) 2>/dev/null | grep -v mcphost-config | head -50 | tr '\n' '\0')

          echo "Manifests collected: $COUNT" >> "$ART_DIR/index.txt"
          echo "Repository: $CONTAINERIZE_REPO" >> "$ART_DIR/index.txt"
          # Include full mcphost output if present
          if [ -f /tmp/mcphost-output.txt ]; then
            cp /tmp/mcphost-output.txt "$ART_DIR/"
            echo "mcphost-output: mcphost-output.txt" >> "$ART_DIR/index.txt"
          fi
          # Include Kubernetes diagnostics if present
          if [ -f /tmp/k8s-diagnostics.txt ]; then
            cp /tmp/k8s-diagnostics.txt "$ART_DIR/"
            echo "k8s-diagnostics: k8s-diagnostics.txt" >> "$ART_DIR/index.txt"
          fi

      - name: Upload containerization artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: containerization-artifacts-${{ github.run_id }}
          path: containerization-artifacts/
          if-no-files-found: warn
          retention-days: 7

      - name: Write clean job summary
        if: always()
        run: |
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          ART_NAME="containerization-artifacts-${{ github.run_id }}"
          REPO="${CONTAINERIZE_REPO}"
          EXIT="${SUMMARY_EXIT_CODE:-${EXIT_CODE:-unknown}}"
          DF_FOUND="${SUMMARY_DOCKERFILE_FOUND:-unknown}"
          DF_FROM="${SUMMARY_DOCKERFILE_HAS_FROM:-unknown}"
          MF_PRESENT="${SUMMARY_MANIFEST_PRESENT:-unknown}"
          TOOLS_OK="${SUMMARY_TOOLS_OK:-unknown}"
          TOOLS_MISSING="${SUMMARY_TOOLS_MISSING:-none}"

          status_badge() {
            case "$1" in
              true|0) echo "✅" ;;
              false|1) echo "❌" ;;
              *) echo "⚠️" ;;
            esac
          }

          echo "# Containerization Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| Repository | ${REPO} |" >> $GITHUB_STEP_SUMMARY
          echo "| Exit code | ${EXIT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile found | $(status_badge "$DF_FOUND") ${DF_FOUND} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dockerfile has FROM | $(status_badge "$DF_FROM") ${DF_FROM} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment manifest present | $(status_badge "$MF_PRESENT") ${MF_PRESENT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Required tools | $(status_badge "$TOOLS_OK") ${TOOLS_OK} |" >> $GITHUB_STEP_SUMMARY
          if [ "${TOOLS_OK}" != "true" ]; then
            echo "| Missing tools | ${TOOLS_MISSING} |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Run page (download artifacts at bottom): ${RUN_URL}" >> $GITHUB_STEP_SUMMARY
          echo "- Artifact: ${ART_NAME}" >> $GITHUB_STEP_SUMMARY

          echo "\n<details><summary>mcphost output (full file in artifacts)</summary>" >> $GITHUB_STEP_SUMMARY
          if [ -f /tmp/mcphost-output.txt ]; then
            MAX=120000
            SIZE=$(wc -c < /tmp/mcphost-output.txt)
            if [ "$SIZE" -gt "$MAX" ]; then
              echo "\n(Truncated to $MAX bytes)\n" >> $GITHUB_STEP_SUMMARY
              {
                echo '```'
                head -c $MAX /tmp/mcphost-output.txt
                echo
                echo '```'
              } >> $GITHUB_STEP_SUMMARY
            else
              {
                echo '```'
                cat /tmp/mcphost-output.txt
                echo
                echo '```'
              } >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "(No mcphost output captured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "</details>" >> $GITHUB_STEP_SUMMARY

          echo "\n<details><summary>Kubernetes diagnostics (on failure)</summary>" >> $GITHUB_STEP_SUMMARY
          if [ -f /tmp/k8s-diagnostics.txt ]; then
            MAX=80000
            SIZE=$(wc -c < /tmp/k8s-diagnostics.txt)
            if [ "$SIZE" -gt "$MAX" ]; then
              echo "\n(Truncated to $MAX bytes)\n" >> $GITHUB_STEP_SUMMARY
              {
                echo '```'
                head -c $MAX /tmp/k8s-diagnostics.txt
                echo
                echo '```'
              } >> $GITHUB_STEP_SUMMARY
            else
              {
                echo '```'
                cat /tmp/k8s-diagnostics.txt
                echo
                echo '```'
              } >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "(No diagnostics captured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "</details>" >> $GITHUB_STEP_SUMMARY
