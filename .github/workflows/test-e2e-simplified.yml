name: E2E Containerization Test (Simplified)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository URL to containerize'
        required: false
        type: string
        default: 'https://github.com/konveyor-ecosystem/coolstore'

jobs:
  e2e-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    env:
      AZURE_OPENAI_DEPLOYMENT_ID: ${{ secrets.AZURE_OPENAI_DEPLOYMENT_ID }}
      AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
      AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
      CONTAINERIZE_REPO: ${{ github.event_name == 'workflow_dispatch' && inputs.repo || 'https://github.com/konveyor-ecosystem/coolstore' }}
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          
      - name: Setup Environment
        run: |
          # Verify Docker is working
          docker --version
          docker info
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client
          
          # Install kind (Kubernetes in Docker)
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind version
          
          # Install mcphost
          VERSION="v0.29.0"
          curl -L -o mcphost.tar.gz "https://github.com/mark3labs/mcphost/releases/download/${VERSION}/mcphost_Linux_x86_64.tar.gz"
          tar -xzf mcphost.tar.gz
          chmod +x mcphost
          sudo mv mcphost /usr/local/bin/
          rm -f mcphost.tar.gz
          mcphost --version
          
      - name: Build MCP Server
        run: |
          echo "Building Container Kit MCP Server from PR code..."
          go build -tags mcp -o container-kit-mcp .
          chmod +x container-kit-mcp
          ls -la container-kit-mcp
          
      - name: Configure mcphost
        run: |
          mkdir -p ~/.config/mcphost
          cat > ~/.mcphost.yml << 'EOF'
          # MCP Host Configuration
          version: "1"
          default-model: azure
          models:
            azure:
              type: "azure"
              deployment: "${{ env.AZURE_OPENAI_DEPLOYMENT_ID }}"
              endpoint: "${{ env.AZURE_OPENAI_ENDPOINT }}"
              api-key: "${{ env.AZURE_OPENAI_KEY }}"
              api-version: "2024-08-01-preview"
          servers:
            container-kit:
              command: "./container-kit-mcp"
              args: []
              env:
                AZURE_OPENAI_DEPLOYMENT_ID: "${{ env.AZURE_OPENAI_DEPLOYMENT_ID }}"
                AZURE_OPENAI_KEY: "${{ env.AZURE_OPENAI_KEY }}"
                AZURE_OPENAI_ENDPOINT: "${{ env.AZURE_OPENAI_ENDPOINT }}"
          EOF
          
          # Create workspace and copy MCP binary
          mkdir -p /tmp/test-workspace
          cp ./container-kit-mcp /tmp/test-workspace/
          
      - name: Execute Containerization via MCP
        run: |
          echo "Starting containerization of: $CONTAINERIZE_REPO"
          cd /tmp/test-workspace
          
          # Execute containerization using non-interactive mode with proper prompt
          timeout 600s mcphost --model azure --prompt "Please containerize this repository: ${CONTAINERIZE_REPO}. This is an automated test." --quiet > /tmp/mcp.log 2>&1 || true
          
          # Save log for debugging
          echo "Containerization process completed"
          
      - name: Verify Docker Image Exists
        id: verify-image
        run: |
          echo "=== Checking for Docker images ==="
          
          # List all images for debugging
          docker images
          
          # Extract repository name from URL to make it generic
          REPO_NAME=$(echo "$CONTAINERIZE_REPO" | sed -E 's|.*/([^/]+)/?$|\1|' | tr '[:upper:]' '[:lower:]')
          echo "Looking for images related to: $REPO_NAME"
          
          # Look for the containerized image with improved generic patterns
          IMAGE_NAME=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>" | grep -v "^registry\." | grep -v "^docker\.io" | head -1)
          
          # If no image found, this is a failure
          if [ -z "$IMAGE_NAME" ]; then
            echo "❌ FAIL: No Docker image found"
            echo "Available images:"
            docker images
            echo "Expected to find an image for repository: $REPO_NAME"
            exit 1
          fi
          
          echo "✅ SUCCESS: Found Docker image: $IMAGE_NAME"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "image=$IMAGE_NAME" >> $GITHUB_OUTPUT
          
      - name: Extract Port from Dockerfile
        id: extract-port
        run: |
          echo "=== Extracting port information ==="
          
          # Find Dockerfile
          DOCKERFILE=$(find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1)
          
          if [ -n "$DOCKERFILE" ]; then
            # Extract EXPOSE port from Dockerfile
            EXPOSED_PORT=$(grep -E "^EXPOSE" "$DOCKERFILE" | head -1 | awk '{print $2}' | sed 's/[^0-9]//g')
            echo "Found EXPOSE port: $EXPOSED_PORT"
          fi
          
          # Also check generated K8s manifests for port info
          K8S_PORT=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | xargs grep -h "targetPort:\|containerPort:" 2>/dev/null | head -1 | grep -oE '[0-9]+' | head -1)
          
          # Use the first port we find, defaulting to common ports
          PORT=${EXPOSED_PORT:-$K8S_PORT}
          PORT=${PORT:-8080}
          
          echo "Using port: $PORT"
          echo "PORT=$PORT" >> $GITHUB_ENV
          echo "port=$PORT" >> $GITHUB_OUTPUT
          
      - name: Test Container Locally
        run: |
          echo "=== Testing container locally ==="
          
          # Run the container with discovered port
          docker run -d -p ${PORT}:${PORT} --name test-app $IMAGE_NAME || {
            echo "Failed with port $PORT, trying common ports..."
            for try_port in 3000 5000 8000 80; do
              docker rm -f test-app 2>/dev/null || true
              if docker run -d -p ${try_port}:${try_port} --name test-app $IMAGE_NAME; then
                PORT=$try_port
                echo "PORT=$PORT" >> $GITHUB_ENV
                break
              fi
            done
          }
          
          # Give it time to start
          sleep 15
          
          # Check if container is running
          if ! docker ps | grep test-app; then
            echo "Container failed to start. Logs:"
            docker logs test-app
            exit 1
          fi
          
          echo "✅ Container is running"
          docker ps | grep test-app
          
          # Try to access the application
          ACCESSIBLE=false
          for endpoint in "/" "/health" "/api/health" "/status" "/api/status"; do
            if curl -f -m 5 "http://localhost:${PORT}${endpoint}" 2>/dev/null; then
              echo "✅ SUCCESS: Container responds on port $PORT at endpoint $endpoint"
              ACCESSIBLE=true
              break
            fi
          done
          
          if [ "$ACCESSIBLE" = "false" ]; then
            echo "⚠️  WARNING: Container is running but not responding to HTTP requests"
            echo "This may be normal for non-web applications"
          fi
          
      - name: Verify Kubernetes Deployment
        id: verify-k8s
        run: |
          echo "=== Checking Kubernetes deployment ==="
          
          # Check if kind cluster exists
          if kind get clusters 2>/dev/null | grep -q .; then
            echo "✅ Kind cluster found!"
            
            # Get cluster info
            kubectl cluster-info
            
            # Wait for pods to be created
            echo "Waiting for pods to be created..."
            sleep 15
            
            # Check all pods
            echo "All pods in cluster:"
            kubectl get pods -A
            
            # Check for application pods (excluding system namespaces)
            APP_PODS=$(kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
            
            if [ -n "$APP_PODS" ]; then
              echo "✅ SUCCESS: Found application pods:"
              echo "$APP_PODS"
              
              # Enhanced pod health checking
              echo ""
              echo "=== Pod Health Analysis ==="
              
              # Count pods by status
              RUNNING_PODS=$(echo "$APP_PODS" | grep "Running" | wc -l)
              PENDING_PODS=$(echo "$APP_PODS" | grep "Pending" | wc -l)
              FAILED_PODS=$(echo "$APP_PODS" | grep -E "(Failed|Error|CrashLoopBackOff|ImagePullBackOff)" | wc -l)
              TOTAL_PODS=$(echo "$APP_PODS" | wc -l)
              
              echo "Pod Status Summary:"
              echo "  Running: $RUNNING_PODS"
              echo "  Pending: $PENDING_PODS" 
              echo "  Failed/Error: $FAILED_PODS"
              echo "  Total: $TOTAL_PODS"
              
              # Check for problematic pods
              PROBLEM_PODS=$(echo "$APP_PODS" | grep -E "(CrashLoopBackOff|ImagePullBackOff|Error|Failed)" || true)
              if [ -n "$PROBLEM_PODS" ]; then
                echo ""
                echo "⚠️  WARNING: Found pods with issues:"
                echo "$PROBLEM_PODS"
                
                # Get details for problematic pods
                echo ""
                echo "Pod issue details:"
                echo "$PROBLEM_PODS" | while read -r line; do
                  POD_NAME=$(echo "$line" | awk '{print $2}')
                  NAMESPACE=$(echo "$line" | awk '{print $1}')
                  echo "--- Pod: $POD_NAME (namespace: $NAMESPACE) ---"
                  kubectl describe pod "$POD_NAME" -n "$NAMESPACE" | grep -A 10 "Events:" || true
                done
              fi
              
              # Wait up to 120 seconds for pods to become ready
              echo ""
              echo "Waiting for pods to become ready..."
              WAIT_TIME=0
              while [ $WAIT_TIME -lt 120 ]; do
                # Count ready pods more carefully
                READY_PODS=0
                echo "$APP_PODS" | while read -r line; do
                  if echo "$line" | grep -q "Running"; then
                    READY_STATUS=$(echo "$line" | awk '{print $3}')
                    if echo "$READY_STATUS" | grep -qE "^[1-9]+/[1-9]+$"; then
                      # Check if ready count equals total count (e.g., "2/2", "1/1")
                      READY_COUNT=$(echo "$READY_STATUS" | cut -d'/' -f1)
                      TOTAL_COUNT=$(echo "$READY_STATUS" | cut -d'/' -f2)
                      if [ "$READY_COUNT" = "$TOTAL_COUNT" ]; then
                        READY_PODS=$((READY_PODS + 1))
                      fi
                    fi
                  fi
                done
                
                # Refresh pod status
                APP_PODS=$(kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
                READY_PODS=$(echo "$APP_PODS" | grep "Running" | grep -E "[0-9]+/[0-9]+" | awk '{
                  split($3, ready, "/"); 
                  if (ready[1] == ready[2] && ready[1] > 0) print $0
                }' | wc -l || echo 0)
                
                if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
                  echo "✅ All $TOTAL_PODS application pods are ready!"
                  break
                fi
                
                echo "Waiting for pods to be ready... ($READY_PODS/$TOTAL_PODS ready) - ${WAIT_TIME}s elapsed"
                sleep 10
                WAIT_TIME=$((WAIT_TIME + 10))
              done
              
              # Final pod status check
              echo ""
              echo "=== Final Pod Status ==="
              kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage"
              
              # Set output for later validation
              if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
                echo "k8s_pods_healthy=true" >> $GITHUB_OUTPUT
              else
                echo "k8s_pods_healthy=false" >> $GITHUB_OUTPUT
              fi
              
            else
              echo "⚠️  WARNING: No application pods found in cluster"
              echo "k8s_pods_healthy=false" >> $GITHUB_OUTPUT
            fi
            
            # Check services and try to test connectivity
            echo ""
            echo "=== Service Analysis ==="
            SERVICES=$(kubectl get services -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
            
            if [ -n "$SERVICES" ]; then
              echo "Found application services:"
              echo "$SERVICES"
              
              # Try to test service connectivity if port is available
              SERVICE_NAME=$(echo "$SERVICES" | head -1 | awk '{print $2}')
              SERVICE_NAMESPACE=$(echo "$SERVICES" | head -1 | awk '{print $1}')
              SERVICE_PORT=$(echo "$SERVICES" | head -1 | awk '{print $6}' | cut -d':' -f1 | cut -d'/' -f1)
              
              if [ -n "$SERVICE_NAME" ] && [ -n "$SERVICE_PORT" ]; then
                echo ""
                echo "Testing service connectivity: $SERVICE_NAME:$SERVICE_PORT"
                
                # Start port-forward in background
                kubectl port-forward service/$SERVICE_NAME $SERVICE_PORT:$SERVICE_PORT -n $SERVICE_NAMESPACE &
                PF_PID=$!
                
                # Give port-forward time to establish
                sleep 5
                
                # Test connectivity
                if curl -f -m 10 "http://localhost:$SERVICE_PORT" 2>/dev/null; then
                  echo "✅ Service is responding on port $SERVICE_PORT"
                else
                  echo "⚠️  Service not responding (may be normal for non-HTTP services)"
                fi
                
                # Clean up port-forward
                kill $PF_PID 2>/dev/null || true
              fi
            else
              echo "No application services found"
            fi
            
            echo "k8s_cluster_found=true" >> $GITHUB_OUTPUT
            
          else
            echo "No kind cluster found - checking for manifest files instead"
            echo "k8s_cluster_found=false" >> $GITHUB_OUTPUT
            
            # Look for K8s manifest files
            MANIFESTS=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | head -5)
            
            if [ -n "$MANIFESTS" ]; then
              echo "✅ SUCCESS: Found Kubernetes manifest files:"
              echo "$MANIFESTS"
              
              # Validate manifest files
              echo ""
              echo "=== Manifest Validation ==="
              for manifest in $MANIFESTS; do
                echo "Validating: $manifest"
                if kubectl apply --dry-run=client -f "$manifest" 2>/dev/null; then
                  echo "  ✅ Valid Kubernetes manifest"
                else
                  echo "  ⚠️  Manifest validation failed"
                fi
              done
              
              # Show a sample of the deployment manifest
              DEPLOYMENT=$(echo "$MANIFESTS" | grep -i deployment | head -1)
              if [ -n "$DEPLOYMENT" ]; then
                echo ""
                echo "Sample deployment manifest:"
                head -30 "$DEPLOYMENT"
              fi
            else
              echo "⚠️  WARNING: No Kubernetes manifests found"
            fi
          fi
          
      - name: Verify Generated Artifacts
        run: |
          echo "=== Checking for generated artifacts ==="
          
          # Look for Dockerfile
          DOCKERFILE=$(find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1)
          if [ -n "$DOCKERFILE" ]; then
            echo "✅ SUCCESS: Found Dockerfile at: $DOCKERFILE"
            echo "Content preview:"
            head -20 "$DOCKERFILE"
          else
            echo "⚠️  WARNING: No Dockerfile found"
          fi
          
          # Look for Kubernetes manifests
          MANIFESTS=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | head -5)
          if [ -n "$MANIFESTS" ]; then
            echo "✅ SUCCESS: Found Kubernetes manifests:"
            echo "$MANIFESTS"
          else
            echo "⚠️  WARNING: No Kubernetes manifests found"
          fi
          
          # Look for docker-compose files
          COMPOSE=$(find /tmp -name "docker-compose*.yml" -o -name "docker-compose*.yaml" 2>/dev/null | head -1)
          if [ -n "$COMPOSE" ]; then
            echo "✅ SUCCESS: Found docker-compose file at: $COMPOSE"
          fi
          
      - name: Verify Security Scan Completed
        run: |
          echo "=== Checking for security scan artifacts ==="
          
          # Look for Trivy scan results
          TRIVY_RESULTS=$(find /tmp -name "*trivy*.json" -o -name "*vulnerability*.json" 2>/dev/null | head -1)
          if [ -n "$TRIVY_RESULTS" ]; then
            echo "✅ SUCCESS: Found Trivy scan results at: $TRIVY_RESULTS"
            # Check for vulnerabilities
            if [ -f "$TRIVY_RESULTS" ]; then
              HIGH_VULNS=$(grep -o '"Severity":"HIGH"' "$TRIVY_RESULTS" 2>/dev/null | wc -l || echo 0)
              CRITICAL_VULNS=$(grep -o '"Severity":"CRITICAL"' "$TRIVY_RESULTS" 2>/dev/null | wc -l || echo 0)
              echo "Found $CRITICAL_VULNS critical and $HIGH_VULNS high vulnerabilities"
            fi
          else
            echo "ℹ️  INFO: No Trivy scan results found (may be disabled)"
          fi
          
          # Look for Hadolint results
          HADOLINT_RESULTS=$(find /tmp -name "*hadolint*.json" -o -name "*lint*.json" 2>/dev/null | head -1)
          if [ -n "$HADOLINT_RESULTS" ]; then
            echo "✅ SUCCESS: Found Hadolint results at: $HADOLINT_RESULTS"
          else
            echo "ℹ️  INFO: No Hadolint results found (may be disabled)"
          fi
          
      - name: Final E2E Validation
        id: validation
        run: |
          echo "=== Final E2E Test Validation ==="
          
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          # Extract repo name for generic checking
          REPO_NAME=$(echo "$CONTAINERIZE_REPO" | sed -E 's|.*/([^/]+)/?$|\1|' | tr '[:upper:]' '[:lower:]')
          
          # Check 1: Docker image exists
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>" | grep -q .; then
            echo "✅ Docker image creation: PASS"
            ((TESTS_PASSED++))
          else
            echo "❌ Docker image creation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 2: Container runs
          if docker ps -a | grep test-app > /dev/null; then
            echo "✅ Container execution: PASS"
            ((TESTS_PASSED++))
          else
            echo "❌ Container execution: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 3: Dockerfile exists
          if find /tmp -name "Dockerfile" -type f 2>/dev/null | grep -q .; then
            echo "✅ Dockerfile generation: PASS"
            ((TESTS_PASSED++))
          else
            echo "❌ Dockerfile generation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 4: Kubernetes manifests exist
          if find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | grep -q .; then
            echo "✅ Kubernetes manifest generation: PASS"
            ((TESTS_PASSED++))
          else
            echo "❌ Kubernetes manifest generation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 5: Enhanced Kubernetes deployment validation
          if [ "${{ steps.verify-k8s.outputs.k8s_cluster_found }}" = "true" ]; then
            if [ "${{ steps.verify-k8s.outputs.k8s_pods_healthy }}" = "true" ]; then
              echo "✅ Kubernetes deployment: PASS (pods are healthy)"
              ((TESTS_PASSED++))
            else
              echo "❌ Kubernetes deployment: FAIL (pods not healthy or missing)"
              ((TESTS_FAILED++))
            fi
          else
            echo "ℹ️  Kubernetes deployment: SKIPPED (no cluster found)"
          fi
          
          # Summary
          echo ""
          echo "=== TEST SUMMARY ==="
          echo "Tests Passed: $TESTS_PASSED"
          echo "Tests Failed: $TESTS_FAILED"
          echo "Total Tests: $((TESTS_PASSED + TESTS_FAILED))"
          
          # Set outputs
          echo "tests_passed=$TESTS_PASSED" >> $GITHUB_OUTPUT
          echo "tests_failed=$TESTS_FAILED" >> $GITHUB_OUTPUT
          
          # Fail if any critical test failed
          if [ $TESTS_FAILED -gt 0 ]; then
            echo ""
            echo "❌ E2E TEST FAILED: One or more critical checks failed"
            exit 1
          else
            echo ""
            echo "✅ E2E TEST PASSED: All critical checks passed"
          fi
          
      - name: Collect E2E Test Results
        if: always()
        run: |
          mkdir -p e2e-artifacts
          
          # Copy MCP log
          cp /tmp/mcp.log e2e-artifacts/ 2>/dev/null || echo "No MCP log found"
          
          # Copy Dockerfile if exists
          find /tmp -name "Dockerfile" -type f -exec cp {} e2e-artifacts/ \; 2>/dev/null || echo "No Dockerfile found"
          
          # Copy Kubernetes manifests
          find /tmp -name "*.yaml" -o -name "*.yml" | grep -E "(deployment|service|manifest)" | xargs -I {} cp {} e2e-artifacts/ 2>/dev/null || echo "No manifests found"
          
          # Copy scan results
          find /tmp -name "*trivy*.json" -o -name "*vulnerability*.json" -o -name "*hadolint*.json" | xargs -I {} cp {} e2e-artifacts/ 2>/dev/null || echo "No scan results found"
          
          # Docker information
          docker images > e2e-artifacts/docker-images.txt
          docker ps -a > e2e-artifacts/docker-containers.txt
          
          # Kubernetes information if cluster exists
          if kind get clusters 2>/dev/null | grep -q .; then
            kubectl get all -A > e2e-artifacts/k8s-resources.txt 2>/dev/null || true
            kubectl describe pods -A > e2e-artifacts/k8s-pod-details.txt 2>/dev/null || true
          fi
          
          # List artifacts
          echo "=== Collected Artifacts ==="
          ls -la e2e-artifacts/
          
      - name: Upload E2E Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-artifacts
          path: e2e-artifacts/
          retention-days: 7
          
      - name: Write Job Summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # E2E Containerization Test Results
          
          ## Test Summary
          - **Tests Passed**: ${{ steps.validation.outputs.tests_passed || '0' }}
          - **Tests Failed**: ${{ steps.validation.outputs.tests_failed || '0' }}
          - **Repository Tested**: ${{ env.CONTAINERIZE_REPO }}
          
          ## Key Outcomes
          - Docker Image: ${{ env.IMAGE_NAME || 'Not found' }}
          - Container Port: ${{ steps.extract-port.outputs.port || 'Unknown' }}
          - Container Status: ${{ steps.verify-image.outcome == 'success' && '✅ Created' || '❌ Failed' }}
          - Kubernetes Manifests: Generated
          
          ## Artifacts
          Check the uploaded artifacts for:
          - MCP execution log
          - Generated Dockerfile
          - Kubernetes manifests
          - Security scan results
          - Kubernetes cluster state (if deployed)
          
          EOF
