name: E2E Containerization Test (Simplified)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      repo:
        description: 'Repository URL to containerize'
        required: false
        type: string
        default: 'https://github.com/konveyor-ecosystem/coolstore'

jobs:
  e2e-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    env:
      AZURE_OPENAI_DEPLOYMENT_ID: ${{ secrets.AZURE_OPENAI_DEPLOYMENT_ID }}
      AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
      AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
      CONTAINERIZE_REPO: ${{ github.event_name == 'workflow_dispatch' && inputs.repo || 'https://github.com/konveyor-ecosystem/coolstore' }}
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          
      - name: Setup Environment
        run: |
          # Verify Docker is working
          docker --version
          docker info
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client
          
          # Install kind (Kubernetes in Docker)
          curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind version
          
          # Install mcphost
          VERSION="v0.29.0"
          curl -L -o mcphost.tar.gz "https://github.com/mark3labs/mcphost/releases/download/${VERSION}/mcphost_Linux_x86_64.tar.gz"
          tar -xzf mcphost.tar.gz
          chmod +x mcphost
          sudo mv mcphost /usr/local/bin/
          rm -f mcphost.tar.gz
          mcphost --version
          
      - name: Create mcphost configuration
        run: |
          echo "Creating mcphost configuration using dedicated config file..."
          mkdir -p ~/.config/mcphost
          
          # Copy the main configuration template
          cp .github/workflows/mcphost/config.yml ~/.mcphost.yml
          
          echo "Configuration created. Contents:"
          cat ~/.mcphost.yml
          
          # Create workspace for testing
          mkdir -p /tmp/test-workspace
          
      - name: Verify MCP Configuration
        run: |
          echo "=== Testing MCP Configuration with Simple Request ==="
          cd /tmp/test-workspace
          
          # Test basic mcphost functionality with a simple math operation
          echo "Testing mcphost with simple addition: 2 + 3"
          echo "This test uses only built-in MCP servers (no custom server needed yet)"
          
          # Execute simple test with timeout
          set +e  # Don't exit on error so we can capture exit code
          timeout 60s mcphost --quiet --prompt "Please calculate 2 + 3 and respond with just the number result." > /tmp/mcp-verification.log 2>&1
          VERIFICATION_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Show the verification log
          echo "MCP Verification Log:"
          cat /tmp/mcp-verification.log
          
          # Check if the test succeeded
          if [ $VERIFICATION_EXIT_CODE -eq 0 ]; then
            # Look for the expected result (5) in the output
            if grep -q "5" /tmp/mcp-verification.log; then
              echo "‚úÖ MCP verification PASSED: Found expected result '5'"
            else
              echo "‚ùå MCP verification FAILED: Expected result '5' not found in output"
              echo "This indicates Azure OpenAI is not responding correctly to basic requests"
              exit 1
            fi
          else
            echo "‚ùå MCP verification FAILED: mcphost exited with code $VERIFICATION_EXIT_CODE"
            echo "This indicates a fundamental issue with MCP configuration or Azure OpenAI connection"
            exit 1
          fi
          
          echo "‚úÖ MCP verification completed successfully - Azure OpenAI connection is working"
          
      - name: Build MCP Server
        run: |
          echo "Building Containerization Assist MCP Server from PR code..."
          go build -tags mcp -o containerization-assist-mcp .
          chmod +x containerization-assist-mcp
          ls -la containerization-assist-mcp
          
          # Copy MCP binary to workspace
          cp ./containerization-assist-mcp /tmp/test-workspace/
          
      - name: Update MCP Configuration for Containerization
        run: |
          echo "Adding custom containerization server to MCP configuration..."
          
          # Create updated config with the custom server
          cat > ~/.mcphost.yml << 'EOF'
          mcpServers:
            filesystem:
              type: "builtin"
              name: "fs"
              options:
                allowed_directories: ["/tmp", ".", "/home/runner/work"]
            
            bash:
              type: "builtin"
              name: "bash"
              
            containerization-assist:
              type: "stdio"
              command: "/tmp/test-workspace/containerization-assist-mcp"
              args: []
              
          model: "azure:${env://AZURE_OPENAI_DEPLOYMENT_ID}"
          provider-api-key: "${env://AZURE_OPENAI_KEY}"
          provider-url: "${env://AZURE_OPENAI_ENDPOINT}"
          EOF
          
          echo "Updated MCP configuration:"
          cat ~/.mcphost.yml
          
          # Test that the custom server can start
          echo "Testing custom MCP server startup..."
          cd /tmp/test-workspace
          timeout 10s ./containerization-assist-mcp --version || echo "Custom server version check completed"
          
          # Verify MCP server health
          echo "=== MCP Server Health Check ==="
          echo "Binary size: $(stat -c%s ./containerization-assist-mcp) bytes"
          echo "Binary permissions: $(stat -c%a ./containerization-assist-mcp)"
          echo "Binary type:"
          file ./containerization-assist-mcp
          
          # Test if server can handle basic communication
          echo "Testing MCP server basic communication..."
          set +e
          timeout 15s ./containerization-assist-mcp --help > /tmp/mcp-server-test.log 2>&1
          SERVER_TEST_EXIT=$?
          set -e
          
          if [ $SERVER_TEST_EXIT -eq 0 ]; then
            echo "‚úÖ MCP server basic communication test passed"
          else
            echo "‚ö†Ô∏è  MCP server communication test failed (exit code: $SERVER_TEST_EXIT)"
            echo "Server test output:"
            cat /tmp/mcp-server-test.log || echo "No test log available"
          fi
          
      - name: Execute Containerization via MCP
        continue-on-error: true
        run: |
          echo "Starting containerization of: $CONTAINERIZE_REPO"
          cd /tmp/test-workspace
          
          # Show current working directory and environment
          echo "Working directory: $(pwd)"
          echo "Available disk space:"
          df -h /tmp
          
          # Verify MCP server binary
          ls -la ./containerization-assist-mcp
          ./containerization-assist-mcp --version || echo "Version check failed"
          
          # Check Azure OpenAI environment variables (without exposing secrets)
          echo "Azure OpenAI configuration status:"
          echo "AZURE_OPENAI_DEPLOYMENT_ID: ${AZURE_OPENAI_DEPLOYMENT_ID:+SET}"
          echo "AZURE_OPENAI_KEY: ${AZURE_OPENAI_KEY:+SET}" 
          echo "AZURE_OPENAI_ENDPOINT: ${AZURE_OPENAI_ENDPOINT:+SET}"
          
          # Test mcphost configuration
          echo "Testing mcphost configuration..."
          mcphost --help || echo "mcphost help failed"
          
          # Execute containerization with improved timeout and monitoring
          echo "=== Starting MCP Containerization Process ==="
          echo "Repository: ${CONTAINERIZE_REPO}"
          echo "Timeout: 300 seconds (5 minutes) with progress monitoring"
          
          # Start MCP process in background with reduced timeout
          set +e  # Don't exit on error so we can capture exit code
          
          # Create a function to monitor progress
          monitor_mcp_progress() {
            local pid=$1
            local timeout=300  # 5 minutes total
            local elapsed=0
            local check_interval=30  # Check every 30 seconds
            
            while [ $elapsed -lt $timeout ]; do
              if ! kill -0 $pid 2>/dev/null; then
                # Process has finished
                break
              fi
              
              # Show progress update
              echo "‚è±Ô∏è  MCP process still running... (${elapsed}s elapsed, timeout at ${timeout}s)"
              
              # Check if any files have been created (sign of progress)
              local file_count=$(find /tmp/test-workspace -type f -newer /tmp/test-workspace 2>/dev/null | wc -l)
              if [ $file_count -gt 0 ]; then
                echo "üìÅ Files created/modified: $file_count"
              fi
              
              # Check log file size
              if [ -f /tmp/mcp.log ]; then
                local log_size=$(wc -l < /tmp/mcp.log)
                echo "üìù Log entries: $log_size lines"
                
                # Show last few lines for progress indication
                echo "Recent activity:"
                tail -3 /tmp/mcp.log | sed 's/^/   /'
              fi
              
              sleep $check_interval
              elapsed=$((elapsed + check_interval))
            done
            
            # Check if process is still running (timed out)
            if kill -0 $pid 2>/dev/null; then
              echo "‚ö†Ô∏è  Process timed out after ${timeout}s - terminating..."
              kill -TERM $pid 2>/dev/null || true
              sleep 5
              kill -KILL $pid 2>/dev/null || true
              return 124  # timeout exit code
            fi
            
            # Get actual exit code
            wait $pid
            return $?
          }
          
          # Start mcphost in background with compact output to reduce repetitive text
          mcphost --compact --prompt "Please containerize and deploy this repository: ${CONTAINERIZE_REPO}. This is an automated test." > /tmp/mcp.log 2>&1 &
          MCP_PID=$!
          
          # Monitor the process
          monitor_mcp_progress $MCP_PID
          MCP_EXIT_CODE=$?
          
          set -e  # Re-enable exit on error
          
          echo "MCP process completed with exit code: $MCP_EXIT_CODE"
          
          # Analyze the result
          case $MCP_EXIT_CODE in
            0)
              echo "‚úÖ MCP process completed successfully"
              ;;
            124)
              echo "‚ùå MCP process timed out after 300 seconds"
              echo "This suggests the process may be hanging or stuck"
              ;;
            *)
              echo "‚ùå MCP process failed with exit code: $MCP_EXIT_CODE"
              ;;
          esac
          
          # Always show the log contents for debugging
          echo ""
          echo "=== MCP LOG CONTENTS ==="
          if [ -f /tmp/mcp.log ]; then
            echo "Log file size: $(wc -l < /tmp/mcp.log) lines"
            cat /tmp/mcp.log
          else
            echo "No MCP log file found!"
          fi
          
          # Show what was created in the workspace
          echo ""
          echo "=== WORKSPACE CONTENTS AFTER MCP ==="
          ls -la /tmp/test-workspace/ || echo "Workspace listing failed"
          find /tmp/test-workspace -type f -name "*" | head -20 || echo "No files found in workspace"
          
          # Check if any Docker-related files were created
          echo ""
          echo "=== SEARCHING FOR GENERATED FILES ==="
          find /tmp -name "Dockerfile" -type f 2>/dev/null | head -5 || echo "No Dockerfiles found"
          find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | head -10 || echo "No YAML files found"
          
          # Exit with error if MCP failed
          if [ $MCP_EXIT_CODE -ne 0 ]; then
            echo "‚ùå MCP process failed with exit code $MCP_EXIT_CODE"
            exit $MCP_EXIT_CODE
          fi
          
          echo "‚úÖ MCP process completed successfully"
          
      - name: Verify Docker Image Exists
        id: verify-image
        if: success() || failure()
        run: |
          echo "=== Checking for Docker images ==="
          
          # List all images for debugging
          docker images
          
          # Extract repository name from URL to make it generic
          REPO_NAME=$(echo "$CONTAINERIZE_REPO" | sed -E 's|.*/([^/]+)/?$|\1|' | tr '[:upper:]' '[:lower:]')
          echo "Looking for images related to: $REPO_NAME"
          
          # Look for the containerized image with improved generic patterns
          IMAGE_NAME=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>" | grep -v "^registry\." | grep -v "^docker\.io" | head -1)
          
          # If no image found, this is a failure
          if [ -z "$IMAGE_NAME" ]; then
            echo "‚ùå FAIL: No Docker image found"
            echo "Available images:"
            docker images
            echo "Expected to find an image for repository: $REPO_NAME"
            exit 1
          fi
          
          echo "‚úÖ SUCCESS: Found Docker image: $IMAGE_NAME"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
          echo "image=$IMAGE_NAME" >> $GITHUB_OUTPUT
          
      - name: Extract Port from Dockerfile
        id: extract-port
        if: success() || failure()
        run: |
          echo "=== Extracting port information ==="
          
          # Find Dockerfile
          DOCKERFILE=$(find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1)
          
          if [ -n "$DOCKERFILE" ]; then
            # Extract EXPOSE port from Dockerfile
            EXPOSED_PORT=$(grep -E "^EXPOSE" "$DOCKERFILE" | head -1 | awk '{print $2}' | sed 's/[^0-9]//g')
            echo "Found EXPOSE port: $EXPOSED_PORT"
          fi
          
          # Also check generated K8s manifests for port info
          K8S_PORT=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | xargs grep -h "targetPort:\|containerPort:" 2>/dev/null | head -1 | grep -oE '[0-9]+' | head -1)
          
          # Use the first port we find, defaulting to common ports
          PORT=${EXPOSED_PORT:-$K8S_PORT}
          PORT=${PORT:-8080}
          
          echo "Using port: $PORT"
          echo "PORT=$PORT" >> $GITHUB_ENV
          echo "port=$PORT" >> $GITHUB_OUTPUT
          
      - name: Test Container Locally
        if: success() || failure()
        run: |
          echo "=== Testing container locally ==="
          
          # Run the container with discovered port
          docker run -d -p ${PORT}:${PORT} --name test-app $IMAGE_NAME || {
            echo "Failed with port $PORT, trying common ports..."
            for try_port in 3000 5000 8000 80; do
              docker rm -f test-app 2>/dev/null || true
              if docker run -d -p ${try_port}:${try_port} --name test-app $IMAGE_NAME; then
                PORT=$try_port
                echo "PORT=$PORT" >> $GITHUB_ENV
                break
              fi
            done
          }
          
          # Give it time to start
          sleep 15
          
          # Check if container is running
          if ! docker ps | grep test-app; then
            echo "Container failed to start. Logs:"
            docker logs test-app
            exit 1
          fi
          
          echo "‚úÖ Container is running"
          docker ps | grep test-app
          
          # Try to access the application
          ACCESSIBLE=false
          for endpoint in "/" "/health" "/api/health" "/status" "/api/status"; do
            if curl -f -m 5 "http://localhost:${PORT}${endpoint}" 2>/dev/null; then
              echo "‚úÖ SUCCESS: Container responds on port $PORT at endpoint $endpoint"
              ACCESSIBLE=true
              break
            fi
          done
          
          if [ "$ACCESSIBLE" = "false" ]; then
            echo "‚ö†Ô∏è  WARNING: Container is running but not responding to HTTP requests"
            echo "This may be normal for non-web applications"
          fi
          
      - name: Verify Kubernetes Deployment
        id: verify-k8s
        if: success() || failure()
        run: |
          echo "=== Checking Kubernetes deployment ==="
          
          # Check if kind cluster exists
          if kind get clusters 2>/dev/null | grep -q .; then
            echo "‚úÖ Kind cluster found!"
            
            # Get cluster info
            kubectl cluster-info
            
            # Wait for pods to be created
            echo "Waiting for pods to be created..."
            sleep 15
            
            # Check all pods
            echo "All pods in cluster:"
            kubectl get pods -A
            
            # Check for application pods (excluding system namespaces)
            APP_PODS=$(kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
            
            if [ -n "$APP_PODS" ]; then
              echo "‚úÖ SUCCESS: Found application pods:"
              echo "$APP_PODS"
              
              # Enhanced pod health checking
              echo ""
              echo "=== Pod Health Analysis ==="
              
              # Count pods by status
              RUNNING_PODS=$(echo "$APP_PODS" | grep "Running" | wc -l)
              PENDING_PODS=$(echo "$APP_PODS" | grep "Pending" | wc -l)
              FAILED_PODS=$(echo "$APP_PODS" | grep -E "(Failed|Error|CrashLoopBackOff|ImagePullBackOff)" | wc -l)
              TOTAL_PODS=$(echo "$APP_PODS" | wc -l)
              
              echo "Pod Status Summary:"
              echo "  Running: $RUNNING_PODS"
              echo "  Pending: $PENDING_PODS" 
              echo "  Failed/Error: $FAILED_PODS"
              echo "  Total: $TOTAL_PODS"
              
              # Check for problematic pods
              PROBLEM_PODS=$(echo "$APP_PODS" | grep -E "(CrashLoopBackOff|ImagePullBackOff|Error|Failed)" || true)
              if [ -n "$PROBLEM_PODS" ]; then
                echo ""
                echo "‚ö†Ô∏è  WARNING: Found pods with issues:"
                echo "$PROBLEM_PODS"
                
                # Get details for problematic pods
                echo ""
                echo "Pod issue details:"
                echo "$PROBLEM_PODS" | while read -r line; do
                  POD_NAME=$(echo "$line" | awk '{print $2}')
                  NAMESPACE=$(echo "$line" | awk '{print $1}')
                  echo "--- Pod: $POD_NAME (namespace: $NAMESPACE) ---"
                  kubectl describe pod "$POD_NAME" -n "$NAMESPACE" | grep -A 10 "Events:" || true
                done
              fi
              
              # Wait up to 120 seconds for pods to become ready
              echo ""
              echo "Waiting for pods to become ready..."
              WAIT_TIME=0
              while [ $WAIT_TIME -lt 120 ]; do
                # Count ready pods more carefully
                READY_PODS=0
                echo "$APP_PODS" | while read -r line; do
                  if echo "$line" | grep -q "Running"; then
                    READY_STATUS=$(echo "$line" | awk '{print $3}')
                    if echo "$READY_STATUS" | grep -qE "^[1-9]+/[1-9]+$"; then
                      # Check if ready count equals total count (e.g., "2/2", "1/1")
                      READY_COUNT=$(echo "$READY_STATUS" | cut -d'/' -f1)
                      TOTAL_COUNT=$(echo "$READY_STATUS" | cut -d'/' -f2)
                      if [ "$READY_COUNT" = "$TOTAL_COUNT" ]; then
                        READY_PODS=$((READY_PODS + 1))
                      fi
                    fi
                  fi
                done
                
                # Refresh pod status
                APP_PODS=$(kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
                READY_PODS=$(echo "$APP_PODS" | grep "Running" | grep -E "[0-9]+/[0-9]+" | awk '{
                  split($3, ready, "/"); 
                  if (ready[1] == ready[2] && ready[1] > 0) print $0
                }' | wc -l || echo 0)
                
                if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
                  echo "‚úÖ All $TOTAL_PODS application pods are ready!"
                  break
                fi
                
                echo "Waiting for pods to be ready... ($READY_PODS/$TOTAL_PODS ready) - ${WAIT_TIME}s elapsed"
                sleep 10
                WAIT_TIME=$((WAIT_TIME + 10))
              done
              
              # Final pod status check
              echo ""
              echo "=== Final Pod Status ==="
              kubectl get pods -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage"
              
              # Set output for later validation
              if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt 0 ]; then
                echo "k8s_pods_healthy=true" >> $GITHUB_OUTPUT
              else
                echo "k8s_pods_healthy=false" >> $GITHUB_OUTPUT
              fi
              
            else
              echo "‚ö†Ô∏è  WARNING: No application pods found in cluster"
              echo "k8s_pods_healthy=false" >> $GITHUB_OUTPUT
            fi
            
            # Check services and try to test connectivity
            echo ""
            echo "=== Service Analysis ==="
            SERVICES=$(kubectl get services -A --no-headers | grep -v "kube-system\|kube-public\|kube-node-lease\|local-path-storage" || true)
            
            if [ -n "$SERVICES" ]; then
              echo "Found application services:"
              echo "$SERVICES"
              
              # Try to test service connectivity if port is available
              SERVICE_NAME=$(echo "$SERVICES" | head -1 | awk '{print $2}')
              SERVICE_NAMESPACE=$(echo "$SERVICES" | head -1 | awk '{print $1}')
              SERVICE_PORT=$(echo "$SERVICES" | head -1 | awk '{print $6}' | cut -d':' -f1 | cut -d'/' -f1)
              
              if [ -n "$SERVICE_NAME" ] && [ -n "$SERVICE_PORT" ]; then
                echo ""
                echo "Testing service connectivity: $SERVICE_NAME:$SERVICE_PORT"
                
                # Start port-forward in background
                kubectl port-forward service/$SERVICE_NAME $SERVICE_PORT:$SERVICE_PORT -n $SERVICE_NAMESPACE &
                PF_PID=$!
                
                # Give port-forward time to establish
                sleep 5
                
                # Test connectivity
                if curl -f -m 10 "http://localhost:$SERVICE_PORT" 2>/dev/null; then
                  echo "‚úÖ Service is responding on port $SERVICE_PORT"
                else
                  echo "‚ö†Ô∏è  Service not responding (may be normal for non-HTTP services)"
                fi
                
                # Clean up port-forward
                kill $PF_PID 2>/dev/null || true
              fi
            else
              echo "No application services found"
            fi
            
            echo "k8s_cluster_found=true" >> $GITHUB_OUTPUT
            
          else
            echo "No kind cluster found - checking for manifest files instead"
            echo "k8s_cluster_found=false" >> $GITHUB_OUTPUT
            
            # Look for K8s manifest files
            MANIFESTS=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | head -5)
            
            if [ -n "$MANIFESTS" ]; then
              echo "‚úÖ SUCCESS: Found Kubernetes manifest files:"
              echo "$MANIFESTS"
              
              # Validate manifest files
              echo ""
              echo "=== Manifest Validation ==="
              for manifest in $MANIFESTS; do
                echo "Validating: $manifest"
                if kubectl apply --dry-run=client -f "$manifest" 2>/dev/null; then
                  echo "  ‚úÖ Valid Kubernetes manifest"
                else
                  echo "  ‚ö†Ô∏è  Manifest validation failed"
                fi
              done
              
              # Show a sample of the deployment manifest
              DEPLOYMENT=$(echo "$MANIFESTS" | grep -i deployment | head -1)
              if [ -n "$DEPLOYMENT" ]; then
                echo ""
                echo "Sample deployment manifest:"
                head -30 "$DEPLOYMENT"
              fi
            else
              echo "‚ö†Ô∏è  WARNING: No Kubernetes manifests found"
            fi
          fi
          
      - name: Verify Generated Artifacts
        if: success() || failure()
        run: |
          echo "=== Checking for generated artifacts ==="
          
          # Look for Dockerfile
          DOCKERFILE=$(find /tmp -name "Dockerfile" -type f 2>/dev/null | head -1)
          if [ -n "$DOCKERFILE" ]; then
            echo "‚úÖ SUCCESS: Found Dockerfile at: $DOCKERFILE"
            echo "Content preview:"
            head -20 "$DOCKERFILE"
          else
            echo "‚ö†Ô∏è  WARNING: No Dockerfile found"
          fi
          
          # Look for Kubernetes manifests
          MANIFESTS=$(find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | head -5)
          if [ -n "$MANIFESTS" ]; then
            echo "‚úÖ SUCCESS: Found Kubernetes manifests:"
            echo "$MANIFESTS"
          else
            echo "‚ö†Ô∏è  WARNING: No Kubernetes manifests found"
          fi
          
          # Look for docker-compose files
          COMPOSE=$(find /tmp -name "docker-compose*.yml" -o -name "docker-compose*.yaml" 2>/dev/null | head -1)
          if [ -n "$COMPOSE" ]; then
            echo "‚úÖ SUCCESS: Found docker-compose file at: $COMPOSE"
          fi
          
      - name: Verify Security Scan Completed
        if: success() || failure()
        run: |
          echo "=== Checking for security scan artifacts ==="
          
          # Look for Trivy scan results
          TRIVY_RESULTS=$(find /tmp -name "*trivy*.json" -o -name "*vulnerability*.json" 2>/dev/null | head -1)
          if [ -n "$TRIVY_RESULTS" ]; then
            echo "‚úÖ SUCCESS: Found Trivy scan results at: $TRIVY_RESULTS"
            # Check for vulnerabilities
            if [ -f "$TRIVY_RESULTS" ]; then
              HIGH_VULNS=$(grep -o '"Severity":"HIGH"' "$TRIVY_RESULTS" 2>/dev/null | wc -l || echo 0)
              CRITICAL_VULNS=$(grep -o '"Severity":"CRITICAL"' "$TRIVY_RESULTS" 2>/dev/null | wc -l || echo 0)
              echo "Found $CRITICAL_VULNS critical and $HIGH_VULNS high vulnerabilities"
            fi
          else
            echo "‚ÑπÔ∏è  INFO: No Trivy scan results found (may be disabled)"
          fi
          
          # Look for Hadolint results
          HADOLINT_RESULTS=$(find /tmp -name "*hadolint*.json" -o -name "*lint*.json" 2>/dev/null | head -1)
          if [ -n "$HADOLINT_RESULTS" ]; then
            echo "‚úÖ SUCCESS: Found Hadolint results at: $HADOLINT_RESULTS"
          else
            echo "‚ÑπÔ∏è  INFO: No Hadolint results found (may be disabled)"
          fi
          
      - name: Final E2E Validation
        id: validation
        run: |
          echo "=== Final E2E Test Validation ==="
          
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          # Extract repo name for generic checking
          REPO_NAME=$(echo "$CONTAINERIZE_REPO" | sed -E 's|.*/([^/]+)/?$|\1|' | tr '[:upper:]' '[:lower:]')
          
          # Check 1: Docker image exists
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "<none>" | grep -q .; then
            echo "‚úÖ Docker image creation: PASS"
            ((TESTS_PASSED++))
          else
            echo "‚ùå Docker image creation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 2: Container runs
          if docker ps -a | grep test-app > /dev/null; then
            echo "‚úÖ Container execution: PASS"
            ((TESTS_PASSED++))
          else
            echo "‚ùå Container execution: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 3: Dockerfile exists
          if find /tmp -name "Dockerfile" -type f 2>/dev/null | grep -q .; then
            echo "‚úÖ Dockerfile generation: PASS"
            ((TESTS_PASSED++))
          else
            echo "‚ùå Dockerfile generation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 4: Kubernetes manifests exist
          if find /tmp -name "*.yaml" -o -name "*.yml" 2>/dev/null | grep -E "(deployment|service|manifest)" | grep -q .; then
            echo "‚úÖ Kubernetes manifest generation: PASS"
            ((TESTS_PASSED++))
          else
            echo "‚ùå Kubernetes manifest generation: FAIL"
            ((TESTS_FAILED++))
          fi
          
          # Check 5: Enhanced Kubernetes deployment validation
          if [ "${{ steps.verify-k8s.outputs.k8s_cluster_found }}" = "true" ]; then
            if [ "${{ steps.verify-k8s.outputs.k8s_pods_healthy }}" = "true" ]; then
              echo "‚úÖ Kubernetes deployment: PASS (pods are healthy)"
              ((TESTS_PASSED++))
            else
              echo "‚ùå Kubernetes deployment: FAIL (pods not healthy or missing)"
              ((TESTS_FAILED++))
            fi
          else
            echo "‚ÑπÔ∏è  Kubernetes deployment: SKIPPED (no cluster found)"
          fi
          
          # Summary
          echo ""
          echo "=== TEST SUMMARY ==="
          echo "Tests Passed: $TESTS_PASSED"
          echo "Tests Failed: $TESTS_FAILED"
          echo "Total Tests: $((TESTS_PASSED + TESTS_FAILED))"
          
          # Set outputs
          echo "tests_passed=$TESTS_PASSED" >> $GITHUB_OUTPUT
          echo "tests_failed=$TESTS_FAILED" >> $GITHUB_OUTPUT
          
          # Fail if any critical test failed
          if [ $TESTS_FAILED -gt 0 ]; then
            echo ""
            echo "‚ùå E2E TEST FAILED: One or more critical checks failed"
            exit 1
          else
            echo ""
            echo "‚úÖ E2E TEST PASSED: All critical checks passed"
          fi
          
      - name: Collect E2E Test Results
        if: always()
        run: |
          mkdir -p e2e-artifacts
          
          # Copy MCP logs
          cp /tmp/mcp.log e2e-artifacts/ 2>/dev/null || echo "No MCP log found"
          cp /tmp/mcp-verification.log e2e-artifacts/ 2>/dev/null || echo "No MCP verification log found"
          
          # Copy Dockerfile if exists
          find /tmp -name "Dockerfile" -type f -exec cp {} e2e-artifacts/ \; 2>/dev/null || echo "No Dockerfile found"
          
          # Copy Kubernetes manifests
          find /tmp -name "*.yaml" -o -name "*.yml" | grep -E "(deployment|service|manifest)" | xargs -I {} cp {} e2e-artifacts/ 2>/dev/null || echo "No manifests found"
          
          # Copy scan results
          find /tmp -name "*trivy*.json" -o -name "*vulnerability*.json" -o -name "*hadolint*.json" | xargs -I {} cp {} e2e-artifacts/ 2>/dev/null || echo "No scan results found"
          
          # Docker information
          docker images > e2e-artifacts/docker-images.txt
          docker ps -a > e2e-artifacts/docker-containers.txt
          
          # Kubernetes information if cluster exists
          if kind get clusters 2>/dev/null | grep -q .; then
            kubectl get all -A > e2e-artifacts/k8s-resources.txt 2>/dev/null || true
            kubectl describe pods -A > e2e-artifacts/k8s-pod-details.txt 2>/dev/null || true
          fi
          
          # List artifacts
          echo "=== Collected Artifacts ==="
          ls -la e2e-artifacts/
          
      - name: Upload E2E Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-artifacts
          path: e2e-artifacts/
          retention-days: 7
          
      - name: Write Job Summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # E2E Containerization Test Results
          
          ## Test Summary
          - **Tests Passed**: ${{ steps.validation.outputs.tests_passed || '0' }}
          - **Tests Failed**: ${{ steps.validation.outputs.tests_failed || '0' }}
          - **Repository Tested**: ${{ env.CONTAINERIZE_REPO }}
          
          ## Key Outcomes
          - Docker Image: ${{ env.IMAGE_NAME || 'Not found' }}
          - Container Port: ${{ steps.extract-port.outputs.port || 'Unknown' }}
          - Container Status: ${{ steps.verify-image.outcome == 'success' && '‚úÖ Created' || '‚ùå Failed' }}
          - Kubernetes Manifests: Generated
          
          ## Artifacts
          Check the uploaded artifacts for:
          - MCP execution log
          - Generated Dockerfile
          - Kubernetes manifests
          - Security scan results
          - Kubernetes cluster state (if deployed)
          
          EOF
