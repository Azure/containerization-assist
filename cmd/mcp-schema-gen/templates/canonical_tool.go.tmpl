package {{.Domain}}

import (
	"context"
	"fmt"

	"github.com/Azure/container-kit/pkg/mcp/application/api"
	"github.com/Azure/container-kit/pkg/mcp/domain/errors"
	"github.com/Azure/container-kit/pkg/mcp/domain/session"
	"github.com/rs/zerolog"
)

// {{.ToolName}}Tool implements the canonical api.Tool interface
type {{.ToolName}}Tool struct {
	sessionManager session.UnifiedSessionManager
	logger         zerolog.Logger
}

// New{{.ToolName}}Tool creates a new {{.ToolName}} tool using canonical interface
func New{{.ToolName}}Tool(sessionManager session.UnifiedSessionManager, logger zerolog.Logger) api.Tool {
	return &{{.ToolName}}Tool{
		sessionManager: sessionManager,
		logger:         logger.With().Str("tool", "{{.ToolNameLower}}").Logger(),
	}
}

// Name implements api.Tool
func (t *{{.ToolName}}Tool) Name() string {
	return "{{.ToolNameLower}}"
}

// Description implements api.Tool
func (t *{{.ToolName}}Tool) Description() string {
	return "{{.Description}}"
}

// Schema implements api.Tool
func (t *{{.ToolName}}Tool) Schema() api.ToolSchema {
	return api.ToolSchema{
		Name:        t.Name(),
		Description: t.Description(),
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				{{range .InputFields}}"{{.Name}}": map[string]interface{}{
					"type":        "{{.Type}}",
					"description": "{{.Description}}",
				},
				{{end}}
			},
			"required": []string{},
		},
		OutputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"success": map[string]interface{}{
					"type":        "boolean",
					"description": "Whether the operation was successful",
				},
				"data": map[string]interface{}{
					"type":        "object",
					"description": "Operation result data",
					"properties": map[string]interface{}{
						{{range .OutputFields}}"{{.Name}}": map[string]interface{}{
							"type":        "{{.Type}}",
							"description": "{{.Description}}",
						},
						{{end}}
					},
				},
				"error": map[string]interface{}{
					"type":        "string",
					"description": "Error message if operation failed",
				},
				"metadata": map[string]interface{}{
					"type":        "object",
					"description": "Additional metadata about the operation",
				},
			},
		},
		Tags:     []string{},
		Category: "{{.Domain}}",
		Version:  "{{.Version}}",
	}
}

// Execute implements api.Tool
func (t *{{.ToolName}}Tool) Execute(ctx context.Context, input api.ToolInput) (api.ToolOutput, error) {
	// Validate session ID
	if input.SessionID == "" {
		return api.ToolOutput{
			Success: false,
			Error:   "session_id is required",
			Data: map[string]interface{}{
				"error": "session_id is required",
			},
		}, errors.NewError().Message("session_id is required").WithLocation().Build()
	}

	// Extract and validate input parameters
	var params struct {
		{{range .InputFields}}{{.Name | title}} {{.GoType}} `json:"{{.Name}}"{{if not .Required}},omitempty{{end}}`
		{{end}}
	}

	// Parse parameters from input.Data
	{{range .InputFields}}
	if val, ok := input.Data["{{.Name}}"]; ok {
		{{if eq .Type "string"}}if strVal, ok := val.(string); ok {
			params.{{.Name | title}} = strVal
		}{{else if eq .Type "boolean"}}if boolVal, ok := val.(bool); ok {
			params.{{.Name | title}} = boolVal
		}{{else if eq .Type "array"}}if arrVal, ok := val.([]interface{}); ok {
			for _, item := range arrVal {
				if strItem, ok := item.(string); ok {
					params.{{.Name | title}} = append(params.{{.Name | title}}, strItem)
				}
			}
		}{{end}}
	}
	{{end}}

	// Validate required parameters
	{{range .InputFields}}{{if .Required}}
	{{if eq .Type "string"}}if params.{{.Name | title}} == "" {
		return api.ToolOutput{
			Success: false,
			Error:   "{{.Name}} is required",
			Data: map[string]interface{}{
				"error": "{{.Name}} is required",
			},
		}, errors.NewError().Message("{{.Name}} is required").WithLocation().Build()
	}{{end}}
	{{end}}{{end}}

	// Log the execution
	t.logger.Info().
		Str("session_id", input.SessionID).
		Msg("Starting {{.ToolNameLower}} execution")

	// TODO: Implement actual {{.ToolNameLower}} logic here
	// For now, return a mock result
	result := api.ToolOutput{
		Success: true,
		Data: map[string]interface{}{
			"status": "completed",
		},
		Metadata: map[string]interface{}{
			"execution_time_ms": 1000,
			"session_id":        input.SessionID,
			"tool_version":      "{{.Version}}",
		},
	}

	t.logger.Info().
		Str("session_id", input.SessionID).
		Msg("{{.ToolName}} execution completed successfully")

	return result, nil
}
