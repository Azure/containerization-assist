package {{.Domain}}

import (
	"context"
	"time"

	"github.com/Azure/container-kit/pkg/mcp/api"
	"github.com/Azure/container-kit/pkg/mcp/errors"
	"github.com/Azure/container-kit/pkg/mcp/infra/telemetry"
	"github.com/Azure/container-kit/pkg/mcp/internal/validation"
)

// {{.ToolName | pascalCase}}Tool implements the {{.Domain}} {{.Action}} functionality
type {{.ToolName | pascalCase}}Tool struct {
	logger    *telemetry.StructuredLogger
	validator *{{.ToolName | pascalCase}}Validator
	telemetry *telemetry.TelemetryProvider
}

// New{{.ToolName | pascalCase}}Tool creates a new {{.ToolName}} tool instance
func New{{.ToolName | pascalCase}}Tool() api.Tool {
	// Initialize telemetry
	telemetryProvider, _ := telemetry.NewTelemetryProvider(telemetry.TelemetryConfig{
		ServiceName: "{{.Domain}}-{{.ToolName | kebabCase}}-tool",
		Enabled:     true,
	})

	return &{{.ToolName | pascalCase}}Tool{
		logger:    telemetry.NewLogger("{{.Domain}}.{{.ToolName | camelCase}}"),
		validator: New{{.ToolName | pascalCase}}Validator(),
		telemetry: telemetryProvider,
	}
}

// Execute implements the api.Tool interface
func (t *{{.ToolName | pascalCase}}Tool) Execute(ctx context.Context, input api.ToolInput) (api.ToolOutput, error) {
	// Instrument execution with telemetry
	if t.telemetry != nil {
		return t.telemetry.InstrumentToolExecution(ctx, "{{.Domain}}_{{.Action}}_{{.Object}}", input.SessionID,
			func(ctx context.Context) (interface{}, error) {
				return t.executeInternal(ctx, input)
			})
	}

	// Fallback to direct execution
	return t.executeInternal(ctx, input)
}

// executeInternal contains the actual tool implementation
func (t *{{.ToolName | pascalCase}}Tool) executeInternal(ctx context.Context, input api.ToolInput) (api.ToolOutput, error) {
	// Validate input using standardized framework
	if err := t.validator.Validate(ctx, input); err != nil {
		return api.ToolOutput{}, errors.NewRichError("VALIDATION_FAILED", "Input validation failed").
			WithCause(err).
			WithContext("tool", "{{.Domain}}_{{.Action}}_{{.Object}}").
			WithContext("session_id", input.SessionID)
	}

	// Extract and validate input parameters
	{{range .InputFields}}
	{{if .Required}}
	{{.Name | camelCase}}, exists := input.Data["{{.Name}}"]
	if !exists {
		return api.ToolOutput{}, errors.NewRichError("MISSING_PARAMETER", "Required parameter missing").
			WithContext("parameter", "{{.Name}}").
			WithContext("tool", "{{$.Domain}}_{{$.Action}}_{{$.Object}}")
	}
	{{.Name | camelCase}}Typed, ok := {{.Name | camelCase}}.({{.Type}})
	if !ok {
		return api.ToolOutput{}, errors.NewRichError("INVALID_PARAMETER_TYPE", "Parameter has invalid type").
			WithContext("parameter", "{{.Name}}").
			WithContext("expected_type", "{{.Type}}").
			WithContext("tool", "{{$.Domain}}_{{$.Action}}_{{$.Object}}")
	}
	{{else}}
	{{.Name | camelCase}}Typed, _ := input.Data["{{.Name}}"].({{.Type}})
	{{end}}
	{{end}}

	// Initialize contextual logging
	logger := t.logger.WithContext(ctx).WithFields(map[string]interface{}{
		"tool":       "{{.Domain}}_{{.Action}}_{{.Object}}",
		"session_id": input.SessionID,
		{{range .InputFields}}
		{{if .Required}}"{{.Name}}": {{.Name | camelCase}}Typed,{{end}}
		{{end}}
	})

	logger.Info("starting {{.Action}} {{.Object}} operation")
	startTime := time.Now()

	// TODO: Implement {{.Domain}} {{.Action}} {{.Object}} business logic here
	// Example implementation structure:
	//
	// 1. Prepare operation context
	// 2. Execute domain-specific logic
	// 3. Handle results and errors
	// 4. Return structured output

	// Placeholder implementation - replace with actual business logic
	result := map[string]interface{}{
		"status": "success",
		"message": "{{.ToolName | pascalCase}} operation completed successfully",
		"execution_time": time.Since(startTime).String(),
		{{range .OutputFields}}
		{{if ne .Name "status"}}"{{.Name}}": getDefault{{.Type | pascalCase}}(),{{end}}
		{{end}}
	}

	logger.Info("completed {{.Action}} {{.Object}} operation",
		"duration", time.Since(startTime),
		"status", "success")

	return api.ToolOutput{
		Data: result,
	}, nil
}

// Metadata implements the api.Tool interface
func (t *{{.ToolName | pascalCase}}Tool) Metadata() api.ToolMetadata {
	return api.ToolMetadata{
		Name:        "{{.Domain}}_{{.Action}}_{{.Object}}",
		Description: "{{if .Description}}{{.Description}}{{else}}{{.Action | title}} {{.Object}} in {{.Domain}} domain{{end}}",
		Version:     "{{.Version}}",
	}
}

{{range .OutputFields}}
{{if ne .Name "status"}}
// getDefault{{.Type | pascalCase}} returns a default value for {{.Type}}
func getDefault{{.Type | pascalCase}}() {{.Type}} {
	{{if eq .Type "string"}}return ""
	{{else if eq .Type "int"}}return 0
	{{else if eq .Type "int64"}}return int64(0)
	{{else if eq .Type "float64"}}return 0.0
	{{else if eq .Type "bool"}}return false
	{{else if hasPrefix .Type "[]"}}return {{.Type}}{}
	{{else}}return {{.Type}}{}{{end}}
}
{{end}}
{{end}}
