package {{.Domain}}

import (
	"context"
	"testing"

	"github.com/Azure/container-kit/pkg/mcp/api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func Test{{.ToolName | pascalCase}}Tool_Execute(t *testing.T) {
	tool := New{{.ToolName | pascalCase}}Tool()
	ctx := context.Background()

	tests := []struct {
		name        string
		input       api.ToolInput
		expectError bool
		errorCode   string
	}{
		{
			name: "valid input",
			input: api.ToolInput{
				SessionID: "test-session",
				Data: map[string]interface{}{
					{{range .InputFields}}
					{{if .Required}}"{{.Name}}": getValid{{.Type | pascalCase}}{{.Name | pascalCase}}(),{{end}}
					{{end}}
				},
			},
			expectError: false,
		},
		{{range .InputFields}}
		{{if .Required}}
		{
			name: "missing {{.Name}}",
			input: api.ToolInput{
				SessionID: "test-session",
				Data: map[string]interface{}{
					// Missing {{.Name}}
					{{range $.InputFields}}
					{{if and .Required (ne .Name $.Name)}}"{{.Name}}": getValid{{.Type | pascalCase}}{{.Name | pascalCase}}(),{{end}}
					{{end}}
				},
			},
			expectError: true,
			errorCode:   "VALIDATION_FAILED",
		},
		{
			name: "invalid {{.Name}} type",
			input: api.ToolInput{
				SessionID: "test-session",
				Data: map[string]interface{}{
					"{{.Name}}": 123, // Wrong type
					{{range $.InputFields}}
					{{if and .Required (ne .Name $.Name)}}"{{.Name}}": getValid{{.Type | pascalCase}}{{.Name | pascalCase}}(),{{end}}
					{{end}}
				},
			},
			expectError: true,
			errorCode:   "VALIDATION_FAILED",
		},
		{{end}}
		{{end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output, err := tool.Execute(ctx, tt.input)

			if tt.expectError {
				require.Error(t, err)
				if tt.errorCode != "" {
					// Check if error contains expected code
					assert.Contains(t, err.Error(), tt.errorCode)
				}
			} else {
				require.NoError(t, err)
				assert.NotNil(t, output.Data)

				// Verify output structure
				status, exists := output.Data["status"]
				assert.True(t, exists, "output should contain status field")
				assert.Equal(t, "success", status)
			}
		})
	}
}

func Test{{.ToolName | pascalCase}}Tool_Metadata(t *testing.T) {
	tool := New{{.ToolName | pascalCase}}Tool()
	metadata := tool.Metadata()

	assert.Equal(t, "{{.Domain}}_{{.Action}}_{{.Object}}", metadata.Name)
	assert.NotEmpty(t, metadata.Description)
	assert.Equal(t, "{{.Version}}", metadata.Version)
}

func Test{{.ToolName | pascalCase}}Tool_InterfaceCompliance(t *testing.T) {
	// Verify tool implements api.Tool interface
	var _ api.Tool = New{{.ToolName | pascalCase}}Tool()
}

func Benchmark{{.ToolName | pascalCase}}Tool_Execute(b *testing.B) {
	tool := New{{.ToolName | pascalCase}}Tool()
	ctx := context.Background()
	input := api.ToolInput{
		SessionID: "benchmark-session",
		Data: map[string]interface{}{
			{{range .InputFields}}
			{{if .Required}}"{{.Name}}": getValid{{.Type | pascalCase}}{{.Name | pascalCase}}(),{{end}}
			{{end}}
		},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := tool.Execute(ctx, input)
		if err != nil {
			b.Fatalf("execution failed: %v", err)
		}
	}
}

// Helper functions for generating valid test data

{{range .InputFields}}
func getValid{{.Type | pascalCase}}{{.Name | pascalCase}}() {{.Type}} {
	{{if eq .Type "string"}}
	{{if eq .Name "image_ref"}}return "nginx:latest"
	{{else if eq .Name "dockerfile_path"}}return "./Dockerfile"
	{{else if eq .Name "manifest_path"}}return "./k8s/deployment.yaml"
	{{else if eq .Name "repo_url"}}return "https://github.com/example/repo"
	{{else if eq .Name "session_id"}}return "test-session-123"
	{{else}}return "test-{{.Name}}"{{end}}
	{{else if eq .Type "int"}}return 42
	{{else if eq .Type "int64"}}return int64(42)
	{{else if eq .Type "float64"}}return 3.14
	{{else if eq .Type "bool"}}return true
	{{else if hasPrefix .Type "[]"}}return {{.Type}}{}
	{{else}}return {{.Type}}{}{{end}}
}
{{end}}
