package main

// Template for generating tool adapters
const adapterTemplate = `// Code generated by tool-generator. DO NOT EDIT.

package adapters

import (
	"context"
	"fmt"

	"github.com/Azure/container-copilot/pkg/mcp/internal/orchestration/dispatch"
	"github.com/Azure/container-copilot/pkg/mcp/internal/tools"
)

// {{.StructName}}Adapter adapts {{.StructName}} to the dispatch.Tool interface
type {{.StructName}}Adapter struct {
	tool *tools.{{.StructName}}
}

// New{{.StructName}}Adapter creates a new adapter instance
func New{{.StructName}}Adapter() dispatch.Tool {
	return &{{.StructName}}Adapter{
		// Tool will be created with proper dependencies during registration
	}
}

// SetTool sets the underlying tool instance
func (a *{{.StructName}}Adapter) SetTool(tool *tools.{{.StructName}}) {
	a.tool = tool
}

// Execute implements dispatch.Tool interface
func (a *{{.StructName}}Adapter) Execute(ctx context.Context, args interface{}) (interface{}, error) {
	if a.tool == nil {
		return nil, fmt.Errorf("tool not initialized")
	}

	// For now, we'll use a generic approach
	// In the future, this will be type-safe
	return nil, fmt.Errorf("{{.Name}} execution not yet implemented")
}

// GetMetadata implements dispatch.Tool interface
func (a *{{.StructName}}Adapter) GetMetadata() dispatch.ToolMetadata {
	return dispatch.ToolMetadata{
		Name:         "{{.Name}}",
		Description:  "{{.Description}}",
		Category:     "{{.Category}}",
		Version:      "1.0.0",
		Dependencies: []string{},
		Capabilities: []string{},
		Requirements: []string{},
		Parameters:   make(map[string]string),
	}
}
`

// Template for generating converters
const convertersTemplate = `// Code generated by tool-generator. DO NOT EDIT.

package generated

import (
	"fmt"

	"github.com/Azure/container-copilot/pkg/mcp/internal/orchestration/dispatch"
)

{{range .}}
// Convert{{.StructName}}Args converts generic args to {{.Name}} specific args
func Convert{{.StructName}}Args(args map[string]interface{}) (dispatch.ToolArgs, error) {
	// For now, return a generic converter
	// This will be replaced with type-specific conversion
	return &GenericToolArgs{
		ToolName: "{{.Name}}",
		Args:     args,
	}, nil
}
{{end}}

// GenericToolArgs is a temporary implementation for tool args
type GenericToolArgs struct {
	ToolName string
	Args     map[string]interface{}
}

// Validate implements dispatch.ToolArgs
func (g *GenericToolArgs) Validate() error {
	if g.Args == nil {
		return fmt.Errorf("args cannot be nil")
	}

	// Check for session_id
	if _, ok := g.Args["session_id"]; !ok {
		return fmt.Errorf("session_id is required")
	}

	return nil
}
`

// Template for generating registry
const registryTemplate = `// Code generated by tool-generator. DO NOT EDIT.

package generated

import (
	"github.com/Azure/container-copilot/pkg/mcp/internal/orchestration/dispatch"
	"github.com/Azure/container-copilot/pkg/mcp/internal/orchestration/dispatch/generated/adapters"
)

// RegisterAllTools registers all tools with the dispatcher
func RegisterAllTools(d *dispatch.ToolDispatcher) error {
	{{range .}}
	// Register {{.Name}}
	if err := d.RegisterTool(
		"{{.Name}}",
		func() dispatch.Tool {
			return adapters.New{{.StructName}}Adapter()
		},
		Convert{{.StructName}}Args,
	); err != nil {
		return err
	}
	{{end}}

	return nil
}

// GetToolNames returns all registered tool names
func GetToolNames() []string {
	return []string{
		{{range .}}"{{.Name}}",
		{{end}}
	}
}
`
