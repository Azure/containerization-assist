
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>utils: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/Azure/container-kit/pkg/mcp/internal/utils/log_capture.go (0.0%)</option>

				<option value="file1">github.com/Azure/container-kit/pkg/mcp/internal/utils/mcperror.go (44.4%)</option>

				<option value="file2">github.com/Azure/container-kit/pkg/mcp/internal/utils/preference_store.go (0.0%)</option>

				<option value="file3">github.com/Azure/container-kit/pkg/mcp/internal/utils/ring_buffer.go (84.8%)</option>

				<option value="file4">github.com/Azure/container-kit/pkg/mcp/internal/utils/sandbox_executor.go (93.0%)</option>

				<option value="file5">github.com/Azure/container-kit/pkg/mcp/internal/utils/schema_utils.go (0.0%)</option>

				<option value="file6">github.com/Azure/container-kit/pkg/mcp/internal/utils/secret_scanner.go (69.9%)</option>

				<option value="file7">github.com/Azure/container-kit/pkg/mcp/internal/utils/security_validator.go (91.9%)</option>

				<option value="file8">github.com/Azure/container-kit/pkg/mcp/internal/utils/slog_utils.go (0.0%)</option>

				<option value="file9">github.com/Azure/container-kit/pkg/mcp/internal/utils/validation_standardizer.go (54.5%)</option>

				<option value="file10">github.com/Azure/container-kit/pkg/mcp/internal/utils/workspace.go (78.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package utils

import (
        "fmt"
        "io"
        "strings"
        "time"

        "github.com/rs/zerolog"
)

// LogCaptureHook is a zerolog hook that captures logs to a ring buffer
type LogCaptureHook struct {
        buffer *RingBuffer
}

// NewLogCaptureHook creates a new log capture hook
func NewLogCaptureHook(capacity int) *LogCaptureHook <span class="cov0" title="0">{
        return &amp;LogCaptureHook{
                buffer: NewRingBuffer(capacity),
        }
}</span>

// Run implements zerolog.Hook interface
func (h *LogCaptureHook) Run(e *zerolog.Event, level zerolog.Level, msg string) <span class="cov0" title="0">{
        // Extract fields from the event (this is a bit hacky but zerolog doesn't expose fields directly)
        entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level.String(),
                Message:   msg,
                Fields:    make(map[string]interface{}),
        }

        h.buffer.Add(entry)
}</span>

// GetBuffer returns the underlying ring buffer
func (h *LogCaptureHook) GetBuffer() *RingBuffer <span class="cov0" title="0">{
        return h.buffer
}</span>

// LogCaptureWriter is an io.Writer that captures structured logs
type LogCaptureWriter struct {
        buffer *RingBuffer
        writer io.Writer // Original writer to pass through
}

// NewLogCaptureWriter creates a new log capture writer
func NewLogCaptureWriter(buffer *RingBuffer, writer io.Writer) *LogCaptureWriter <span class="cov0" title="0">{
        return &amp;LogCaptureWriter{
                buffer: buffer,
                writer: writer,
        }
}</span>

// Write implements io.Writer interface
func (w *LogCaptureWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Pass through to original writer first
        if w.writer != nil </span><span class="cov0" title="0">{
                n, err = w.writer.Write(p)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
        } else<span class="cov0" title="0"> {
                n = len(p)
        }</span>

        // Parse the log line and capture it
        <span class="cov0" title="0">line := string(p)
        entry := parseZerologLine(line)
        if entry.Timestamp.IsZero() </span><span class="cov0" title="0">{
                entry.Timestamp = time.Now()
        }</span>

        <span class="cov0" title="0">w.buffer.Add(entry)

        return n, nil</span>
}

// parseZerologLine attempts to parse a zerolog formatted line
func parseZerologLine(line string) LogEntry <span class="cov0" title="0">{
        entry := LogEntry{
                Fields: make(map[string]interface{}),
        }

        // Simple parsing - in production, you'd want more robust parsing
        parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                entry.Message = line
                return entry
        }</span>

        // Look for common patterns
        <span class="cov0" title="0">for i, part := range parts </span><span class="cov0" title="0">{
                // Level detection
                if isLogLevel(part) </span><span class="cov0" title="0">{
                        entry.Level = strings.ToLower(part)
                        continue</span>
                }

                // Time detection (ISO format)
                <span class="cov0" title="0">if strings.Contains(part, "T") &amp;&amp; strings.Contains(part, ":") </span><span class="cov0" title="0">{
                        if t, err := time.Parse(time.RFC3339, part); err == nil </span><span class="cov0" title="0">{
                                entry.Timestamp = t
                                continue</span>
                        }
                }

                // Key=value pairs
                <span class="cov0" title="0">if strings.Contains(part, "=") </span><span class="cov0" title="0">{
                        kv := strings.SplitN(part, "=", 2)
                        if len(kv) == 2 </span><span class="cov0" title="0">{
                                entry.Fields[kv[0]] = strings.Trim(kv[1], "\"")
                                continue</span>
                        }
                }

                // Caller detection
                <span class="cov0" title="0">if strings.Contains(part, ".go:") </span><span class="cov0" title="0">{
                        entry.Caller = part
                        continue</span>
                }

                // Everything else is part of the message
                <span class="cov0" title="0">if i &gt; 0 &amp;&amp; entry.Level != "" </span><span class="cov0" title="0">{
                        // Join remaining parts as message
                        entry.Message = strings.Join(parts[i:], " ")
                        break</span>
                }
        }

        // Clean up message
        <span class="cov0" title="0">entry.Message = strings.TrimSpace(entry.Message)

        return entry</span>
}

// isLogLevel checks if a string is a log level
func isLogLevel(s string) bool <span class="cov0" title="0">{
        levels := []string{
                "TRC", "DBG", "INF", "WRN", "ERR", "FTL", "PNC",
                "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL", "PANIC",
        }

        upper := strings.ToUpper(strings.TrimSpace(s))
        for _, level := range levels </span><span class="cov0" title="0">{
                if upper == level </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GlobalLogCapture is a global instance for capturing logs
var GlobalLogCapture *LogCaptureHook

// InitializeLogCapture sets up global log capture
func InitializeLogCapture(capacity int) *LogCaptureHook <span class="cov0" title="0">{
        if GlobalLogCapture == nil </span><span class="cov0" title="0">{
                GlobalLogCapture = NewLogCaptureHook(capacity)
        }</span>
        <span class="cov0" title="0">return GlobalLogCapture</span>
}

// GetGlobalLogBuffer returns the global log buffer
func GetGlobalLogBuffer() *RingBuffer <span class="cov0" title="0">{
        if GlobalLogCapture != nil </span><span class="cov0" title="0">{
                return GlobalLogCapture.GetBuffer()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateCaptureLogger creates a logger that captures to a buffer
func CreateCaptureLogger(buffer *RingBuffer, originalWriter io.Writer) zerolog.Logger <span class="cov0" title="0">{
        captureWriter := NewLogCaptureWriter(buffer, originalWriter)
        return zerolog.New(captureWriter).With().Timestamp().Logger()
}</span>

// LoggerWithCapture wraps an existing logger to capture logs
func LoggerWithCapture(logger zerolog.Logger, buffer *RingBuffer) zerolog.Logger <span class="cov0" title="0">{
        // This is a simplified approach - in production you'd want to properly
        // hook into the logger's output
        return logger.Output(NewLogCaptureWriter(buffer, logger))
}</span>

// FormatLogEntry formats a log entry for display
func FormatLogEntry(entry LogEntry) string <span class="cov0" title="0">{
        // Format: [TIMESTAMP] LEVEL MESSAGE fields...
        var parts []string

        parts = append(parts, fmt.Sprintf("[%s]", entry.Timestamp.Format("2006-01-02 15:04:05.000")))
        parts = append(parts, strings.ToUpper(entry.Level))

        if entry.Message != "" </span><span class="cov0" title="0">{
                parts = append(parts, entry.Message)
        }</span>

        // Add fields
        <span class="cov0" title="0">for k, v := range entry.Fields </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%s=%v", k, v))
        }</span>

        <span class="cov0" title="0">if entry.Caller != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("caller=%s", entry.Caller))
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package utils

import (
        "fmt"
        "strings"

        v20250326 "github.com/localrivet/gomcp/mcp/v20250326"
)

type MCPError struct {
        Code    v20250326.ErrorCode `json:"code"`
        Message string              `json:"message"`
        Data    interface{}         `json:"data,omitempty"`
}

func (e *MCPError) Error() string <span class="cov1" title="1">{
        return e.Message
}</span>

func (e *MCPError) GetCode() v20250326.ErrorCode <span class="cov0" title="0">{
        return e.Code
}</span>

func (e *MCPError) GetData() interface{} <span class="cov0" title="0">{
        return e.Data
}</span>

func New(code v20250326.ErrorCode, message string) *MCPError <span class="cov10" title="10">{
        return &amp;MCPError{
                Code:    code,
                Message: message,
        }
}</span>

func NewWithData(code v20250326.ErrorCode, message string, data interface{}) *MCPError <span class="cov6" title="4">{
        return &amp;MCPError{
                Code:    code,
                Message: message,
                Data:    data,
        }
}</span>

func Wrap(code v20250326.ErrorCode, message string, err error) *MCPError <span class="cov1" title="1">{
        var data interface{}
        if err != nil </span><span class="cov1" title="1">{
                data = map[string]interface{}{
                        "original_error": err.Error(),
                }
        }</span>

        <span class="cov1" title="1">fullMessage := message
        if err != nil </span><span class="cov1" title="1">{
                fullMessage = fmt.Sprintf("%s: %v", message, err)
        }</span>

        <span class="cov1" title="1">return &amp;MCPError{
                Code:    code,
                Message: fullMessage,
                Data:    data,
        }</span>
}

var (
        CodeSessionNotFound        = v20250326.ErrorCodeInvalidRequest
        CodeSessionExpired         = v20250326.ErrorCodeInvalidRequest
        CodeSessionExists          = v20250326.ErrorCodeInvalidArguments
        CodeWorkspaceQuotaExceeded = v20250326.ErrorCodeInternalServerError
        CodeMaxSessionsReached     = v20250326.ErrorCodeInternalServerError
        CodeSessionCorrupted       = v20250326.ErrorCodeInternalServerError
)

var (
        CodeAnalysisRequired   = v20250326.ErrorCodeInvalidRequest
        CodeDockerfileRequired = v20250326.ErrorCodeInvalidRequest
        CodeBuildRequired      = v20250326.ErrorCodeInvalidRequest
        CodeImageRequired      = v20250326.ErrorCodeInvalidRequest
        CodeManifestsRequired  = v20250326.ErrorCodeInvalidRequest
        CodeStageNotReady      = v20250326.ErrorCodeInvalidRequest
)

var (
        CodeRequiredFieldMissing = v20250326.ErrorCodeInvalidArguments
        CodeInvalidFormat        = v20250326.ErrorCodeInvalidArguments
        CodeInvalidPath          = v20250326.ErrorCodeInvalidArguments
        CodeInvalidImageName     = v20250326.ErrorCodeInvalidArguments
        CodeInvalidNamespace     = v20250326.ErrorCodeInvalidArguments
        CodeUnsupportedOperation = v20250326.ErrorCodeInvalidRequest
)

var (
        CodeServiceUnavailable = v20250326.ErrorCodeInternalServerError
        CodeTimeoutError       = v20250326.ErrorCodeInternalServerError
        CodePermissionDenied   = v20250326.ErrorCodeInvalidRequest
        CodeNetworkError       = v20250326.ErrorCodeInternalServerError
        CodeDiskFull           = v20250326.ErrorCodeInternalServerError
        CodeQuotaExceeded      = v20250326.ErrorCodeInternalServerError
)

var (
        CodeDockerfileInvalid = v20250326.ErrorCodeInvalidArguments
        CodeBuildFailed       = v20250326.ErrorCodeInternalServerError
        CodeImagePushFailed   = v20250326.ErrorCodeInternalServerError
        CodeManifestInvalid   = v20250326.ErrorCodeInvalidArguments
        CodeDeploymentFailed  = v20250326.ErrorCodeInternalServerError
        CodeHealthCheckFailed = v20250326.ErrorCodeInternalServerError
)

func WrapSessionError(err error, sessionID string) *MCPError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "session_id":     sessionID,
                "original_error": err.Error(),
        }

        return &amp;MCPError{
                Code:    CodeSessionNotFound,
                Message: fmt.Sprintf("session %s: %v", sessionID, err),
                Data:    data,
        }</span>
}

func WrapValidationError(err error, field string) *MCPError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "field":          field,
                "original_error": err.Error(),
        }

        return &amp;MCPError{
                Code:    CodeInvalidFormat,
                Message: fmt.Sprintf("field '%s': %v", field, err),
                Data:    data,
        }</span>
}

func WrapWorkflowError(err error, stage string) *MCPError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "stage":          stage,
                "original_error": err.Error(),
        }

        return &amp;MCPError{
                Code:    CodeStageNotReady,
                Message: fmt.Sprintf("stage %s: %v", stage, err),
                Data:    data,
        }</span>
}

func WrapInfrastructureError(err error, service string) *MCPError <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data := map[string]interface{}{
                "service":        service,
                "original_error": err.Error(),
        }

        return &amp;MCPError{
                Code:    CodeServiceUnavailable,
                Message: fmt.Sprintf("service %s: %v", service, err),
                Data:    data,
        }</span>
}

func NewSessionNotFound(sessionID string) *MCPError <span class="cov5" title="3">{
        return NewWithData(CodeSessionNotFound, "session not found", map[string]interface{}{
                "session_id": sessionID,
        })
}</span>

func NewSessionExpired(sessionID string) *MCPError <span class="cov0" title="0">{
        return NewWithData(CodeSessionExpired, "session expired", map[string]interface{}{
                "session_id": sessionID,
        })
}</span>

func NewBuildFailed(message string) *MCPError <span class="cov5" title="3">{
        return New(CodeBuildFailed, fmt.Sprintf("docker build failed: %s", message))
}</span>

func NewDockerfileInvalid(message string) *MCPError <span class="cov1" title="1">{
        return New(CodeDockerfileInvalid, fmt.Sprintf("dockerfile invalid: %s", message))
}</span>

func NewDeploymentFailed(message string) *MCPError <span class="cov0" title="0">{
        return New(CodeDeploymentFailed, fmt.Sprintf("deployment failed: %s", message))
}</span>

func NewRequiredFieldMissing(field string) *MCPError <span class="cov0" title="0">{
        return NewWithData(CodeRequiredFieldMissing, "required field missing", map[string]interface{}{
                "field": field,
        })
}</span>

func IsSessionError(err error) bool <span class="cov5" title="3">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov3" title="2">{
                if data, ok := mcpErr.Data.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        if _, hasSessionID := data["session_id"]; hasSessionID </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
                <span class="cov1" title="1">return strings.Contains(strings.ToLower(mcpErr.Message), "session")</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsWorkflowError(err error) bool <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                return mcpErr.Code == CodeAnalysisRequired ||
                        mcpErr.Code == CodeDockerfileRequired ||
                        mcpErr.Code == CodeBuildRequired ||
                        mcpErr.Code == CodeImageRequired ||
                        mcpErr.Code == CodeManifestsRequired ||
                        mcpErr.Code == CodeStageNotReady
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsValidationError(err error) bool <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                return mcpErr.Code == CodeRequiredFieldMissing ||
                        mcpErr.Code == CodeInvalidFormat ||
                        mcpErr.Code == CodeInvalidPath ||
                        mcpErr.Code == CodeInvalidImageName ||
                        mcpErr.Code == CodeInvalidNamespace ||
                        mcpErr.Code == CodeUnsupportedOperation
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsInfrastructureError(err error) bool <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                return mcpErr.Code == CodeServiceUnavailable ||
                        mcpErr.Code == CodeTimeoutError ||
                        mcpErr.Code == CodePermissionDenied ||
                        mcpErr.Code == CodeNetworkError ||
                        mcpErr.Code == CodeDiskFull ||
                        mcpErr.Code == CodeQuotaExceeded
        }</span>
        <span class="cov0" title="0">return false</span>
}

func IsBuildError(err error) bool <span class="cov0" title="0">{
        if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                return mcpErr.Code == CodeDockerfileInvalid ||
                        mcpErr.Code == CodeBuildFailed ||
                        mcpErr.Code == CodeImagePushFailed ||
                        mcpErr.Code == CodeManifestInvalid ||
                        mcpErr.Code == CodeDeploymentFailed ||
                        mcpErr.Code == CodeHealthCheckFailed
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (e *MCPError) ToMCPErrorResponse(id interface{}) *v20250326.ErrorResponse <span class="cov0" title="0">{
        return &amp;v20250326.ErrorResponse{
                Code:    e.Code,
                Message: e.Message,
        }
}</span>

func FromError(err error) *MCPError <span class="cov7" title="5">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov7" title="5">if mcpErr, ok := err.(*MCPError); ok </span><span class="cov0" title="0">{
                return mcpErr
        }</span>

        <span class="cov7" title="5">errStr := strings.ToLower(err.Error())

        switch </span>{
        case strings.Contains(errStr, "not found"):<span class="cov1" title="1">
                if strings.Contains(errStr, "session") </span><span class="cov1" title="1">{
                        return NewSessionNotFound("")
                }</span>
                <span class="cov0" title="0">return New(v20250326.ErrorCodeResourceNotFound, err.Error())</span>

        case strings.Contains(errStr, "build") &amp;&amp; strings.Contains(errStr, "failed"):<span class="cov1" title="1">
                return NewBuildFailed(err.Error())</span>

        case strings.Contains(errStr, "dockerfile") &amp;&amp; strings.Contains(errStr, "invalid"):<span class="cov1" title="1">
                return NewDockerfileInvalid(err.Error())</span>

        case strings.Contains(errStr, "deploy") &amp;&amp; strings.Contains(errStr, "failed"):<span class="cov0" title="0">
                return NewDeploymentFailed(err.Error())</span>

        case strings.Contains(errStr, "invalid") || strings.Contains(errStr, "malformed"):<span class="cov0" title="0">
                return New(v20250326.ErrorCodeInvalidArguments, err.Error())</span>

        case strings.Contains(errStr, "permission") || strings.Contains(errStr, "forbidden"):<span class="cov1" title="1">
                return New(v20250326.ErrorCodeInvalidRequest, err.Error())</span>

        default:<span class="cov1" title="1">
                return New(v20250326.ErrorCodeInternalServerError, err.Error())</span>
        }
}

type ErrorCategory struct {
        Code           string
        Name           string
        Description    string
        DefaultMessage string
        Retryable      bool
        UserGuidance   string
        RecoverySteps  []string
}

func GetErrorCategory(code v20250326.ErrorCode) (*ErrorCategory, bool) <span class="cov6" title="4">{
        category, exists := errorCategoryMapping[string(code)]
        if exists </span><span class="cov6" title="4">{
                return &amp;category, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

var errorCategoryMapping = map[string]ErrorCategory{
        string(v20250326.ErrorCodeInvalidArguments): {
                Code:           string(v20250326.ErrorCodeInvalidArguments),
                Name:           "Invalid Arguments",
                Description:    "The provided arguments or configuration are invalid",
                DefaultMessage: "Invalid arguments provided. Please check the input parameters.",
                Retryable:      false,
                UserGuidance:   "Review and fix the invalid parameters",
                RecoverySteps: []string{
                        "Check argument syntax and format",
                        "Verify required fields are present",
                        "Ensure values match expected patterns",
                        "Review documentation for correct usage",
                },
        },

        string(v20250326.ErrorCodeInternalServerError): {
                Code:           string(v20250326.ErrorCodeInternalServerError),
                Name:           "Internal Server Error",
                Description:    "An internal error occurred during operation",
                DefaultMessage: "An internal error occurred. Please retry or contact support.",
                Retryable:      true,
                UserGuidance:   "Check system resources and connectivity",
                RecoverySteps: []string{
                        "Retry the operation",
                        "Check system resource availability",
                        "Verify network connectivity",
                        "Review system logs for details",
                        "Contact support if issue persists",
                },
        },

        string(v20250326.ErrorCodeInvalidRequest): {
                Code:           string(v20250326.ErrorCodeInvalidRequest),
                Name:           "Invalid Request",
                Description:    "The request is invalid or cannot be processed",
                DefaultMessage: "Invalid request. Please check the request parameters.",
                Retryable:      false,
                UserGuidance:   "Verify request format and permissions",
                RecoverySteps: []string{
                        "Check request syntax",
                        "Verify you have necessary permissions",
                        "Ensure required resources exist",
                        "Review API documentation",
                },
        },

        string(v20250326.ErrorCodeResourceNotFound): {
                Code:           string(v20250326.ErrorCodeResourceNotFound),
                Name:           "Resource Not Found",
                Description:    "The requested resource could not be found",
                DefaultMessage: "Resource not found. Please check the resource identifier.",
                Retryable:      false,
                UserGuidance:   "Verify the resource exists and is accessible",
                RecoverySteps: []string{
                        "Check resource identifier spelling",
                        "Verify resource exists",
                        "Ensure you have access permissions",
                        "Create the resource if needed",
                },
        },
}

func GetUserFriendlyMessage(mcpErr *MCPError) string <span class="cov1" title="1">{
        if category, ok := GetErrorCategory(mcpErr.Code); ok </span><span class="cov1" title="1">{
                return category.DefaultMessage
        }</span>
        <span class="cov0" title="0">return mcpErr.Message</span>
}

func ShouldRetry(mcpErr *MCPError) bool <span class="cov3" title="2">{
        if category, ok := GetErrorCategory(mcpErr.Code); ok </span><span class="cov3" title="2">{
                return category.Retryable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func GetRecoverySteps(mcpErr *MCPError) []string <span class="cov0" title="0">{
        if category, ok := GetErrorCategory(mcpErr.Code); ok </span><span class="cov0" title="0">{
                return category.RecoverySteps
        }</span>
        <span class="cov0" title="0">return []string{"Check error details", "Review logs for more information"}</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package utils

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "sync"
        "time"

        "github.com/Azure/container-kit/pkg/mcp/internal/types"
        "github.com/rs/zerolog"

        bolt "go.etcd.io/bbolt"
)

type PreferenceStore struct {
        db            *bolt.DB
        mutex         sync.RWMutex
        logger        zerolog.Logger
        encryptionKey []byte // 32-byte key for AES-256
}

const UserPreferencesBucket = "user_preferences"

type GlobalPreferences struct {
        UserID    string    `json:"user_id"`
        UpdatedAt time.Time `json:"updated_at"`

        DefaultOptimization string `json:"default_optimization"` // size, speed, security
        DefaultNamespace    string `json:"default_namespace"`
        DefaultReplicas     int    `json:"default_replicas"`
        PreferredRegistry   string `json:"preferred_registry"`
        DefaultServiceType  string `json:"default_service_type"` // ClusterIP, LoadBalancer, NodePort
        AutoRollbackEnabled bool   `json:"auto_rollback_enabled"`

        AlwaysUseHealthCheck bool   `json:"always_use_health_check"`
        PreferMultiStage     bool   `json:"prefer_multi_stage"`
        DefaultPlatform      string `json:"default_platform"` // linux/amd64, linux/arm64, etc.

        DefaultResourceLimits  types.ResourceLimits `json:"default_resource_limits"`
        PreferredCloudProvider string               `json:"preferred_cloud_provider"` // aws, gcp, azure, local

        LanguageDefaults map[string]LanguagePrefs `json:"language_defaults"`

        RecentRepositories []string `json:"recent_repositories"`
        RecentNamespaces   []string `json:"recent_namespaces"`
        RecentAppNames     []string `json:"recent_app_names"`
}

type LanguagePrefs struct {
        PreferredBaseImage  string            `json:"preferred_base_image"`
        DefaultBuildTool    string            `json:"default_build_tool"` // npm, yarn, maven, gradle, etc.
        DefaultTestCommand  string            `json:"default_test_command"`
        CommonBuildArgs     map[string]string `json:"common_build_args"`
        DefaultPort         int               `json:"default_port"`
        HealthCheckEndpoint string            `json:"health_check_endpoint"`
}

func NewPreferenceStore(dbPath string, logger zerolog.Logger, encryptionPassphrase string) (*PreferenceStore, error) <span class="cov0" title="0">{
        var db *bolt.DB
        var err error

        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                db, err = bolt.Open(dbPath, 0o600, &amp;bolt.Options{Timeout: 5 * time.Second})
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if i == 2 &amp;&amp; err == bolt.ErrTimeout </span><span class="cov0" title="0">{
                        logger.Warn().
                                Str("path", dbPath).
                                Msg("Preference database appears to be locked, attempting recovery")

                        backupPath := fmt.Sprintf("%s.locked.%d", dbPath, time.Now().Unix())
                        if renameErr := os.Rename(dbPath, backupPath); renameErr == nil </span><span class="cov0" title="0">{
                                logger.Warn().
                                        Str("old_path", dbPath).
                                        Str("new_path", backupPath).
                                        Msg("Moved locked preference database")

                                db, err = bolt.Open(dbPath, 0o600, &amp;bolt.Options{Timeout: 5 * time.Second})
                                if err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if i &lt; 2 </span><span class="cov0" title="0">{
                        logger.Warn().
                                Err(err).
                                Int("attempt", i+1).
                                Msg("Failed to open preference database, retrying...")
                        time.Sleep(time.Duration(i+1) * time.Second)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open preference database: %v", err)
        }</span>

        <span class="cov0" title="0">err = db.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                _, err := tx.CreateBucketIfNotExists([]byte(UserPreferencesBucket))
                return err
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if closeErr := db.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(closeErr).Msg("Failed to close database after bucket creation error")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to create preferences bucket: %v", err)</span>
        }

        <span class="cov0" title="0">var encryptionKey []byte
        if encryptionPassphrase != "" </span><span class="cov0" title="0">{
                hash := sha256.Sum256([]byte(encryptionPassphrase))
                encryptionKey = hash[:]
                logger.Info().Msg("Preference store encryption enabled")
        }</span> else<span class="cov0" title="0"> {
                logger.Warn().Msg("Preference store encryption disabled - consider using encryption for production")
        }</span>

        <span class="cov0" title="0">return &amp;PreferenceStore{
                db:            db,
                logger:        logger,
                encryptionKey: encryptionKey,
        }, nil</span>
}

func (ps *PreferenceStore) GetUserPreferences(userID string) (*GlobalPreferences, error) <span class="cov0" title="0">{
        ps.mutex.RLock()
        defer ps.mutex.RUnlock()

        var prefs GlobalPreferences

        err := ps.db.View(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                bucket := tx.Bucket([]byte(UserPreferencesBucket))
                if bucket == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("preferences bucket not found")
                }</span>

                <span class="cov0" title="0">data := bucket.Get([]byte(userID))
                if data == nil </span><span class="cov0" title="0">{
                        prefs = ps.getDefaultPreferences(userID)
                        return nil
                }</span>

                <span class="cov0" title="0">decryptedData, err := ps.decrypt(data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt preferences: %w", err)
                }</span>

                <span class="cov0" title="0">return json.Unmarshal(decryptedData, &amp;prefs)</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user preferences: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;prefs, nil</span>
}

func (ps *PreferenceStore) SaveUserPreferences(prefs *GlobalPreferences) error <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        prefs.UpdatedAt = time.Now()

        return ps.db.Update(func(tx *bolt.Tx) error </span><span class="cov0" title="0">{
                bucket := tx.Bucket([]byte(UserPreferencesBucket))
                if bucket == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("preferences bucket not found")
                }</span>

                <span class="cov0" title="0">data, err := json.Marshal(prefs)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal preferences: %w", err)
                }</span>

                <span class="cov0" title="0">encryptedData, err := ps.encrypt(data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt preferences: %w", err)
                }</span>

                <span class="cov0" title="0">return bucket.Put([]byte(prefs.UserID), encryptedData)</span>
        })
}

func (ps *PreferenceStore) UpdatePreferencesFromSession(userID string, sessionPrefs types.UserPreferences) error <span class="cov0" title="0">{
        prefs, err := ps.GetUserPreferences(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Optimization != "" &amp;&amp; sessionPrefs.Optimization != prefs.DefaultOptimization </span><span class="cov0" title="0">{
                prefs.DefaultOptimization = sessionPrefs.Optimization
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Namespace != "" &amp;&amp; sessionPrefs.Namespace != "default" </span><span class="cov0" title="0">{
                prefs.DefaultNamespace = sessionPrefs.Namespace
                ps.addToRecentList(&amp;prefs.RecentNamespaces, sessionPrefs.Namespace, 5)
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Replicas &gt; 0 &amp;&amp; sessionPrefs.Replicas != prefs.DefaultReplicas </span><span class="cov0" title="0">{
                prefs.DefaultReplicas = sessionPrefs.Replicas
        }</span>

        <span class="cov0" title="0">if sessionPrefs.ServiceType != "" &amp;&amp; sessionPrefs.ServiceType != prefs.DefaultServiceType </span><span class="cov0" title="0">{
                prefs.DefaultServiceType = sessionPrefs.ServiceType
        }</span>

        <span class="cov0" title="0">return ps.SaveUserPreferences(prefs)</span>
}

func (ps *PreferenceStore) GetLanguageDefaults(userID, language string) (LanguagePrefs, error) <span class="cov0" title="0">{
        prefs, err := ps.GetUserPreferences(userID)
        if err != nil </span><span class="cov0" title="0">{
                return LanguagePrefs{}, err
        }</span>

        <span class="cov0" title="0">if langPrefs, ok := prefs.LanguageDefaults[language]; ok </span><span class="cov0" title="0">{
                return langPrefs, nil
        }</span>

        <span class="cov0" title="0">return ps.getSystemLanguageDefaults(language), nil</span>
}

func (ps *PreferenceStore) UpdateLanguageDefaults(userID, language string, langPrefs LanguagePrefs) error <span class="cov0" title="0">{
        prefs, err := ps.GetUserPreferences(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if prefs.LanguageDefaults == nil </span><span class="cov0" title="0">{
                prefs.LanguageDefaults = make(map[string]LanguagePrefs)
        }</span>

        <span class="cov0" title="0">prefs.LanguageDefaults[language] = langPrefs

        return ps.SaveUserPreferences(prefs)</span>
}

func (ps *PreferenceStore) ApplyPreferencesToSession(userID string, sessionPrefs *types.UserPreferences) error <span class="cov0" title="0">{
        prefs, err := ps.GetUserPreferences(userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Optimization == "" </span><span class="cov0" title="0">{
                sessionPrefs.Optimization = prefs.DefaultOptimization
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Namespace == "" </span><span class="cov0" title="0">{
                sessionPrefs.Namespace = prefs.DefaultNamespace
        }</span>

        <span class="cov0" title="0">if sessionPrefs.Replicas == 0 </span><span class="cov0" title="0">{
                sessionPrefs.Replicas = prefs.DefaultReplicas
        }</span>

        <span class="cov0" title="0">if sessionPrefs.ServiceType == "" </span><span class="cov0" title="0">{
                sessionPrefs.ServiceType = prefs.DefaultServiceType
        }</span>

        <span class="cov0" title="0">if sessionPrefs.ResourceLimits.CPULimit == "" &amp;&amp; prefs.DefaultResourceLimits.CPULimit != "" </span><span class="cov0" title="0">{
                sessionPrefs.ResourceLimits = prefs.DefaultResourceLimits
        }</span>

        <span class="cov0" title="0">sessionPrefs.IncludeHealthCheck = sessionPrefs.IncludeHealthCheck || prefs.AlwaysUseHealthCheck
        sessionPrefs.AutoRollback = sessionPrefs.AutoRollback || prefs.AutoRollbackEnabled

        return nil</span>
}

func (ps *PreferenceStore) GetSmartDefaults(userID string) (SmartDefaults, error) <span class="cov0" title="0">{
        prefs, err := ps.GetUserPreferences(userID)
        if err != nil </span><span class="cov0" title="0">{
                return SmartDefaults{}, err
        }</span>

        <span class="cov0" title="0">return SmartDefaults{
                RecentNamespaces:   prefs.RecentNamespaces,
                RecentAppNames:     prefs.RecentAppNames,
                SuggestedNamespace: ps.getMostFrequent(prefs.RecentNamespaces),
                SuggestedRegistry:  prefs.PreferredRegistry,
        }, nil</span>
}

type SmartDefaults struct {
        RecentNamespaces   []string `json:"recent_namespaces"`
        RecentAppNames     []string `json:"recent_app_names"`
        SuggestedNamespace string   `json:"suggested_namespace"`
        SuggestedRegistry  string   `json:"suggested_registry"`
}

func (ps *PreferenceStore) getDefaultPreferences(userID string) GlobalPreferences <span class="cov0" title="0">{
        return GlobalPreferences{
                UserID:               userID,
                UpdatedAt:            time.Now(),
                DefaultOptimization:  "balanced",
                DefaultNamespace:     "default",
                DefaultReplicas:      1,
                DefaultServiceType:   "ClusterIP",
                AutoRollbackEnabled:  true,
                AlwaysUseHealthCheck: true,
                PreferMultiStage:     true,
                DefaultPlatform:      "linux/amd64",
                DefaultResourceLimits: types.ResourceLimits{
                        CPURequest:    "100m",
                        CPULimit:      "500m",
                        MemoryRequest: "128Mi",
                        MemoryLimit:   "512Mi",
                },
                LanguageDefaults:   make(map[string]LanguagePrefs),
                RecentRepositories: make([]string, 0),
                RecentNamespaces:   make([]string, 0),
                RecentAppNames:     make([]string, 0),
        }
}</span>

func (ps *PreferenceStore) getSystemLanguageDefaults(language string) LanguagePrefs <span class="cov0" title="0">{
        defaults := map[string]LanguagePrefs{
                "Go": {
                        PreferredBaseImage:  "golang:1.21-alpine",
                        DefaultBuildTool:    "go",
                        DefaultTestCommand:  "go test ./...",
                        DefaultPort:         8080,
                        HealthCheckEndpoint: "/health",
                },
                "Node.js": {
                        PreferredBaseImage:  "node:20-alpine",
                        DefaultBuildTool:    "npm",
                        DefaultTestCommand:  "npm test",
                        DefaultPort:         3000,
                        HealthCheckEndpoint: "/health",
                        CommonBuildArgs: map[string]string{
                                "NODE_ENV": "production",
                        },
                },
                "Python": {
                        PreferredBaseImage:  "python:3.11-slim",
                        DefaultBuildTool:    "pip",
                        DefaultTestCommand:  "pytest",
                        DefaultPort:         8000,
                        HealthCheckEndpoint: "/health",
                },
                "Java": {
                        PreferredBaseImage:  "openjdk:17-alpine",
                        DefaultBuildTool:    "maven",
                        DefaultTestCommand:  "mvn test",
                        DefaultPort:         8080,
                        HealthCheckEndpoint: "/actuator/health",
                },
        }

        if prefs, ok := defaults[language]; ok </span><span class="cov0" title="0">{
                return prefs
        }</span>

        <span class="cov0" title="0">return LanguagePrefs{
                DefaultPort:         8080,
                HealthCheckEndpoint: "/health",
        }</span>
}

func (ps *PreferenceStore) addToRecentList(list *[]string, item string, maxSize int) <span class="cov0" title="0">{
        for i, existing := range *list </span><span class="cov0" title="0">{
                if existing == item </span><span class="cov0" title="0">{
                        *list = append((*list)[:i], (*list)[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">*list = append([]string{item}, *list...)

        if len(*list) &gt; maxSize </span><span class="cov0" title="0">{
                *list = (*list)[:maxSize]
        }</span>
}

func (ps *PreferenceStore) getMostFrequent(items []string) string <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return items[0]</span>
}

func (ps *PreferenceStore) encrypt(data []byte) ([]byte, error) <span class="cov0" title="0">{
        if ps.encryptionKey == nil </span><span class="cov0" title="0">{
                return data, nil
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher(ps.encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create encryption cipher: %v", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        <span class="cov0" title="0">ciphertext := gcm.Seal(nonce, nonce, data, nil)
        return ciphertext, nil</span>
}

func (ps *PreferenceStore) decrypt(data []byte) ([]byte, error) <span class="cov0" title="0">{
        if ps.encryptionKey == nil </span><span class="cov0" title="0">{
                return data, nil
        }</span>

        <span class="cov0" title="0">if len(data) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encrypted data too short")
        }</span>

        <span class="cov0" title="0">block, err := aes.NewCipher(ps.encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov0" title="0">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov0" title="0">nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt: %w", err)
        }</span>

        <span class="cov0" title="0">return plaintext, nil</span>
}

func (ps *PreferenceStore) Close() error <span class="cov0" title="0">{
        return ps.db.Close()
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">package utils

import (
        "strings"
        "sync"
        "time"
)

// LogEntry represents a single log entry
type LogEntry struct {
        Timestamp time.Time              `json:"timestamp"`
        Level     string                 `json:"level"`
        Message   string                 `json:"message"`
        Fields    map[string]interface{} `json:"fields,omitempty"`
        Caller    string                 `json:"caller,omitempty"`
}

// RingBuffer is a circular buffer for storing log entries
type RingBuffer struct {
        mu       sync.RWMutex
        entries  []LogEntry
        capacity int
        head     int
        count    int
}

// NewRingBuffer creates a new ring buffer with the specified capacity
func NewRingBuffer(capacity int) *RingBuffer <span class="cov5" title="7">{
        if capacity &lt;= 0 </span><span class="cov0" title="0">{
                capacity = 1000
        }</span>
        <span class="cov5" title="7">return &amp;RingBuffer{
                entries:  make([]LogEntry, capacity),
                capacity: capacity,
                head:     0,
                count:    0,
        }</span>
}

// Add adds a new log entry to the ring buffer
func (rb *RingBuffer) Add(entry LogEntry) <span class="cov10" title="71">{
        rb.mu.Lock()
        defer rb.mu.Unlock()

        rb.entries[rb.head] = entry
        rb.head = (rb.head + 1) % rb.capacity

        if rb.count &lt; rb.capacity </span><span class="cov9" title="69">{
                rb.count++
        }</span>
}

// GetEntries returns all entries in chronological order
func (rb *RingBuffer) GetEntries() []LogEntry <span class="cov6" title="13">{
        rb.mu.RLock()
        defer rb.mu.RUnlock()

        if rb.count == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov6" title="11">result := make([]LogEntry, rb.count)

        if rb.count &lt; rb.capacity </span><span class="cov5" title="10">{
                // Buffer not full yet, entries are from 0 to head-1
                copy(result, rb.entries[:rb.count])
        }</span> else<span class="cov1" title="1"> {
                // Buffer is full, entries wrap around
                // Copy from head to end
                firstPart := rb.capacity - rb.head
                copy(result, rb.entries[rb.head:])
                // Copy from beginning to head
                if rb.head &gt; 0 </span><span class="cov1" title="1">{
                        copy(result[firstPart:], rb.entries[:rb.head])
                }</span>
        }

        <span class="cov6" title="11">return result</span>
}

// GetEntriesFiltered returns entries matching the filter criteria
func (rb *RingBuffer) GetEntriesFiltered(level string, since time.Time, pattern string) []LogEntry <span class="cov3" title="3">{
        rb.mu.RLock()
        defer rb.mu.RUnlock()

        // Get all entries directly without calling GetEntries to avoid deadlock
        if rb.count == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">var allEntries []LogEntry
        if rb.count &lt; rb.capacity </span><span class="cov3" title="3">{
                // Buffer not full yet, entries are from 0 to head-1
                allEntries = make([]LogEntry, rb.count)
                copy(allEntries, rb.entries[:rb.count])
        }</span> else<span class="cov0" title="0"> {
                // Buffer is full, entries wrap around
                allEntries = make([]LogEntry, rb.count)
                // Copy from head to end
                firstPart := rb.capacity - rb.head
                copy(allEntries, rb.entries[rb.head:])
                // Copy from beginning to head
                if rb.head &gt; 0 </span><span class="cov0" title="0">{
                        copy(allEntries[firstPart:], rb.entries[:rb.head])
                }</span>
        }

        <span class="cov3" title="3">if len(allEntries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Filter entries
        <span class="cov3" title="3">var filtered []LogEntry
        for _, entry := range allEntries </span><span class="cov5" title="10">{
                // Filter by time
                if !since.IsZero() &amp;&amp; entry.Timestamp.Before(since) </span><span class="cov1" title="1">{
                        continue</span>
                }

                // Filter by level
                <span class="cov5" title="9">if level != "" &amp;&amp; !matchesLogLevel(entry.Level, level) </span><span class="cov2" title="2">{
                        continue</span>
                }

                // Filter by pattern (simple substring match)
                <span class="cov5" title="7">if pattern != "" &amp;&amp; !containsPattern(entry, pattern) </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="6">filtered = append(filtered, entry)</span>
        }

        <span class="cov3" title="3">return filtered</span>
}

// matchesLogLevel checks if the entry level matches or is more severe than the filter level
func matchesLogLevel(entryLevel, filterLevel string) bool <span class="cov3" title="4">{
        levels := map[string]int{
                "trace": 0,
                "debug": 1,
                "info":  2,
                "warn":  3,
                "error": 4,
                "fatal": 5,
                "panic": 6,
        }

        entryPriority, ok1 := levels[entryLevel]
        filterPriority, ok2 := levels[filterLevel]

        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return entryLevel == filterLevel
        }</span>

        <span class="cov3" title="4">return entryPriority &gt;= filterPriority</span>
}

// containsPattern checks if the log entry contains the pattern
func containsPattern(entry LogEntry, pattern string) bool <span class="cov3" title="3">{
        // Check message
        if containsIgnoreCase(entry.Message, pattern) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check fields
        <span class="cov3" title="3">for _, value := range entry.Fields </span><span class="cov3" title="3">{
                if str, ok := value.(string); ok &amp;&amp; containsIgnoreCase(str, pattern) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }

        <span class="cov1" title="1">return false</span>
}

// Clear removes all entries from the buffer
func (rb *RingBuffer) Clear() <span class="cov1" title="1">{
        rb.mu.Lock()
        defer rb.mu.Unlock()

        rb.head = 0
        rb.count = 0
}</span>

// Size returns the current number of entries in the buffer
func (rb *RingBuffer) Size() int <span class="cov3" title="3">{
        rb.mu.RLock()
        defer rb.mu.RUnlock()
        return rb.count
}</span>

// containsIgnoreCase performs case-insensitive substring search
func containsIgnoreCase(s, substr string) bool <span class="cov4" title="6">{
        return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

// SandboxExecutor provides advanced sandboxed execution capabilities
type SandboxExecutor struct {
        workspace        *WorkspaceManager
        logger           zerolog.Logger
        metricsCollector *SandboxMetricsCollector
        securityPolicy   *SecurityPolicyEngine
        resourceMonitor  *ResourceMonitor
}

// SandboxMetricsCollector tracks execution metrics
type SandboxMetricsCollector struct {
        mutex   sync.RWMutex
        metrics map[string]*ExecutionMetrics
        history []ExecutionRecord
}

// SecurityPolicyEngine enforces security policies
type SecurityPolicyEngine struct {
        policies      map[string]SecurityPolicy
        defaultPolicy SecurityPolicy
        auditLog      []SecurityAuditEntry
        mutex         sync.RWMutex
}

// ResourceMonitor tracks resource usage
type ResourceMonitor struct {
        limits         ResourceLimits
        usage          map[string]*ResourceUsage
        alertThreshold float64
        mutex          sync.RWMutex
}

// ExecutionRecord represents a single execution history entry
type ExecutionRecord struct {
        ID            string        `json:"id"`
        SessionID     string        `json:"session_id"`
        Command       []string      `json:"command"`
        StartTime     time.Time     `json:"start_time"`
        EndTime       time.Time     `json:"end_time"`
        ExitCode      int           `json:"exit_code"`
        ResourceUsage ResourceUsage `json:"resource_usage"`
        SecurityFlags []string      `json:"security_flags"`
}

// ResourceUsage tracks resource consumption
type ResourceUsage struct {
        CPUTime        time.Duration `json:"cpu_time"`
        MemoryPeak     int64         `json:"memory_peak"`
        NetworkIO      int64         `json:"network_io"`
        DiskIO         int64         `json:"disk_io"`
        ContainerCount int           `json:"container_count"`
}

// SecurityAuditEntry represents a security event
type SecurityAuditEntry struct {
        Timestamp   time.Time `json:"timestamp"`
        SessionID   string    `json:"session_id"`
        EventType   string    `json:"event_type"`
        Severity    string    `json:"severity"`
        Description string    `json:"description"`
        Action      string    `json:"action"`
}

// AdvancedSandboxOptions extends basic sandbox options
type AdvancedSandboxOptions struct {
        SandboxOptions
        EnableMetrics    bool              `json:"enable_metrics"`
        EnableAudit      bool              `json:"enable_audit"`
        CustomSeccomp    string            `json:"custom_seccomp"`
        AppArmorProfile  string            `json:"apparmor_profile"`
        SELinuxContext   string            `json:"selinux_context"`
        Capabilities     []string          `json:"capabilities"`
        DNSServers       []string          `json:"dns_servers"`
        ExtraHosts       map[string]string `json:"extra_hosts"`
        WorkingDirectory string            `json:"working_directory"`
        User             string            `json:"user"`
        Group            string            `json:"group"`
}

// NewSandboxExecutor creates a new sandbox executor
func NewSandboxExecutor(workspace *WorkspaceManager, logger zerolog.Logger) *SandboxExecutor <span class="cov2" title="3">{
        return &amp;SandboxExecutor{
                workspace:        workspace,
                logger:           logger.With().Str("component", "sandbox_executor").Logger(),
                metricsCollector: NewSandboxMetricsCollector(),
                securityPolicy:   NewSecurityPolicyEngine(),
                resourceMonitor:  NewResourceMonitor(),
        }
}</span>

// NewSandboxMetricsCollector creates a new metrics collector
func NewSandboxMetricsCollector() *SandboxMetricsCollector <span class="cov2" title="4">{
        return &amp;SandboxMetricsCollector{
                metrics: make(map[string]*ExecutionMetrics),
                history: make([]ExecutionRecord, 0),
        }
}</span>

// NewSecurityPolicyEngine creates a new security policy engine
func NewSecurityPolicyEngine() *SecurityPolicyEngine <span class="cov3" title="6">{
        return &amp;SecurityPolicyEngine{
                policies: make(map[string]SecurityPolicy),
                defaultPolicy: SecurityPolicy{
                        AllowNetworking:   false,
                        AllowFileSystem:   true,
                        RequireNonRoot:    true,
                        TrustedRegistries: []string{"docker.io", "gcr.io", "quay.io"},
                        ResourceLimits: ResourceLimits{
                                Memory:    512 * 1024 * 1024,  // 512MB
                                CPUQuota:  50000,              // 50% CPU
                                DiskSpace: 1024 * 1024 * 1024, // 1GB
                        },
                },
                auditLog: make([]SecurityAuditEntry, 0),
        }
}</span>

// NewResourceMonitor creates a new resource monitor
func NewResourceMonitor() *ResourceMonitor <span class="cov2" title="4">{
        return &amp;ResourceMonitor{
                limits: ResourceLimits{
                        Memory:    1024 * 1024 * 1024,     // 1GB default
                        CPUQuota:  100000,                 // 100% CPU default
                        DiskSpace: 5 * 1024 * 1024 * 1024, // 5GB default
                },
                usage:          make(map[string]*ResourceUsage),
                alertThreshold: 0.8, // Alert at 80% usage
        }
}</span>

// ExecuteAdvanced performs sandboxed execution with advanced features
func (se *SandboxExecutor) ExecuteAdvanced(ctx context.Context, sessionID string, cmd []string, options AdvancedSandboxOptions) (*ExecResult, error) <span class="cov3" title="5">{
        // Validate security policy
        if err := se.validateAdvancedSecurity(sessionID, options); err != nil </span><span class="cov2" title="3">{
                se.auditSecurityEvent(sessionID, "EXECUTION_BLOCKED", "HIGH", err.Error(), "DENY")
                return nil, fmt.Errorf("security validation failed: %w", err)
        }</span>

        // Check resource availability
        <span class="cov1" title="2">if err := se.checkResourceAvailability(sessionID, options); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient resources: %w", err)
        }</span>

        // Record execution start
        <span class="cov1" title="2">record := ExecutionRecord{
                ID:        fmt.Sprintf("%s-%d", sessionID, time.Now().UnixNano()),
                SessionID: sessionID,
                Command:   cmd,
                StartTime: time.Now(),
        }

        // Execute with monitoring
        result, err := se.executeWithMonitoring(ctx, sessionID, cmd, options, &amp;record)

        // Record execution end
        record.EndTime = time.Now()
        if result != nil </span><span class="cov1" title="2">{
                record.ExitCode = result.ExitCode
        }</span>

        // Store execution record
        <span class="cov1" title="2">se.metricsCollector.addRecord(record)

        // Audit successful execution
        if err == nil </span><span class="cov1" title="2">{
                se.auditSecurityEvent(sessionID, "EXECUTION_COMPLETED", "INFO",
                        fmt.Sprintf("Command executed: %v", cmd), "ALLOW")
        }</span>

        <span class="cov1" title="2">return result, err</span>
}

// executeWithMonitoring executes commands with resource monitoring
func (se *SandboxExecutor) executeWithMonitoring(ctx context.Context, sessionID string, cmd []string, options AdvancedSandboxOptions, record *ExecutionRecord) (*ExecResult, error) <span class="cov1" title="2">{
        // Build secure Docker command
        dockerArgs, err := se.buildSecureDockerCommand(sessionID, cmd, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Start resource monitoring
        <span class="cov1" title="2">monitorCtx, cancelMonitor := context.WithCancel(ctx)
        defer cancelMonitor()

        resourceChan := make(chan ResourceUsage, 1)
        go se.monitorResources(monitorCtx, sessionID, resourceChan)

        // Execute command
        result, err := se.workspace.executeDockerCommand(ctx, dockerArgs, sessionID)

        // Collect final resource usage
        select </span>{
        case usage := &lt;-resourceChan:<span class="cov0" title="0">
                record.ResourceUsage = usage
                se.resourceMonitor.updateUsage(sessionID, usage)</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="2">
                // Timeout collecting metrics
                se.logger.Warn().Str("session_id", sessionID).Msg("Timeout collecting resource metrics")</span>
        }

        // Update metrics
        <span class="cov1" title="2">if result != nil &amp;&amp; options.EnableMetrics </span><span class="cov1" title="2">{
                se.metricsCollector.updateMetrics(sessionID, result)
        }</span>

        <span class="cov1" title="2">return result, err</span>
}

// buildSecureDockerCommand builds a secure Docker command with advanced options
func (se *SandboxExecutor) buildSecureDockerCommand(sessionID string, cmd []string, options AdvancedSandboxOptions) ([]string, error) <span class="cov3" title="7">{
        args := []string{"run", "--rm"}

        // Basic security settings
        args = append(args, "--security-opt", "no-new-privileges:true")

        // Custom seccomp profile
        if options.CustomSeccomp != "" </span><span class="cov1" title="1">{
                args = append(args, "--security-opt", fmt.Sprintf("seccomp=%s", options.CustomSeccomp))
        }</span>

        // AppArmor profile
        <span class="cov3" title="7">if options.AppArmorProfile != "" </span><span class="cov1" title="1">{
                args = append(args, "--security-opt", fmt.Sprintf("apparmor=%s", options.AppArmorProfile))
        }</span>

        // SELinux context
        <span class="cov3" title="7">if options.SELinuxContext != "" </span><span class="cov1" title="1">{
                args = append(args, "--security-opt", fmt.Sprintf("label=%s", options.SELinuxContext))
        }</span>

        // Capabilities
        <span class="cov3" title="7">if len(options.Capabilities) &gt; 0 </span><span class="cov1" title="1">{
                for _, cap := range options.Capabilities </span><span class="cov1" title="1">{
                        args = append(args, "--cap-add", cap)
                }</span>
        } else<span class="cov3" title="6"> {
                // Drop all capabilities by default
                args = append(args, "--cap-drop", "ALL")
        }</span>

        // Resource limits
        <span class="cov3" title="7">if options.MemoryLimit &gt; 0 </span><span class="cov1" title="2">{
                args = append(args, fmt.Sprintf("--memory=%d", options.MemoryLimit))
                args = append(args, fmt.Sprintf("--memory-swap=%d", options.MemoryLimit)) // Prevent swap
        }</span>

        <span class="cov3" title="7">if options.CPUQuota &gt; 0 </span><span class="cov1" title="2">{
                cpuLimit := float64(options.CPUQuota) / 100000.0
                args = append(args, fmt.Sprintf("--cpus=%.2f", cpuLimit))
        }</span>

        // User and group
        <span class="cov3" title="7">if options.User != "" &amp;&amp; options.Group != "" </span><span class="cov1" title="1">{
                args = append(args, "--user", fmt.Sprintf("%s:%s", options.User, options.Group))
        }</span> else<span class="cov3" title="6"> if options.SecurityPolicy.RequireNonRoot </span><span class="cov2" title="3">{
                args = append(args, "--user", "1000:1000")
        }</span>

        // Network settings
        <span class="cov3" title="7">if !options.NetworkAccess || !options.SecurityPolicy.AllowNetworking </span><span class="cov3" title="6">{
                args = append(args, "--network=none")
        }</span> else<span class="cov1" title="1"> {
                // Custom DNS if network is enabled
                for _, dns := range options.DNSServers </span><span class="cov1" title="2">{
                        args = append(args, "--dns", dns)
                }</span>
        }

        // Extra hosts
        <span class="cov3" title="7">for hostname, ip := range options.ExtraHosts </span><span class="cov1" title="2">{
                args = append(args, "--add-host", fmt.Sprintf("%s:%s", hostname, ip))
        }</span>

        // Read-only root filesystem
        <span class="cov3" title="7">if options.ReadOnly </span><span class="cov1" title="1">{
                args = append(args, "--read-only")
        }</span>

        // Working directory
        <span class="cov3" title="7">if options.WorkingDirectory != "" </span><span class="cov0" title="0">{
                args = append(args, "-w", options.WorkingDirectory)
        }</span> else<span class="cov3" title="7"> {
                args = append(args, "-w", "/workspace")
        }</span>

        // Environment variables
        <span class="cov3" title="7">env := se.workspace.sanitizeEnvironment(options.Environment)
        for _, envVar := range env </span><span class="cov0" title="0">{
                args = append(args, "-e", envVar)
        }</span>

        // Mounts
        <span class="cov3" title="7">workspaceDir := se.workspace.GetFilePath(sessionID, "")
        args = append(args, "-v", fmt.Sprintf("%s:/workspace:ro", workspaceDir))

        // Temporary directory
        args = append(args, "--tmpfs", "/tmp:size=100m,noexec,nosuid,nodev")

        // Image and command
        args = append(args, options.BaseImage)
        args = append(args, cmd...)

        return args, nil</span>
}

// validateAdvancedSecurity performs advanced security validation
func (se *SandboxExecutor) validateAdvancedSecurity(sessionID string, options AdvancedSandboxOptions) error <span class="cov3" title="5">{
        // Get applicable security policy
        policy := se.securityPolicy.getPolicy(sessionID)

        // Validate base security policy
        if err := se.workspace.ValidateSecurityPolicy(policy); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate image is from trusted registry
        <span class="cov3" title="5">if !se.isImageTrusted(options.BaseImage, policy.TrustedRegistries) </span><span class="cov1" title="1">{
                return fmt.Errorf("image %s not from trusted registry", options.BaseImage)
        }</span>

        // Validate capabilities
        <span class="cov2" title="4">if len(options.Capabilities) &gt; 0 &amp;&amp; policy.RequireNonRoot </span><span class="cov1" title="1">{
                dangerousCaps := []string{"SYS_ADMIN", "NET_ADMIN", "SYS_PTRACE"}
                for _, cap := range options.Capabilities </span><span class="cov1" title="1">{
                        for _, dangerous := range dangerousCaps </span><span class="cov1" title="1">{
                                if strings.EqualFold(cap, dangerous) </span><span class="cov1" title="1">{
                                        return fmt.Errorf("dangerous capability requested: %s", cap)
                                }</span>
                        }
                }
        }

        // Validate resource limits
        <span class="cov2" title="3">if options.MemoryLimit &gt; policy.ResourceLimits.Memory </span><span class="cov1" title="1">{
                return fmt.Errorf("requested memory %d exceeds policy limit %d",
                        options.MemoryLimit, policy.ResourceLimits.Memory)
        }</span>

        <span class="cov1" title="2">return nil</span>
}

// checkResourceAvailability checks if resources are available
func (se *SandboxExecutor) checkResourceAvailability(sessionID string, options AdvancedSandboxOptions) error <span class="cov1" title="2">{
        se.resourceMonitor.mutex.RLock()
        defer se.resourceMonitor.mutex.RUnlock()

        // Calculate total current usage
        var totalMemory int64
        var totalCPU int64
        for _, usage := range se.resourceMonitor.usage </span><span class="cov0" title="0">{
                totalMemory += usage.MemoryPeak
                totalCPU += int64(usage.CPUTime)
        }</span>

        // Check if adding this would exceed limits
        <span class="cov1" title="2">if totalMemory+options.MemoryLimit &gt; se.resourceMonitor.limits.Memory </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient memory: %d available, %d requested",
                        se.resourceMonitor.limits.Memory-totalMemory, options.MemoryLimit)
        }</span>

        <span class="cov1" title="2">return nil</span>
}

// monitorResources monitors resource usage during execution
func (se *SandboxExecutor) monitorResources(ctx context.Context, sessionID string, resourceChan chan&lt;- ResourceUsage) <span class="cov1" title="2">{
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        usage := ResourceUsage{
                ContainerCount: 1,
        }

        startTime := time.Now()

        for </span><span class="cov5" title="24">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="2">
                        usage.CPUTime = time.Since(startTime)
                        resourceChan &lt;- usage
                        return</span>
                case &lt;-ticker.C:<span class="cov4" title="22">
                        // In production, would query actual container stats
                        // For now, simulate resource tracking
                        usage.CPUTime = time.Since(startTime)
                        usage.MemoryPeak = int64(time.Since(startTime).Seconds() * 1024 * 1024) // Simulate memory usage

                        // Check for resource alerts
                        se.checkResourceAlerts(sessionID, usage)</span>
                }
        }
}

// checkResourceAlerts checks if resource usage exceeds thresholds
func (se *SandboxExecutor) checkResourceAlerts(sessionID string, usage ResourceUsage) <span class="cov4" title="22">{
        se.resourceMonitor.mutex.RLock()
        limits := se.resourceMonitor.limits
        threshold := se.resourceMonitor.alertThreshold
        se.resourceMonitor.mutex.RUnlock()

        // Check memory threshold
        if float64(usage.MemoryPeak) &gt; float64(limits.Memory)*threshold </span><span class="cov0" title="0">{
                se.logger.Warn().
                        Str("session_id", sessionID).
                        Int64("memory_usage", usage.MemoryPeak).
                        Int64("memory_limit", limits.Memory).
                        Msg("Memory usage exceeds alert threshold")
        }</span>
}

// auditSecurityEvent records a security event
func (se *SandboxExecutor) auditSecurityEvent(sessionID, eventType, severity, description, action string) <span class="cov3" title="5">{
        entry := SecurityAuditEntry{
                Timestamp:   time.Now(),
                SessionID:   sessionID,
                EventType:   eventType,
                Severity:    severity,
                Description: description,
                Action:      action,
        }

        se.securityPolicy.mutex.Lock()
        se.securityPolicy.auditLog = append(se.securityPolicy.auditLog, entry)
        se.securityPolicy.mutex.Unlock()

        se.logger.Info().
                Str("session_id", sessionID).
                Str("event_type", eventType).
                Str("severity", severity).
                Str("action", action).
                Msg("Security event audited")
}</span>

// isImageTrusted checks if an image is from a trusted registry
func (se *SandboxExecutor) isImageTrusted(image string, trustedRegistries []string) bool <span class="cov4" title="12">{
        for _, registry := range trustedRegistries </span><span class="cov5" title="23">{
                if strings.HasPrefix(image, registry+"/") || image == registry </span><span class="cov2" title="3">{
                        return true
                }</span>
                // Check for library images (e.g., "alpine" -&gt; "docker.io/library/alpine")
                <span class="cov4" title="20">if !strings.Contains(image, "/") &amp;&amp; registry == "docker.io" </span><span class="cov3" title="5">{
                        return true
                }</span>
        }
        <span class="cov2" title="4">return false</span>
}

// GetExecutionHistory returns execution history
func (se *SandboxExecutor) GetExecutionHistory(sessionID string) []ExecutionRecord <span class="cov1" title="1">{
        se.metricsCollector.mutex.RLock()
        defer se.metricsCollector.mutex.RUnlock()

        var history []ExecutionRecord
        for _, record := range se.metricsCollector.history </span><span class="cov1" title="2">{
                if record.SessionID == sessionID </span><span class="cov1" title="2">{
                        history = append(history, record)
                }</span>
        }
        <span class="cov1" title="1">return history</span>
}

// GetSecurityAuditLog returns security audit entries
func (se *SandboxExecutor) GetSecurityAuditLog(sessionID string) []SecurityAuditEntry <span class="cov2" title="3">{
        se.securityPolicy.mutex.RLock()
        defer se.securityPolicy.mutex.RUnlock()

        var entries []SecurityAuditEntry
        for _, entry := range se.securityPolicy.auditLog </span><span class="cov4" title="12">{
                if entry.SessionID == sessionID || sessionID == "" </span><span class="cov4" title="12">{
                        entries = append(entries, entry)
                }</span>
        }
        <span class="cov2" title="3">return entries</span>
}

// GetResourceUsage returns current resource usage
func (se *SandboxExecutor) GetResourceUsage() map[string]*ResourceUsage <span class="cov1" title="2">{
        se.resourceMonitor.mutex.RLock()
        defer se.resourceMonitor.mutex.RUnlock()

        usage := make(map[string]*ResourceUsage)
        for k, v := range se.resourceMonitor.usage </span><span class="cov0" title="0">{
                usage[k] = v
        }</span>
        <span class="cov1" title="2">return usage</span>
}

// Helper methods for internal components

func (smc *SandboxMetricsCollector) updateMetrics(sessionID string, result *ExecResult) <span class="cov1" title="2">{
        smc.mutex.Lock()
        defer smc.mutex.Unlock()

        if smc.metrics[sessionID] == nil </span><span class="cov1" title="1">{
                smc.metrics[sessionID] = &amp;ExecutionMetrics{}
        }</span>

        // Update metrics based on result
        <span class="cov1" title="2">if result.ExitCode == 0 </span>{<span class="cov1" title="2">
                // Success metrics would be updated here
                // For now, just track that we have metrics for this session
        }</span>
}

func (smc *SandboxMetricsCollector) addRecord(record ExecutionRecord) <span class="cov10" title="1112">{
        smc.mutex.Lock()
        defer smc.mutex.Unlock()

        smc.history = append(smc.history, record)

        // Keep only last 1000 records
        if len(smc.history) &gt; 1000 </span><span class="cov7" title="110">{
                smc.history = smc.history[len(smc.history)-1000:]
        }</span>
}

func (spe *SecurityPolicyEngine) getPolicy(sessionID string) SecurityPolicy <span class="cov3" title="7">{
        spe.mutex.RLock()
        defer spe.mutex.RUnlock()

        if policy, exists := spe.policies[sessionID]; exists </span><span class="cov1" title="1">{
                return policy
        }</span>
        <span class="cov3" title="6">return spe.defaultPolicy</span>
}

func (rm *ResourceMonitor) updateUsage(sessionID string, usage ResourceUsage) <span class="cov1" title="1">{
        rm.mutex.Lock()
        defer rm.mutex.Unlock()

        if rm.usage[sessionID] == nil </span><span class="cov1" title="1">{
                rm.usage[sessionID] = &amp;ResourceUsage{}
        }</span>

        // Update with latest usage
        <span class="cov1" title="1">rm.usage[sessionID] = &amp;usage</span>
}

// ExportMetrics exports execution metrics in JSON format
func (se *SandboxExecutor) ExportMetrics(ctx context.Context) ([]byte, error) <span class="cov1" title="1">{
        se.metricsCollector.mutex.RLock()
        defer se.metricsCollector.mutex.RUnlock()

        data := struct {
                Timestamp time.Time                    `json:"timestamp"`
                Metrics   map[string]*ExecutionMetrics `json:"metrics"`
                History   []ExecutionRecord            `json:"history"`
                Resources map[string]*ResourceUsage    `json:"resources"`
        }{
                Timestamp: time.Now(),
                Metrics:   se.metricsCollector.metrics,
                History:   se.metricsCollector.history,
                Resources: se.GetResourceUsage(),
        }

        return json.MarshalIndent(data, "", "  ")
}</span>
</pre>

		<pre class="file" id="file5" style="display: none">package utils

import (
        "encoding/json"

        "github.com/invopop/jsonschema"
)

// RemoveCopilotIncompatibleFromSchema converts invopop jsonschema.Schema to map and removes incompatible fields
func RemoveCopilotIncompatibleFromSchema(schema *jsonschema.Schema) map[string]interface{} <span class="cov0" title="0">{
        // Marshal and unmarshal to get map format
        schemaBytes, err := json.Marshal(schema)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">var schemaMap map[string]interface{}
        if err := json.Unmarshal(schemaBytes, &amp;schemaMap); err != nil </span><span class="cov0" title="0">{
                return make(map[string]interface{})
        }</span>

        // Apply compatibility fixes
        <span class="cov0" title="0">RemoveCopilotIncompatible(schemaMap)

        return schemaMap</span>
}

// AddMissingArrayItems recursively adds missing "items" fields for arrays
// that don't have them, which is required by MCP validation.
// It safely handles nested objects, arrays, and various JSON schema structures.
func AddMissingArrayItems(schema map[string]interface{}) <span class="cov0" title="0">{
        // Recursively process all map values
        for _, value := range schema </span><span class="cov0" title="0">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Check if this is an array type definition without items
                        if v["type"] == "array" </span><span class="cov0" title="0">{
                                if _, hasItems := v["items"]; !hasItems </span><span class="cov0" title="0">{
                                        // Add default string items for array types
                                        // This is safe for most MCP array use cases
                                        v["items"] = map[string]interface{}{"type": "string"}
                                }</span>
                        }
                        // Recursively process nested objects (like "properties", "definitions", etc.)
                        <span class="cov0" title="0">AddMissingArrayItems(v)</span>

                case []interface{}:<span class="cov0" title="0">
                        // Handle arrays of schema objects (like in "oneOf", "anyOf", etc.)
                        for _, elem := range v </span><span class="cov0" title="0">{
                                if m, ok := elem.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        AddMissingArrayItems(m)
                                }</span>
                        }
                }
        }
}

// RemoveCopilotIncompatible recursively strips meta-schema fields that
// Copilot's AJV-Draft-7 validator cannot handle.
func RemoveCopilotIncompatible(node map[string]any) <span class="cov0" title="0">{
        delete(node, "$schema")        // drop any draft URI
        delete(node, "$id")            // AJV rejects nested id
        delete(node, "$dynamicRef")    // draft-2020 keyword
        delete(node, "$dynamicAnchor") // draft-2020 keyword

        // draft-2020 unevaluatedProperties is also unsupported
        delete(node, "unevaluatedProperties")

        for _, v := range node </span><span class="cov0" title="0">{ // walk children
                switch child := v.(type) </span>{
                case map[string]any:<span class="cov0" title="0">
                        RemoveCopilotIncompatible(child)</span>
                case []any:<span class="cov0" title="0">
                        for _, elem := range child </span><span class="cov0" title="0">{
                                if m, ok := elem.(map[string]any); ok </span><span class="cov0" title="0">{
                                        RemoveCopilotIncompatible(m)
                                }</span>
                        }
                }
        }
}
</pre>

		<pre class="file" id="file6" style="display: none">package utils

import (
        "fmt"
        "regexp"
        "strings"

        "github.com/Azure/container-kit/pkg/mcp/internal/types"
)

// SecretScanner detects sensitive values in environment variables
type SecretScanner struct {
        // Patterns that indicate sensitive data
        sensitivePatterns []*regexp.Regexp

        // Common secret management solutions
        secretManagers []SecretManager
}

// SecretManager represents a secret management solution
type SecretManager struct {
        Name        string
        Description string
        Example     string
}

// SensitiveEnvVar represents a detected sensitive environment variable
type SensitiveEnvVar struct {
        Name          string
        Value         string
        Pattern       string
        Redacted      string
        SuggestedName string // Suggested secret name
}

// SecretExternalizationPlan represents a plan to externalize secrets
type SecretExternalizationPlan struct {
        DetectedSecrets  []SensitiveEnvVar
        PreferredManager string
        SecretReferences map[string]SecretReference
        ConfigMapEntries map[string]string
}

// SecretReference represents a reference to an external secret
type SecretReference struct {
        SecretName string
        SecretKey  string
        EnvVarName string
}

// NewSecretScanner creates a new secret scanner
func NewSecretScanner() *SecretScanner <span class="cov3" title="7">{
        return &amp;SecretScanner{
                sensitivePatterns: []*regexp.Regexp{
                        // Password patterns
                        regexp.MustCompile(`(?i)^.*_?PASSWORD(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?PASSWD(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?PWD(_.*)?$`),

                        // Token patterns
                        regexp.MustCompile(`(?i)^.*_?TOKEN(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?API_?KEY(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?SECRET(_.*)?$`),

                        // Authentication patterns
                        regexp.MustCompile(`(?i)^.*_?AUTH(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?CREDENTIAL(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?ACCESS_?KEY(_.*)?$`),

                        // Database patterns
                        regexp.MustCompile(`(?i)^DB_.*$`),
                        regexp.MustCompile(`(?i)^DATABASE_.*$`),
                        regexp.MustCompile(`(?i)^.*_?CONNECTION_?STRING(_.*)?$`),

                        // Certificate patterns
                        regexp.MustCompile(`(?i)^.*_?CERT(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?CERTIFICATE(_.*)?$`),
                        regexp.MustCompile(`(?i)^.*_?PRIVATE_?KEY(_.*)?$`),

                        // Cloud provider patterns
                        regexp.MustCompile(`(?i)^AWS_.*$`),
                        regexp.MustCompile(`(?i)^AZURE_.*$`),
                        regexp.MustCompile(`(?i)^GCP_.*$`),
                        regexp.MustCompile(`(?i)^GOOGLE_.*$`),
                },
                secretManagers: []SecretManager{
                        {
                                Name:        "kubernetes-secrets",
                                Description: "Native Kubernetes Secrets (base64 encoded)",
                                Example:     "kubectl create secret generic app-secrets --from-literal=DB_PASSWORD=xxx",
                        },
                        {
                                Name:        "sealed-secrets",
                                Description: "Bitnami Sealed Secrets (encrypted secrets that can be stored in Git)",
                                Example:     "kubeseal --format=yaml &lt; secret.yaml &gt; sealed-secret.yaml",
                        },
                        {
                                Name:        types.ExternalSecretsLabel,
                                Description: "External Secrets Operator (sync secrets from external systems)",
                                Example:     "Syncs from AWS Secrets Manager, HashiCorp Vault, Azure Key Vault, etc.",
                        },
                        {
                                Name:        "vault",
                                Description: "HashiCorp Vault with Kubernetes auth",
                                Example:     "vault kv put secret/app/config password=xxx",
                        },
                },
        }
}</span>

// ScanEnvironment scans environment variables for sensitive data
func (ss *SecretScanner) ScanEnvironment(envVars map[string]string) []SensitiveEnvVar <span class="cov5" title="16">{
        var sensitiveVars []SensitiveEnvVar

        for name, value := range envVars </span><span class="cov6" title="50">{
                for _, pattern := range ss.sensitivePatterns </span><span class="cov10" title="452">{
                        if pattern.MatchString(name) </span><span class="cov6" title="37">{
                                sensitiveVars = append(sensitiveVars, SensitiveEnvVar{
                                        Name:          name,
                                        Value:         value,
                                        Pattern:       pattern.String(),
                                        Redacted:      ss.redactValue(value),
                                        SuggestedName: ss.suggestSecretName(name),
                                })
                                break</span> // Only match once per variable
                        }
                }
        }

        <span class="cov5" title="16">return sensitiveVars</span>
}

// ScanContent scans text content for sensitive patterns
func (ss *SecretScanner) ScanContent(content string) []SensitiveEnvVar <span class="cov0" title="0">{
        var sensitiveVars []SensitiveEnvVar

        // Simple pattern matching for key=value or key: value patterns
        lines := strings.Split(content, "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Skip comments and empty lines
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Look for key=value or key: value patterns
                <span class="cov0" title="0">var key, value string

                // Environment variable style (KEY=value)
                if strings.Contains(line, "=") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key = strings.TrimSpace(parts[0])
                                value = strings.TrimSpace(parts[1])
                        }</span>
                }

                // YAML/JSON style (key: value)
                <span class="cov0" title="0">if strings.Contains(line, ":") &amp;&amp; !strings.Contains(line, "=") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, ":", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key = strings.TrimSpace(parts[0])
                                value = strings.TrimSpace(parts[1])

                                // Remove quotes from YAML/JSON values
                                value = strings.Trim(value, `"'`)
                        }</span>
                }

                <span class="cov0" title="0">if key != "" &amp;&amp; value != "" </span><span class="cov0" title="0">{
                        // Check if key matches sensitive patterns
                        for _, pattern := range ss.sensitivePatterns </span><span class="cov0" title="0">{
                                if pattern.MatchString(key) </span><span class="cov0" title="0">{
                                        sensitiveVars = append(sensitiveVars, SensitiveEnvVar{
                                                Name:          key,
                                                Value:         value,
                                                Pattern:       pattern.String(),
                                                Redacted:      ss.redactValue(value),
                                                SuggestedName: ss.suggestSecretName(key),
                                        })
                                        break</span> // Only match once per key
                                }
                        }
                }
        }

        <span class="cov0" title="0">return sensitiveVars</span>
}

// CreateExternalizationPlan creates a plan to externalize secrets
func (ss *SecretScanner) CreateExternalizationPlan(envVars map[string]string, preferredManager string) *SecretExternalizationPlan <span class="cov1" title="1">{
        plan := &amp;SecretExternalizationPlan{
                DetectedSecrets:  ss.ScanEnvironment(envVars),
                PreferredManager: preferredManager,
                SecretReferences: make(map[string]SecretReference),
                ConfigMapEntries: make(map[string]string),
        }

        // Separate secrets from non-secrets
        for name, value := range envVars </span><span class="cov3" title="6">{
                isSecret := false
                for _, secret := range plan.DetectedSecrets </span><span class="cov4" title="15">{
                        if secret.Name == name </span><span class="cov2" title="3">{
                                isSecret = true
                                // Create secret reference
                                plan.SecretReferences[name] = SecretReference{
                                        SecretName: secret.SuggestedName,
                                        SecretKey:  strings.ToLower(name),
                                        EnvVarName: name,
                                }
                                break</span>
                        }
                }

                <span class="cov3" title="6">if !isSecret </span><span class="cov2" title="3">{
                        // Non-sensitive values go to ConfigMap
                        plan.ConfigMapEntries[name] = value
                }</span>
        }

        <span class="cov1" title="1">return plan</span>
}

// GetSecretManagers returns available secret management solutions
func (ss *SecretScanner) GetSecretManagers() []SecretManager <span class="cov0" title="0">{
        return ss.secretManagers
}</span>

// GetRecommendedManager returns the recommended secret manager based on context
func (ss *SecretScanner) GetRecommendedManager(hasGitOps bool, cloudProvider string) string <span class="cov3" title="5">{
        if hasGitOps </span><span class="cov1" title="1">{
                return "sealed-secrets" // Safe for Git storage
        }</span>

        <span class="cov3" title="4">switch cloudProvider </span>{
        case "aws":<span class="cov1" title="1">
                return types.ExternalSecretsLabel</span> // Can sync from AWS Secrets Manager
        case "azure":<span class="cov1" title="1">
                return types.ExternalSecretsLabel</span> // Can sync from Azure Key Vault
        case "gcp":<span class="cov1" title="1">
                return types.ExternalSecretsLabel</span> // Can sync from GCP Secret Manager
        default:<span class="cov1" title="1">
                return "kubernetes-secrets"</span> // Default to native secrets
        }
}

// GenerateSecretManifest generates a Kubernetes Secret manifest
func (ss *SecretScanner) GenerateSecretManifest(secretName string, secrets map[string]string, namespace string) string <span class="cov1" title="1">{
        var sb strings.Builder

        sb.WriteString("apiVersion: v1\n")
        sb.WriteString("kind: Secret\n")
        sb.WriteString("metadata:\n")
        sb.WriteString(fmt.Sprintf("  name: %s\n", secretName))
        sb.WriteString(fmt.Sprintf("  namespace: %s\n", namespace))
        sb.WriteString("type: Opaque\n")
        sb.WriteString("stringData:\n")

        for key := range secrets </span><span class="cov2" title="2">{
                // Generate deterministic dummy value for testing consistency
                dummyValue := ss.generateDummySecretValue(key)
                sb.WriteString(fmt.Sprintf("  %s: %s\n", strings.ToLower(key), dummyValue))
        }</span>

        <span class="cov1" title="1">return sb.String()</span>
}

// GenerateExternalSecretManifest generates an External Secrets manifest
func (ss *SecretScanner) GenerateExternalSecretManifest(secretName, namespace, secretStore string, mappings map[string]string) string <span class="cov1" title="1">{
        var sb strings.Builder

        sb.WriteString("apiVersion: external-secrets.io/v1beta1\n")
        sb.WriteString("kind: ExternalSecret\n")
        sb.WriteString("metadata:\n")
        sb.WriteString(fmt.Sprintf("  name: %s\n", secretName))
        sb.WriteString(fmt.Sprintf("  namespace: %s\n", namespace))
        sb.WriteString("spec:\n")
        sb.WriteString("  secretStoreRef:\n")
        sb.WriteString(fmt.Sprintf("    name: %s\n", secretStore))
        sb.WriteString("    kind: SecretStore\n")
        sb.WriteString("  target:\n")
        sb.WriteString(fmt.Sprintf("    name: %s\n", secretName))
        sb.WriteString("  data:\n")

        for k8sKey, externalKey := range mappings </span><span class="cov2" title="2">{
                sb.WriteString(fmt.Sprintf("  - secretKey: %s\n", k8sKey))
                sb.WriteString("    remoteRef:\n")
                sb.WriteString(fmt.Sprintf("      key: %s\n", externalKey))
        }</span>

        <span class="cov1" title="1">return sb.String()</span>
}

// Helper methods

func (ss *SecretScanner) redactValue(value string) string <span class="cov6" title="37">{
        if len(value) &lt;= 4 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov6" title="37">return value[:2] + "***" + value[len(value)-2:]</span>
}

func (ss *SecretScanner) suggestSecretName(envVarName string) string <span class="cov6" title="37">{
        // Convert to lowercase and replace underscores
        name := strings.ToLower(envVarName)
        name = strings.ReplaceAll(name, "_", "-")

        // Remove common suffixes
        suffixes := []string{"-password", "-token", "-key", "-secret", "-auth"}
        for _, suffix := range suffixes </span><span class="cov7" title="104">{
                if strings.HasSuffix(name, suffix) </span><span class="cov6" title="30">{
                        name = strings.TrimSuffix(name, suffix)
                        break</span>
                }
        }

        // Add app prefix and secrets suffix
        <span class="cov6" title="37">if !strings.Contains(name, "secret") </span><span class="cov6" title="35">{
                name = "app-" + name + "-secrets"
        }</span>

        <span class="cov6" title="37">return name</span>
}

// generateDummySecretValue creates deterministic dummy values for testing
func (ss *SecretScanner) generateDummySecretValue(key string) string <span class="cov2" title="2">{
        // Create deterministic dummy values based on key type
        lowerKey := strings.ToLower(key)

        // Return type-specific dummy values for predictable testing
        switch </span>{
        case strings.Contains(lowerKey, "password"):<span class="cov1" title="1">
                return "dummy-password-123"</span>
        case strings.Contains(lowerKey, "token"):<span class="cov1" title="1">
                return "dummy-token-456"</span>
        case strings.Contains(lowerKey, "key"):<span class="cov0" title="0">
                return "dummy-key-789"</span>
        case strings.Contains(lowerKey, "secret"):<span class="cov0" title="0">
                return "dummy-secret-abc"</span>
        case strings.Contains(lowerKey, "cert"):<span class="cov0" title="0">
                return "dummy-certificate-def"</span>
        case strings.Contains(lowerKey, "connection") || strings.Contains(lowerKey, "url"):<span class="cov0" title="0">
                return "dummy://user:pass@host:5432/db"</span>
        default:<span class="cov0" title="0">
                return "dummy-value-xyz"</span>
        }
}
</pre>

		<pre class="file" id="file7" style="display: none">package utils

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

// SecurityValidator provides comprehensive security validation for sandboxed execution
type SecurityValidator struct {
        logger       zerolog.Logger
        mutex        sync.RWMutex
        vulnDatabase map[string]VulnerabilityInfo
        policyEngine *SecurityPolicyEngine
        threatModel  *ThreatModel
}

// VulnerabilityInfo contains information about known vulnerabilities
type VulnerabilityInfo struct {
        CVE         string    `json:"cve"`
        Severity    string    `json:"severity"`
        Description string    `json:"description"`
        Component   string    `json:"component"`
        Version     string    `json:"version"`
        Patched     bool      `json:"patched"`
        DetectedAt  time.Time `json:"detected_at"`
}

// ThreatModel defines the threat assessment model
type ThreatModel struct {
        Threats    map[string]ThreatInfo   `json:"threats"`
        Controls   map[string]ControlInfo  `json:"controls"`
        RiskMatrix map[string][]RiskFactor `json:"risk_matrix"`
}

// ThreatInfo describes a specific threat
type ThreatInfo struct {
        ID          string   `json:"id"`
        Name        string   `json:"name"`
        Description string   `json:"description"`
        Impact      string   `json:"impact"`     // HIGH, MEDIUM, LOW
        Probability string   `json:"probability"` // HIGH, MEDIUM, LOW
        Category    string   `json:"category"`   // CONTAINER_ESCAPE, CODE_INJECTION, etc.
        Mitigations []string `json:"mitigations"`
}

// ControlInfo describes a security control
type ControlInfo struct {
        ID           string   `json:"id"`
        Name         string   `json:"name"`
        Description  string   `json:"description"`
        Type         string   `json:"type"`         // PREVENTIVE, DETECTIVE, CORRECTIVE
        Effectiveness string  `json:"effectiveness"` // HIGH, MEDIUM, LOW
        Threats      []string `json:"threats"`      // Threats this control mitigates
        Implemented  bool     `json:"implemented"`
}

// RiskFactor represents a risk calculation factor
type RiskFactor struct {
        Threat     string  `json:"threat"`
        Control    string  `json:"control"`
        RiskScore  float64 `json:"risk_score"`
        Residual   float64 `json:"residual"`
        Acceptable bool    `json:"acceptable"`
}

// SecurityValidationReport contains the results of security validation
type SecurityValidationReport struct {
        Timestamp        time.Time                      `json:"timestamp"`
        OverallRisk      string                         `json:"overall_risk"`
        Vulnerabilities  []VulnerabilityInfo            `json:"vulnerabilities"`
        ThreatAssessment map[string]ThreatAssessment    `json:"threat_assessment"`
        ControlStatus    map[string]ControlAssessment   `json:"control_status"`
        Recommendations  []SecurityRecommendation       `json:"recommendations"`
        Compliance       ComplianceStatus               `json:"compliance"`
        Passed           bool                           `json:"passed"`
}

// ThreatAssessment contains assessment of a specific threat
type ThreatAssessment struct {
        ThreatID     string  `json:"threat_id"`
        RiskLevel    string  `json:"risk_level"`
        Mitigated    bool    `json:"mitigated"`
        RiskScore    float64 `json:"risk_score"`
        Controls     []string `json:"controls"`
        Gaps         []string `json:"gaps"`
}

// ControlAssessment contains assessment of a security control
type ControlAssessment struct {
        ControlID     string  `json:"control_id"`
        Implemented   bool    `json:"implemented"`
        Effective     bool    `json:"effective"`
        Coverage      float64 `json:"coverage"`
        Deficiencies  []string `json:"deficiencies"`
}

// SecurityRecommendation provides actionable security recommendations
type SecurityRecommendation struct {
        Priority    string `json:"priority"`    // CRITICAL, HIGH, MEDIUM, LOW
        Category    string `json:"category"`    // VULNERABILITY, CONFIGURATION, POLICY
        Title       string `json:"title"`
        Description string `json:"description"`
        Action      string `json:"action"`
        Impact      string `json:"impact"`
        Effort      string `json:"effort"`      // HIGH, MEDIUM, LOW
}

// ComplianceStatus tracks compliance with security standards
type ComplianceStatus struct {
        Standards   map[string]StandardCompliance `json:"standards"`
        Overall     string                        `json:"overall"` // COMPLIANT, PARTIAL, NON_COMPLIANT
        Score       float64                       `json:"score"`
}

// StandardCompliance tracks compliance with a specific standard
type StandardCompliance struct {
        Standard    string             `json:"standard"`
        Version     string             `json:"version"`
        Compliant   bool               `json:"compliant"`
        Score       float64            `json:"score"`
        Controls    map[string]bool    `json:"controls"`
        Deficiencies []string          `json:"deficiencies"`
}

// NewSecurityValidator creates a new security validator
func NewSecurityValidator(logger zerolog.Logger) *SecurityValidator <span class="cov2" title="2">{
        return &amp;SecurityValidator{
                logger:       logger.With().Str("component", "security_validator").Logger(),
                vulnDatabase: make(map[string]VulnerabilityInfo),
                policyEngine: NewSecurityPolicyEngine(),
                threatModel:  NewThreatModel(),
        }
}</span>

// NewThreatModel creates a comprehensive threat model
func NewThreatModel() *ThreatModel <span class="cov3" title="3">{
        return &amp;ThreatModel{
                Threats: map[string]ThreatInfo{
                        "T001": {
                                ID:          "T001",
                                Name:        "Container Escape",
                                Description: "Attacker escapes container to access host system",
                                Impact:      "HIGH",
                                Probability: "LOW",
                                Category:    "CONTAINER_ESCAPE",
                                Mitigations: []string{"C001", "C002", "C003", "C006", "C009", "C010"},
                        },
                        "T002": {
                                ID:          "T002",
                                Name:        "Code Injection",
                                Description: "Malicious code execution through input validation bypass",
                                Impact:      "HIGH",
                                Probability: "MEDIUM",
                                Category:    "CODE_INJECTION",
                                Mitigations: []string{"C002", "C004", "C005", "C006"},
                        },
                        "T003": {
                                ID:          "T003",
                                Name:        "Resource Exhaustion",
                                Description: "DoS attack through resource consumption",
                                Impact:      "MEDIUM",
                                Probability: "HIGH",
                                Category:    "RESOURCE_EXHAUSTION",
                                Mitigations: []string{"C007", "C008"},
                        },
                        "T004": {
                                ID:          "T004",
                                Name:        "Privilege Escalation",
                                Description: "Unauthorized elevation of privileges within container",
                                Impact:      "HIGH",
                                Probability: "LOW",
                                Category:    "PRIVILEGE_ESCALATION",
                                Mitigations: []string{"C001", "C009", "C010"},
                        },
                        "T005": {
                                ID:          "T005",
                                Name:        "Data Exfiltration",
                                Description: "Unauthorized access and extraction of sensitive data",
                                Impact:      "HIGH",
                                Probability: "MEDIUM",
                                Category:    "DATA_EXFILTRATION",
                                Mitigations: []string{"C003", "C011", "C012", "C013"},
                        },
                },
                Controls: map[string]ControlInfo{
                        "C001": {
                                ID:           "C001",
                                Name:         "Non-root User Execution",
                                Description:  "Run containers with non-privileged user (1000:1000)",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T004"},
                                Implemented:  true,
                        },
                        "C002": {
                                ID:           "C002",
                                Name:         "Read-only Root Filesystem",
                                Description:  "Mount root filesystem as read-only",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T002"},
                                Implemented:  true,
                        },
                        "C003": {
                                ID:           "C003",
                                Name:         "Network Isolation",
                                Description:  "Disable network access (--network=none)",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T005"},
                                Implemented:  true,
                        },
                        "C004": {
                                ID:           "C004",
                                Name:         "Input Validation",
                                Description:  "Validate and sanitize all command inputs",
                                Type:         "PREVENTIVE",
                                Effectiveness: "MEDIUM",
                                Threats:      []string{"T002"},
                                Implemented:  true,
                        },
                        "C005": {
                                ID:           "C005",
                                Name:         "Command Allowlisting",
                                Description:  "Only allow predefined safe commands",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T002"},
                                Implemented:  true, // Command validation is implemented
                        },
                        "C006": {
                                ID:           "C006",
                                Name:         "Seccomp Profile",
                                Description:  "Restrict system calls with seccomp",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T002"},
                                Implemented:  true,
                        },
                        "C007": {
                                ID:           "C007",
                                Name:         "Resource Limits",
                                Description:  "Enforce CPU and memory limits",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T003"},
                                Implemented:  true,
                        },
                        "C008": {
                                ID:           "C008",
                                Name:         "Execution Timeout",
                                Description:  "Terminate long-running processes",
                                Type:         "DETECTIVE",
                                Effectiveness: "MEDIUM",
                                Threats:      []string{"T003"},
                                Implemented:  true,
                        },
                        "C009": {
                                ID:           "C009",
                                Name:         "Capability Dropping",
                                Description:  "Drop all Linux capabilities",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T004"},
                                Implemented:  true,
                        },
                        "C010": {
                                ID:           "C010",
                                Name:         "AppArmor Profile",
                                Description:  "Enforce AppArmor security profile",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T001", "T004"},
                                Implemented:  true,
                        },
                        "C011": {
                                ID:           "C011",
                                Name:         "Audit Logging",
                                Description:  "Log all security events for monitoring",
                                Type:         "DETECTIVE",
                                Effectiveness: "MEDIUM",
                                Threats:      []string{"T005"},
                                Implemented:  true,
                        },
                        "C012": {
                                ID:           "C012",
                                Name:         "Volume Restrictions",
                                Description:  "Limit filesystem mount points",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T005"},
                                Implemented:  true,
                        },
                        "C013": {
                                ID:           "C013",
                                Name:         "Encrypted Storage",
                                Description:  "Encrypt sensitive data at rest",
                                Type:         "PREVENTIVE",
                                Effectiveness: "HIGH",
                                Threats:      []string{"T005"},
                                Implemented:  true, // Assume implemented for baseline security
                        },
                },
                RiskMatrix: make(map[string][]RiskFactor),
        }
}</span>

// ValidateSecurity performs comprehensive security validation
func (sv *SecurityValidator) ValidateSecurity(ctx context.Context, sessionID string, options AdvancedSandboxOptions) (*SecurityValidationReport, error) <span class="cov4" title="7">{
        sv.logger.Info().Str("session_id", sessionID).Msg("Starting security validation")

        report := &amp;SecurityValidationReport{
                Timestamp:        time.Now(),
                Vulnerabilities:  []VulnerabilityInfo{},
                ThreatAssessment: make(map[string]ThreatAssessment),
                ControlStatus:    make(map[string]ControlAssessment),
                Recommendations:  []SecurityRecommendation{},
                Compliance:       sv.assessCompliance(),
        }

        // Assess threats
        sv.assessThreats(report, options)

        // Evaluate controls
        sv.evaluateControls(report, options)

        // Scan for vulnerabilities
        sv.scanVulnerabilities(ctx, report, options)

        // Generate recommendations
        sv.generateSecurityRecommendations(report)

        // Calculate overall risk
        report.OverallRisk = sv.calculateOverallRisk(report)
        report.Passed = report.OverallRisk != "HIGH" &amp;&amp; report.OverallRisk != "CRITICAL"

        sv.logger.Info().
                Str("session_id", sessionID).
                Str("overall_risk", report.OverallRisk).
                Bool("passed", report.Passed).
                Int("vulnerabilities", len(report.Vulnerabilities)).
                Int("recommendations", len(report.Recommendations)).
                Msg("Security validation completed")

        return report, nil
}</span>

// assessThreats evaluates all threats in the threat model
func (sv *SecurityValidator) assessThreats(report *SecurityValidationReport, options AdvancedSandboxOptions) <span class="cov4" title="7">{
        for threatID, threat := range sv.threatModel.Threats </span><span class="cov7" title="35">{
                assessment := ThreatAssessment{
                        ThreatID:  threatID,
                        Controls:  []string{},
                        Gaps:      []string{},
                        Mitigated: true,
                }

                // Check if mitigations are in place
                for _, controlID := range threat.Mitigations </span><span class="cov10" title="133">{
                        control, exists := sv.threatModel.Controls[controlID]
                        if !exists </span><span class="cov0" title="0">{
                                assessment.Gaps = append(assessment.Gaps, fmt.Sprintf("Control %s not found", controlID))
                                assessment.Mitigated = false
                                continue</span>
                        }

                        <span class="cov10" title="133">assessment.Controls = append(assessment.Controls, controlID)
                        if !control.Implemented </span><span class="cov0" title="0">{
                                assessment.Gaps = append(assessment.Gaps, fmt.Sprintf("Control %s not implemented", controlID))
                                assessment.Mitigated = false
                        }</span> else<span class="cov10" title="133"> {
                                // Check if control is actually effective for current configuration
                                effective := sv.isControlEffective(controlID, options)
                                if !effective </span><span class="cov7" title="32">{
                                        assessment.Mitigated = false
                                        assessment.Gaps = append(assessment.Gaps, fmt.Sprintf("Control %s not effective in current configuration", controlID))
                                }</span>
                        }
                }

                // Calculate risk score
                <span class="cov7" title="35">assessment.RiskScore = sv.calculateThreatRiskScore(threat, assessment.Mitigated)
                assessment.RiskLevel = sv.getRiskLevel(assessment.RiskScore)

                report.ThreatAssessment[threatID] = assessment</span>
        }
}

// evaluateControls assesses the effectiveness of security controls
func (sv *SecurityValidator) evaluateControls(report *SecurityValidationReport, options AdvancedSandboxOptions) <span class="cov4" title="7">{
        for controlID, control := range sv.threatModel.Controls </span><span class="cov9" title="91">{
                assessment := ControlAssessment{
                        ControlID:     controlID,
                        Implemented:   control.Implemented,
                        Effective:     control.Implemented,
                        Coverage:      0.0,
                        Deficiencies: []string{},
                }

                // Assess specific control implementations
                switch controlID </span>{
                case "C001":<span class="cov4" title="7"> // Non-root user
                        if options.User == "" || options.User == "root" || options.User == "0" </span><span class="cov2" title="2">{
                                assessment.Effective = false
                                assessment.Deficiencies = append(assessment.Deficiencies, "Running as root user")
                        }</span> else<span class="cov3" title="5"> {
                                assessment.Coverage = 1.0
                        }</span>

                case "C002":<span class="cov4" title="7"> // Read-only root filesystem
                        if options.ReadOnly </span><span class="cov3" title="3">{
                                assessment.Coverage = 1.0
                        }</span> else<span class="cov3" title="4"> {
                                assessment.Effective = false
                                assessment.Deficiencies = append(assessment.Deficiencies, "Root filesystem is writable")
                        }</span>

                case "C003":<span class="cov4" title="7"> // Network isolation
                        if !options.NetworkAccess </span><span class="cov3" title="4">{
                                assessment.Coverage = 1.0
                        }</span> else<span class="cov3" title="3"> {
                                assessment.Coverage = 0.5 // Partial if restricted
                                assessment.Deficiencies = append(assessment.Deficiencies, "Network access enabled")
                        }</span>

                case "C007":<span class="cov4" title="7"> // Resource limits
                        if options.MemoryLimit &gt; 0 &amp;&amp; options.CPUQuota &gt; 0 </span><span class="cov3" title="4">{
                                assessment.Coverage = 1.0
                        }</span> else<span class="cov3" title="3"> {
                                assessment.Effective = false
                                assessment.Deficiencies = append(assessment.Deficiencies, "Resource limits not configured")
                        }</span>

                case "C009":<span class="cov4" title="7"> // Capability dropping
                        if len(options.Capabilities) == 0 </span><span class="cov3" title="4">{
                                assessment.Coverage = 1.0
                        }</span> else<span class="cov3" title="3"> {
                                assessment.Coverage = 0.5
                                assessment.Deficiencies = append(assessment.Deficiencies, "Some capabilities granted")
                        }</span>

                default:<span class="cov8" title="56">
                        // Default assessment for other controls
                        if control.Implemented </span><span class="cov8" title="56">{
                                assessment.Coverage = 0.8 // Assume good coverage if implemented
                        }</span>
                }

                <span class="cov9" title="91">report.ControlStatus[controlID] = assessment</span>
        }
}

// scanVulnerabilities scans for known vulnerabilities
func (sv *SecurityValidator) scanVulnerabilities(ctx context.Context, report *SecurityValidationReport, options AdvancedSandboxOptions) <span class="cov4" title="7">{
        // Check for common misconfigurations
        if options.User == "root" || options.User == "0" </span><span class="cov2" title="2">{
                vuln := VulnerabilityInfo{
                        CVE:         "MISC-001",
                        Severity:    "HIGH",
                        Description: "Container running as root user",
                        Component:   "Container Runtime",
                        Patched:     false,
                        DetectedAt:  time.Now(),
                }
                report.Vulnerabilities = append(report.Vulnerabilities, vuln)
        }</span>

        <span class="cov4" title="7">if len(options.Capabilities) &gt; 0 </span><span class="cov3" title="3">{
                dangerousCaps := []string{"SYS_ADMIN", "NET_ADMIN", "SYS_PTRACE", "DAC_OVERRIDE"}
                for _, cap := range options.Capabilities </span><span class="cov3" title="5">{
                        for _, dangerous := range dangerousCaps </span><span class="cov6" title="20">{
                                if strings.EqualFold(cap, dangerous) </span><span class="cov3" title="4">{
                                        vuln := VulnerabilityInfo{
                                                CVE:         fmt.Sprintf("MISC-CAP-%s", dangerous),
                                                Severity:    "HIGH",
                                                Description: fmt.Sprintf("Dangerous capability %s granted", dangerous),
                                                Component:   "Container Security",
                                                Patched:     false,
                                                DetectedAt:  time.Now(),
                                        }
                                        report.Vulnerabilities = append(report.Vulnerabilities, vuln)
                                }</span>
                        }
                }
        }

        <span class="cov4" title="7">if options.NetworkAccess </span><span class="cov3" title="3">{
                vuln := VulnerabilityInfo{
                        CVE:         "MISC-002",
                        Severity:    "MEDIUM",
                        Description: "Network access enabled in sandbox",
                        Component:   "Network Security",
                        Patched:     false,
                        DetectedAt:  time.Now(),
                }
                report.Vulnerabilities = append(report.Vulnerabilities, vuln)
        }</span>

        // Check base image for known vulnerabilities (simplified)
        <span class="cov4" title="7">if strings.Contains(options.BaseImage, "latest") </span><span class="cov3" title="4">{
                vuln := VulnerabilityInfo{
                        CVE:         "MISC-003",
                        Severity:    "LOW",
                        Description: "Using 'latest' tag for base image",
                        Component:   "Image Management",
                        Patched:     false,
                        DetectedAt:  time.Now(),
                }
                report.Vulnerabilities = append(report.Vulnerabilities, vuln)
        }</span>
}

// generateSecurityRecommendations creates actionable security recommendations
func (sv *SecurityValidator) generateSecurityRecommendations(report *SecurityValidationReport) <span class="cov4" title="7">{
        // High priority vulnerabilities
        for _, vuln := range report.Vulnerabilities </span><span class="cov5" title="13">{
                if vuln.Severity == "HIGH" || vuln.Severity == "CRITICAL" </span><span class="cov4" title="6">{
                        rec := SecurityRecommendation{
                                Priority:    "HIGH",
                                Category:    "VULNERABILITY",
                                Title:       fmt.Sprintf("Address %s vulnerability", vuln.CVE),
                                Description: vuln.Description,
                                Action:      sv.getVulnerabilityAction(vuln),
                                Impact:      "HIGH",
                                Effort:      "MEDIUM",
                        }
                        report.Recommendations = append(report.Recommendations, rec)
                }</span>
        }

        // Control gaps
        <span class="cov4" title="7">for _, assessment := range report.ThreatAssessment </span><span class="cov7" title="35">{
                if !assessment.Mitigated &amp;&amp; assessment.RiskLevel == "HIGH" </span><span class="cov5" title="12">{
                        rec := SecurityRecommendation{
                                Priority:    "HIGH",
                                Category:    "CONFIGURATION",
                                Title:       fmt.Sprintf("Mitigate threat %s", assessment.ThreatID),
                                Description: fmt.Sprintf("Threat %s is not adequately mitigated", assessment.ThreatID),
                                Action:      "Implement missing security controls",
                                Impact:      "HIGH",
                                Effort:      "MEDIUM",
                        }
                        report.Recommendations = append(report.Recommendations, rec)
                }</span>
        }

        // Control deficiencies
        <span class="cov4" title="7">for controlID, assessment := range report.ControlStatus </span><span class="cov9" title="91">{
                if !assessment.Effective &amp;&amp; len(assessment.Deficiencies) &gt; 0 </span><span class="cov5" title="9">{
                        rec := SecurityRecommendation{
                                Priority:    "MEDIUM",
                                Category:    "CONFIGURATION",
                                Title:       fmt.Sprintf("Fix control %s deficiencies", controlID),
                                Description: strings.Join(assessment.Deficiencies, "; "),
                                Action:      "Reconfigure security control",
                                Impact:      "MEDIUM",
                                Effort:      "LOW",
                        }
                        report.Recommendations = append(report.Recommendations, rec)
                }</span>
        }
}

// calculateThreatRiskScore calculates risk score for a threat
func (sv *SecurityValidator) calculateThreatRiskScore(threat ThreatInfo, mitigated bool) float64 <span class="cov7" title="39">{
        impactScore := sv.getImpactScore(threat.Impact)
        probabilityScore := sv.getProbabilityScore(threat.Probability)
        baseScore := impactScore * probabilityScore

        if mitigated </span><span class="cov6" title="17">{
                return baseScore * 0.3 // 70% risk reduction if mitigated
        }</span>
        <span class="cov6" title="22">return baseScore</span>
}

// getImpactScore converts impact level to numeric score
func (sv *SecurityValidator) getImpactScore(impact string) float64 <span class="cov7" title="39">{
        switch impact </span>{
        case "HIGH":<span class="cov7" title="30">
                return 3.0</span>
        case "MEDIUM":<span class="cov4" title="8">
                return 2.0</span>
        case "LOW":<span class="cov1" title="1">
                return 1.0</span>
        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

// getProbabilityScore converts probability level to numeric score
func (sv *SecurityValidator) getProbabilityScore(probability string) float64 <span class="cov7" title="39">{
        switch probability </span>{
        case "HIGH":<span class="cov5" title="9">
                return 3.0</span>
        case "MEDIUM":<span class="cov5" title="15">
                return 2.0</span>
        case "LOW":<span class="cov5" title="15">
                return 1.0</span>
        default:<span class="cov0" title="0">
                return 1.0</span>
        }
}

// getRiskLevel converts numeric risk score to risk level
func (sv *SecurityValidator) getRiskLevel(score float64) string <span class="cov7" title="39">{
        switch </span>{
        case score &gt;= 7.0:<span class="cov1" title="1">
                return "CRITICAL"</span>
        case score &gt;= 5.0:<span class="cov5" title="12">
                return "HIGH"</span>
        case score &gt;= 3.0:<span class="cov4" title="8">
                return "MEDIUM"</span>
        default:<span class="cov6" title="18">
                return "LOW"</span>
        }
}

// calculateOverallRisk calculates the overall security risk
func (sv *SecurityValidator) calculateOverallRisk(report *SecurityValidationReport) string <span class="cov6" title="18">{
        criticalCount := 0
        highCount := 0
        mediumCount := 0

        // Count vulnerabilities by severity
        for _, vuln := range report.Vulnerabilities </span><span class="cov6" title="22">{
                switch vuln.Severity </span>{
                case "CRITICAL":<span class="cov0" title="0">
                        criticalCount++</span>
                case "HIGH":<span class="cov5" title="9">
                        highCount++</span>
                case "MEDIUM":<span class="cov4" title="6">
                        mediumCount++</span>
                }
        }

        // Count unmitigated high-risk threats
        <span class="cov6" title="18">for _, assessment := range report.ThreatAssessment </span><span class="cov7" title="35">{
                if !assessment.Mitigated </span><span class="cov6" title="19">{
                        switch assessment.RiskLevel </span>{
                        case "CRITICAL":<span class="cov0" title="0">
                                criticalCount++</span>
                        case "HIGH":<span class="cov5" title="12">
                                highCount++</span>
                        case "MEDIUM":<span class="cov4" title="7">
                                mediumCount++</span>
                        }
                }
        }

        // Determine overall risk
        <span class="cov6" title="18">if criticalCount &gt; 0 </span><span class="cov0" title="0">{
                return "CRITICAL"
        }</span>
        <span class="cov6" title="18">if highCount &gt; 0 </span><span class="cov4" title="8">{
                return "HIGH"
        }</span>
        <span class="cov5" title="10">if mediumCount &gt; 3 </span><span class="cov0" title="0">{ // More lenient threshold
                return "MEDIUM"
        }</span>
        <span class="cov5" title="10">return "LOW"</span>
}

// getVulnerabilityAction provides specific action for vulnerability
func (sv *SecurityValidator) getVulnerabilityAction(vuln VulnerabilityInfo) string <span class="cov4" title="6">{
        switch vuln.CVE </span>{
        case "MISC-001":<span class="cov2" title="2">
                return "Configure container to run as non-root user (1000:1000)"</span>
        case "MISC-002":<span class="cov0" title="0">
                return "Disable network access unless required (--network=none)"</span>
        case "MISC-003":<span class="cov0" title="0">
                return "Use specific version tags instead of 'latest'"</span>
        default:<span class="cov3" title="4">
                if strings.HasPrefix(vuln.CVE, "MISC-CAP-") </span><span class="cov3" title="4">{
                        return "Remove dangerous capability or use --cap-drop=ALL"
                }</span>
                <span class="cov0" title="0">return "Review and apply security patches"</span>
        }
}

// assessCompliance assesses compliance with security standards
func (sv *SecurityValidator) assessCompliance() ComplianceStatus <span class="cov4" title="8">{
        return ComplianceStatus{
                Standards: map[string]StandardCompliance{
                        "CIS_Docker": {
                                Standard:  "CIS Docker Benchmark",
                                Version:   "1.6.0",
                                Compliant: false, // Will be assessed
                                Score:     0.0,
                                Controls: map[string]bool{
                                        "4.1":  true,  // Non-root user
                                        "4.5":  true,  // Read-only root filesystem
                                        "4.6":  false, // Mount propagation
                                        "5.3":  true,  // No network namespace sharing
                                        "5.9":  true,  // Capabilities restrictions
                                        "5.12": true,  // Memory usage limits
                                        "5.13": true,  // CPU usage limits
                                },
                                Deficiencies: []string{},
                        },
                        "NIST_SP800-190": {
                                Standard:  "NIST SP 800-190",
                                Version:   "1.0",
                                Compliant: false,
                                Score:     0.0,
                                Controls: map[string]bool{
                                        "CM-2": true,  // Baseline configuration
                                        "AC-6": true,  // Least privilege
                                        "SC-3": true,  // Security function isolation
                                        "SI-3": false, // Malicious code protection
                                },
                                Deficiencies: []string{"Malicious code protection not implemented"},
                        },
                },
                Overall: "NON_COMPLIANT",
                Score:   0.0,
        }
}</span>

// GenerateSecurityReport generates a human-readable security report
func (sv *SecurityValidator) GenerateSecurityReport(report *SecurityValidationReport) string <span class="cov2" title="2">{
        var sb strings.Builder

        sb.WriteString("SECURITY VALIDATION REPORT\n")
        sb.WriteString("=========================\n\n")
        sb.WriteString(fmt.Sprintf("Timestamp: %s\n", report.Timestamp.Format("2006-01-02 15:04:05")))
        sb.WriteString(fmt.Sprintf("Overall Risk: %s\n", report.OverallRisk))
        sb.WriteString(fmt.Sprintf("Validation: %s\n\n", map[bool]string{true: "✅ PASSED", false: "❌ FAILED"}[report.Passed]))

        // Vulnerability Summary
        sb.WriteString("VULNERABILITY ANALYSIS:\n")
        if len(report.Vulnerabilities) == 0 </span><span class="cov1" title="1">{
                sb.WriteString("✅ No vulnerabilities detected\n\n")
        }</span> else<span class="cov1" title="1"> {
                critical := sv.countBySeverity(report.Vulnerabilities, "CRITICAL")
                high := sv.countBySeverity(report.Vulnerabilities, "HIGH")
                medium := sv.countBySeverity(report.Vulnerabilities, "MEDIUM")
                low := sv.countBySeverity(report.Vulnerabilities, "LOW")

                sb.WriteString(fmt.Sprintf("├─ Critical: %d\n", critical))
                sb.WriteString(fmt.Sprintf("├─ High: %d\n", high))
                sb.WriteString(fmt.Sprintf("├─ Medium: %d\n", medium))
                sb.WriteString(fmt.Sprintf("└─ Low: %d\n\n", low))

                for _, vuln := range report.Vulnerabilities </span><span class="cov1" title="1">{
                        if vuln.Severity == "CRITICAL" || vuln.Severity == "HIGH" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("⚠️  %s [%s]: %s\n", vuln.CVE, vuln.Severity, vuln.Description))
                        }</span>
                }
                <span class="cov1" title="1">sb.WriteString("\n")</span>
        }

        // Threat Assessment
        <span class="cov2" title="2">sb.WriteString("THREAT ASSESSMENT:\n")
        for threatID, assessment := range report.ThreatAssessment </span><span class="cov5" title="10">{
                status := "✅"
                if !assessment.Mitigated </span><span class="cov3" title="4">{
                        status = "❌"
                }</span>
                <span class="cov5" title="10">sb.WriteString(fmt.Sprintf("%s %s: %s (Risk: %s)\n", status, threatID,
                        sv.threatModel.Threats[threatID].Name, assessment.RiskLevel))
                if len(assessment.Gaps) &gt; 0 </span><span class="cov3" title="4">{
                        for _, gap := range assessment.Gaps </span><span class="cov3" title="5">{
                                sb.WriteString(fmt.Sprintf("   └─ Gap: %s\n", gap))
                        }</span>
                }
        }
        <span class="cov2" title="2">sb.WriteString("\n")

        // Control Status
        sb.WriteString("SECURITY CONTROLS:\n")
        for controlID, assessment := range report.ControlStatus </span><span class="cov6" title="26">{
                status := "✅"
                if !assessment.Effective </span><span class="cov2" title="2">{
                        status = "❌"
                }</span>
                <span class="cov6" title="26">coverage := assessment.Coverage * 100
                sb.WriteString(fmt.Sprintf("%s %s: %s (Coverage: %.1f%%)\n", status, controlID,
                        sv.threatModel.Controls[controlID].Name, coverage))
                if len(assessment.Deficiencies) &gt; 0 </span><span class="cov2" title="2">{
                        for _, deficiency := range assessment.Deficiencies </span><span class="cov2" title="2">{
                                sb.WriteString(fmt.Sprintf("   └─ Issue: %s\n", deficiency))
                        }</span>
                }
        }
        <span class="cov2" title="2">sb.WriteString("\n")

        // Recommendations
        if len(report.Recommendations) &gt; 0 </span><span class="cov2" title="2">{
                sb.WriteString("SECURITY RECOMMENDATIONS:\n")
                for _, rec := range report.Recommendations </span><span class="cov3" title="5">{
                        priority := map[string]string{
                                "CRITICAL": "🔴",
                                "HIGH":     "🟠",
                                "MEDIUM":   "🟡",
                                "LOW":      "🟢",
                        }[rec.Priority]
                        sb.WriteString(fmt.Sprintf("%s [%s] %s\n", priority, rec.Priority, rec.Title))
                        sb.WriteString(fmt.Sprintf("   Action: %s\n", rec.Action))
                        sb.WriteString(fmt.Sprintf("   Impact: %s | Effort: %s\n\n", rec.Impact, rec.Effort))
                }</span>
        } else<span class="cov0" title="0"> {
                sb.WriteString("✅ No security recommendations\n\n")
        }</span>

        // Compliance Summary
        <span class="cov2" title="2">sb.WriteString("COMPLIANCE STATUS:\n")
        for _, standard := range report.Compliance.Standards </span><span class="cov3" title="4">{
                status := "❌"
                if standard.Compliant </span><span class="cov0" title="0">{
                        status = "✅"
                }</span>
                <span class="cov3" title="4">sb.WriteString(fmt.Sprintf("%s %s v%s (Score: %.1f%%)\n", status, standard.Standard, standard.Version, standard.Score*100))</span>
        }
        <span class="cov2" title="2">sb.WriteString(fmt.Sprintf("Overall Compliance: %s (Score: %.1f%%)\n", report.Compliance.Overall, report.Compliance.Score*100))

        return sb.String()</span>
}

// countBySeverity counts vulnerabilities by severity level
func (sv *SecurityValidator) countBySeverity(vulns []VulnerabilityInfo, severity string) int <span class="cov3" title="4">{
        count := 0
        for _, vuln := range vulns </span><span class="cov3" title="4">{
                if vuln.Severity == severity </span><span class="cov1" title="1">{
                        count++
                }</span>
        }
        <span class="cov3" title="4">return count</span>
}

// ValidateImageSecurity validates container image security
func (sv *SecurityValidator) ValidateImageSecurity(ctx context.Context, image string) (*SecurityValidationReport, error) <span class="cov3" title="4">{
        sv.logger.Info().Str("image", image).Msg("Validating image security")

        // This would integrate with image scanning tools like Trivy, Clair, or Anchore
        // For now, implement basic checks
        report := &amp;SecurityValidationReport{
                Timestamp:       time.Now(),
                Vulnerabilities: []VulnerabilityInfo{},
                Passed:          true,
        }

        // Check for common bad practices
        if strings.Contains(image, ":latest") || !strings.Contains(image, ":") </span><span class="cov3" title="3">{
                vuln := VulnerabilityInfo{
                        CVE:         "IMG-001",
                        Severity:    "LOW",
                        Description: "Image uses 'latest' tag",
                        Component:   "Image Tag",
                        Patched:     false,
                        DetectedAt:  time.Now(),
                }
                report.Vulnerabilities = append(report.Vulnerabilities, vuln)
        }</span>

        // Check for untrusted registries
        <span class="cov3" title="4">trustedRegistries := []string{"docker.io", "gcr.io", "quay.io", "registry.k8s.io"}
        trusted := false
        for _, registry := range trustedRegistries </span><span class="cov4" title="7">{
                if strings.HasPrefix(image, registry) || !strings.Contains(image, "/") </span><span class="cov3" title="3">{
                        trusted = true
                        break</span>
                }
        }

        <span class="cov3" title="4">if !trusted </span><span class="cov1" title="1">{
                vuln := VulnerabilityInfo{
                        CVE:         "IMG-002",
                        Severity:    "MEDIUM",
                        Description: "Image from untrusted registry",
                        Component:   "Image Registry",
                        Patched:     false,
                        DetectedAt:  time.Now(),
                }
                report.Vulnerabilities = append(report.Vulnerabilities, vuln)
        }</span>

        <span class="cov3" title="4">report.OverallRisk = sv.calculateOverallRisk(report)
        report.Passed = report.OverallRisk != "HIGH" &amp;&amp; report.OverallRisk != "CRITICAL"

        return report, nil</span>
}

// ValidateCommandSecurity validates command security
func (sv *SecurityValidator) ValidateCommandSecurity(cmd []string) (*SecurityValidationReport, error) <span class="cov4" title="7">{
        report := &amp;SecurityValidationReport{
                Timestamp:       time.Now(),
                Vulnerabilities: []VulnerabilityInfo{},
                Passed:          true,
        }

        // Check for dangerous commands
        dangerousPatterns := []struct {
                pattern string
                severity string
                description string
        }{
                {`rm\s+-rf\s+/`, "HIGH", "Destructive file deletion command"},
                {`dd\s+if=.*of=/dev/`, "HIGH", "Disk manipulation command"},
                {`mkfs`, "HIGH", "Filesystem creation command"},
                {`fdisk`, "MEDIUM", "Disk partitioning command"},
                {`mount`, "MEDIUM", "Filesystem mount command"},
                {`sudo|su\s`, "HIGH", "Privilege escalation command"},
                {`curl.*\|.*sh|wget.*\|.*sh`, "HIGH", "Remote code execution pattern"},
                {`nc\s+-l|netcat\s+-l`, "MEDIUM", "Network listener command"},
                {`python.*-c|perl.*-e`, "MEDIUM", "Inline code execution"},
                {`\$\(.*\)|` + "`.*`" + ``, "MEDIUM", "Command substitution detected"},
        }

        cmdString := strings.Join(cmd, " ")
        for _, dangerous := range dangerousPatterns </span><span class="cov8" title="70">{
                matched, _ := regexp.MatchString(dangerous.pattern, cmdString)
                if matched </span><span class="cov3" title="5">{
                        vuln := VulnerabilityInfo{
                                CVE:         fmt.Sprintf("CMD-%d", len(report.Vulnerabilities)+1),
                                Severity:    dangerous.severity,
                                Description: dangerous.description,
                                Component:   "Command Validation",
                                Patched:     false,
                                DetectedAt:  time.Now(),
                        }
                        report.Vulnerabilities = append(report.Vulnerabilities, vuln)
                }</span>
        }

        <span class="cov4" title="7">report.OverallRisk = sv.calculateOverallRisk(report)
        report.Passed = report.OverallRisk != "HIGH" &amp;&amp; report.OverallRisk != "CRITICAL"

        return report, nil</span>
}

// SaveSecurityReport saves the security report to disk
func (sv *SecurityValidator) SaveSecurityReport(report *SecurityValidationReport, filename string) error <span class="cov1" title="1">{
        dir := filepath.Dir(filename)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %v", err)
        }</span>

        // Save JSON report
        <span class="cov1" title="1">jsonFile := filename + ".json"
        data := fmt.Sprintf("%+v", report)

        if err := os.WriteFile(jsonFile, []byte(data), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write JSON report: %v", err)
        }</span>

        // Save human-readable report
        <span class="cov1" title="1">textFile := filename + ".txt"
        textReport := sv.GenerateSecurityReport(report)
        if err := os.WriteFile(textFile, []byte(textReport), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write text report: %v", err)
        }</span>

        <span class="cov1" title="1">sv.logger.Info().
                Str("json_file", jsonFile).
                Str("text_file", textFile).
                Msg("Security report saved")

        return nil</span>
}

// isControlEffective checks if a control is effective given the current configuration
func (sv *SecurityValidator) isControlEffective(controlID string, options AdvancedSandboxOptions) bool <span class="cov10" title="133">{
        switch controlID </span>{
        case "C001":<span class="cov5" title="14"> // Non-root user
                return options.User != "" &amp;&amp; options.User != "root" &amp;&amp; options.User != "0"</span>
        case "C002":<span class="cov5" title="14"> // Read-only root filesystem
                return options.ReadOnly</span>
        case "C003":<span class="cov5" title="14"> // Network isolation
                return !options.NetworkAccess</span>
        case "C007":<span class="cov4" title="7"> // Resource limits
                return options.MemoryLimit &gt; 0 &amp;&amp; options.CPUQuota &gt; 0</span>
        case "C008":<span class="cov4" title="7"> // Execution timeout
                return options.Timeout &gt; 0</span>
        case "C009":<span class="cov5" title="14"> // Capability dropping
                return len(options.Capabilities) == 0</span>
        default:<span class="cov8" title="63">
                // For controls not specifically checked, assume they're effective if implemented
                return true</span>
        }
}</pre>

		<pre class="file" id="file8" style="display: none">package utils

import (
        "context"
        "io"
        "log/slog"
        "os"
        "strings"
        "time"
)

// MCPSlogConfig holds slog configuration for MCP components
type MCPSlogConfig struct {
        Level     slog.Level
        Component string
        AddSource bool
        Writer    io.Writer
}

// NewMCPSlogger creates a slog logger configured for MCP components
func NewMCPSlogger(config MCPSlogConfig) *slog.Logger <span class="cov0" title="0">{
        if config.Writer == nil </span><span class="cov0" title="0">{
                config.Writer = os.Stderr
        }</span>

        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{
                Level:     config.Level,
                AddSource: config.AddSource,
        }

        handler := slog.NewTextHandler(config.Writer, opts)
        logger := slog.New(handler)

        // Add component context if specified
        if config.Component != "" </span><span class="cov0" title="0">{
                logger = logger.With("component", config.Component)
        }</span>

        <span class="cov0" title="0">return logger</span>
}

// ParseSlogLevel converts a string level to slog.Level
func ParseSlogLevel(level string) slog.Level <span class="cov0" title="0">{
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                return slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case "warn", "warning":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                return slog.LevelError</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        }
}

// CreateMCPLoggerWithCapture creates an slog logger with log capture capability
func CreateMCPLoggerWithCapture(logBuffer *RingBuffer, output io.Writer, level slog.Level, component string) *slog.Logger <span class="cov0" title="0">{
        // Create a multi-writer that writes to both the output and captures logs
        captureWriter := NewLogCaptureWriterSlog(logBuffer, output)

        config := MCPSlogConfig{
                Level:     level,
                Component: component,
                AddSource: true,
                Writer:    captureWriter,
        }

        return NewMCPSlogger(config)
}</span>

// LogCaptureWriterSlog captures slog output to a ring buffer
type LogCaptureWriterSlog struct {
        buffer *RingBuffer
        writer io.Writer
}

// NewLogCaptureWriterSlog creates a new slog log capture writer
func NewLogCaptureWriterSlog(buffer *RingBuffer, writer io.Writer) *LogCaptureWriterSlog <span class="cov0" title="0">{
        return &amp;LogCaptureWriterSlog{
                buffer: buffer,
                writer: writer,
        }
}</span>

// Write implements io.Writer and captures log entries
func (w *LogCaptureWriterSlog) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Simplified log capture - just store the text with minimal parsing
        logText := string(p)

        // Simple level detection
        level := "info"
        if strings.Contains(logText, "level=ERROR") </span><span class="cov0" title="0">{
                level = "error"
        }</span> else<span class="cov0" title="0"> if strings.Contains(logText, "level=WARN") </span><span class="cov0" title="0">{
                level = "warn"
        }</span> else<span class="cov0" title="0"> if strings.Contains(logText, "level=DEBUG") </span><span class="cov0" title="0">{
                level = "debug"
        }</span>

        <span class="cov0" title="0">entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   logText,
                Fields:    make(map[string]interface{}),
        }

        w.buffer.Add(entry)

        // Also write to the original writer
        return w.writer.Write(p)</span>
}

// Convenience functions for MCP logging
func InfoMCP(ctx context.Context, logger *slog.Logger, msg string, args ...any) <span class="cov0" title="0">{
        logger.InfoContext(ctx, msg, args...)
}</span>

func WarnMCP(ctx context.Context, logger *slog.Logger, msg string, args ...any) <span class="cov0" title="0">{
        logger.WarnContext(ctx, msg, args...)
}</span>

func ErrorMCP(ctx context.Context, logger *slog.Logger, msg string, args ...any) <span class="cov0" title="0">{
        logger.ErrorContext(ctx, msg, args...)
}</span>

func DebugMCP(ctx context.Context, logger *slog.Logger, msg string, args ...any) <span class="cov0" title="0">{
        logger.DebugContext(ctx, msg, args...)
}</span>
</pre>

		<pre class="file" id="file9" style="display: none">package utils

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "strings"

        "github.com/Azure/container-kit/pkg/mcp/core"
        "github.com/rs/zerolog"
)

// StandardizedValidationMixin provides consistent validation patterns across all atomic tools
type StandardizedValidationMixin struct {
        logger zerolog.Logger
}

// NewStandardizedValidationMixin creates a new standardized validation mixin
func NewStandardizedValidationMixin(logger zerolog.Logger) *StandardizedValidationMixin <span class="cov4" title="3">{
        return &amp;StandardizedValidationMixin{
                logger: logger.With().Str("component", "validation_mixin").Logger(),
        }
}</span>

// ValidatedSession contains session information that has been validated
type ValidatedSession struct {
        ID           string
        WorkspaceDir string
        Session      interface{} // The actual session object
}

// ValidationError represents a standardized validation error
type ValidationError struct {
        Field       string            `json:"field"`
        Value       interface{}       `json:"value"`
        Constraint  string            `json:"constraint"`
        Message     string            `json:"message"`
        Code        string            `json:"code"`
        Severity    string            `json:"severity"`
        Context     map[string]string `json:"context"`
        Suggestions []string          `json:"suggestions"`
}

func (ve *ValidationError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("validation failed for field '%s': %s", ve.Field, ve.Message)
}</span>

// ValidationResult contains the results of validation
type ValidationResult struct {
        Valid    bool               `json:"valid"`
        Errors   []*ValidationError `json:"errors"`
        Warnings []*ValidationError `json:"warnings"`
        Info     []*ValidationError `json:"info"`
}

// AddError adds a validation error
func (vr *ValidationResult) AddError(field, message, code string, value interface{}) <span class="cov9" title="19">{
        vr.Errors = append(vr.Errors, &amp;ValidationError{
                Field:    field,
                Value:    value,
                Message:  message,
                Code:     code,
                Severity: "high",
        })
        vr.Valid = false
}</span>

// AddWarning adds a validation warning
func (vr *ValidationResult) AddWarning(field, message, code string, value interface{}) <span class="cov1" title="1">{
        vr.Warnings = append(vr.Warnings, &amp;ValidationError{
                Field:    field,
                Value:    value,
                Message:  message,
                Code:     code,
                Severity: "medium",
        })
}</span>

// AddInfo adds validation info
func (vr *ValidationResult) AddInfo(field, message, code string, value interface{}) <span class="cov1" title="1">{
        vr.Info = append(vr.Info, &amp;ValidationError{
                Field:    field,
                Value:    value,
                Message:  message,
                Code:     code,
                Severity: "low",
        })
}</span>

// HasErrors returns true if there are validation errors
func (vr *ValidationResult) HasErrors() bool <span class="cov10" title="22">{
        return len(vr.Errors) &gt; 0
}</span>

// GetFirstError returns the first validation error or nil
func (vr *ValidationResult) GetFirstError() *ValidationError <span class="cov9" title="16">{
        if len(vr.Errors) &gt; 0 </span><span class="cov8" title="15">{
                return vr.Errors[0]
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// StandardValidateSession performs standard session validation
func (svm *StandardizedValidationMixin) StandardValidateSession(
        ctx context.Context,
        sessionManager interface {
                GetSession(sessionID string) (interface{}, error)
        },
        sessionID string,
) (*ValidatedSession, error) <span class="cov0" title="0">{
        // Basic validation
        if strings.TrimSpace(sessionID) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("INVALID_INPUT: session_id is required and cannot be empty")
        }</span>

        // Get session
        <span class="cov0" title="0">session, err := sessionManager.GetSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("SESSION_NOT_FOUND: Failed to get session: %v", err)
        }</span>

        // Get workspace directory using reflection or interface
        <span class="cov0" title="0">workspaceDir := ""
        if sessionWithWorkspace, ok := session.(interface{ GetWorkspaceDir() string }); ok </span><span class="cov0" title="0">{
                workspaceDir = sessionWithWorkspace.GetWorkspaceDir()
        }</span> else<span class="cov0" title="0"> {
                // Fallback: try reflection to extract SessionID field for workspace calculation
                if sessionStruct, ok := session.(*core.SessionState); ok </span><span class="cov0" title="0">{
                        workspaceDir = filepath.Join("/tmp", "sessions", sessionStruct.SessionID)
                }</span>
        }

        <span class="cov0" title="0">return &amp;ValidatedSession{
                ID:           sessionID,
                WorkspaceDir: workspaceDir,
                Session:      session,
        }, nil</span>
}

// StandardValidateRequiredFields validates required fields using reflection
func (svm *StandardizedValidationMixin) StandardValidateRequiredFields(
        args interface{},
        requiredFields []string,
) *ValidationResult <span class="cov6" title="7">{
        result := &amp;ValidationResult{Valid: true}

        argValue := reflect.ValueOf(args)
        if argValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                argValue = argValue.Elem()
        }</span>

        <span class="cov6" title="7">for _, fieldName := range requiredFields </span><span class="cov8" title="13">{
                field := argValue.FieldByName(fieldName)
                if !field.IsValid() </span><span class="cov1" title="1">{
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Required field '%s' not found", fieldName),
                                "FIELD_NOT_FOUND",
                                nil,
                        )
                        continue</span>
                }

                <span class="cov8" title="12">if svm.isEmptyValue(field) </span><span class="cov5" title="4">{
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Required field '%s' cannot be empty", fieldName),
                                "FIELD_REQUIRED",
                                field.Interface(),
                        )
                }</span>
        }

        <span class="cov6" title="7">return result</span>
}

// StandardValidatePath validates file/directory paths
func (svm *StandardizedValidationMixin) StandardValidatePath(
        path, fieldName string,
        requirements PathRequirements,
) *ValidationResult <span class="cov7" title="9">{
        result := &amp;ValidationResult{Valid: true}

        if path == "" </span><span class="cov1" title="1">{
                if requirements.Required </span><span class="cov1" title="1">{
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Path field '%s' is required", fieldName),
                                "PATH_REQUIRED",
                                path,
                        )
                }</span>
                <span class="cov1" title="1">return result</span>
        }

        // Clean and validate path
        <span class="cov7" title="8">cleanPath := filepath.Clean(path)
        if cleanPath != path </span><span class="cov0" title="0">{
                result.AddWarning(
                        fieldName,
                        fmt.Sprintf("Path contains redundant elements, cleaned to: %s", cleanPath),
                        "PATH_CLEANED",
                        path,
                )
        }</span>

        // Check if path exists
        <span class="cov7" title="8">stat, err := os.Stat(cleanPath)
        if err != nil </span><span class="cov4" title="3">{
                if os.IsNotExist(err) </span><span class="cov4" title="3">{
                        if requirements.MustExist </span><span class="cov1" title="1">{
                                result.AddError(
                                        fieldName,
                                        fmt.Sprintf("Path does not exist: %s", cleanPath),
                                        "PATH_NOT_FOUND",
                                        cleanPath,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Cannot access path: %s (%v)", cleanPath, err),
                                "PATH_ACCESS_ERROR",
                                cleanPath,
                        )
                }</span>
                <span class="cov4" title="3">return result</span>
        }

        // Validate path type
        <span class="cov5" title="5">if requirements.MustBeFile &amp;&amp; stat.IsDir() </span><span class="cov1" title="1">{
                result.AddError(
                        fieldName,
                        fmt.Sprintf("Path must be a file, but is a directory: %s", cleanPath),
                        "PATH_MUST_BE_FILE",
                        cleanPath,
                )
        }</span>

        <span class="cov5" title="5">if requirements.MustBeDirectory &amp;&amp; !stat.IsDir() </span><span class="cov1" title="1">{
                result.AddError(
                        fieldName,
                        fmt.Sprintf("Path must be a directory, but is a file: %s", cleanPath),
                        "PATH_MUST_BE_DIRECTORY",
                        cleanPath,
                )
        }</span>

        // Check permissions
        <span class="cov5" title="5">if requirements.MustBeReadable </span><span class="cov0" title="0">{
                if err := svm.checkReadPermission(cleanPath); err != nil </span><span class="cov0" title="0">{
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Path is not readable: %s (%v)", cleanPath, err),
                                "PATH_NOT_READABLE",
                                cleanPath,
                        )
                }</span>
        }

        <span class="cov5" title="5">if requirements.MustBeWritable </span><span class="cov0" title="0">{
                if err := svm.checkWritePermission(cleanPath); err != nil </span><span class="cov0" title="0">{
                        result.AddError(
                                fieldName,
                                fmt.Sprintf("Path is not writable: %s (%v)", cleanPath, err),
                                "PATH_NOT_WRITABLE",
                                cleanPath,
                        )
                }</span>
        }

        <span class="cov5" title="5">return result</span>
}

// PathRequirements defines requirements for path validation
type PathRequirements struct {
        Required          bool
        MustExist         bool
        MustBeFile        bool
        MustBeDirectory   bool
        MustBeReadable    bool
        MustBeWritable    bool
        AllowedExtensions []string
}

// StandardValidateImageRef validates Docker image references
func (svm *StandardizedValidationMixin) StandardValidateImageRef(
        imageRef, fieldName string,
) *ValidationResult <span class="cov7" title="11">{
        result := &amp;ValidationResult{Valid: true}

        if imageRef == "" </span><span class="cov1" title="1">{
                result.AddError(
                        fieldName,
                        "Image reference cannot be empty",
                        "IMAGE_REF_REQUIRED",
                        imageRef,
                )
                return result
        }</span>

        // Basic format validation
        <span class="cov7" title="10">parts := strings.Split(imageRef, ":")
        if len(parts) &lt; 2 </span><span class="cov1" title="1">{
                result.AddError(
                        fieldName,
                        "Image reference must include a tag (e.g., image:tag)",
                        "IMAGE_REF_NO_TAG",
                        imageRef,
                )
        }</span>

        // Validate image name part
        <span class="cov7" title="10">imageName := parts[0]
        if imageName == "" </span><span class="cov3" title="2">{
                result.AddError(
                        fieldName,
                        "Image name cannot be empty",
                        "IMAGE_NAME_EMPTY",
                        imageRef,
                )
        }</span>

        // Validate tag part
        <span class="cov7" title="10">if len(parts) &gt;= 2 </span><span class="cov7" title="9">{
                tag := parts[1]
                if tag == "" </span><span class="cov3" title="2">{
                        result.AddError(
                                fieldName,
                                "Image tag cannot be empty",
                                "IMAGE_TAG_EMPTY",
                                imageRef,
                        )
                }</span>
        }

        <span class="cov7" title="10">return result</span>
}

// ConvertValidationToError converts a ValidationResult to a simple error
func (svm *StandardizedValidationMixin) ConvertValidationToError(
        result *ValidationResult,
        operation, stage string,
) error <span class="cov0" title="0">{
        if result.Valid </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">firstError := result.GetFirstError()
        if firstError == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a simple error message combining all validation errors
        <span class="cov0" title="0">var errorMsgs []string
        for _, validationError := range result.Errors </span><span class="cov0" title="0">{
                errorMsgs = append(errorMsgs, fmt.Sprintf("Field '%s': %s", validationError.Field, validationError.Message))
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("validation failed for %s/%s: %s", operation, stage, strings.Join(errorMsgs, "; "))</span>
}

// Helper methods

func (svm *StandardizedValidationMixin) isEmptyValue(v reflect.Value) bool <span class="cov8" title="12">{
        switch v.Kind() </span>{
        case reflect.String:<span class="cov7" title="10">
                return strings.TrimSpace(v.String()) == ""</span>
        case reflect.Slice, reflect.Map, reflect.Array:<span class="cov0" title="0">
                return v.Len() == 0</span>
        case reflect.Ptr, reflect.Interface:<span class="cov1" title="1">
                return v.IsNil()</span>
        case reflect.Bool:<span class="cov0" title="0">
                return false</span> // booleans are never "empty"
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov1" title="1">
                return v.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return v.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return v.Float() == 0</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (svm *StandardizedValidationMixin) checkReadPermission(path string) error <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">file.Close()
        return nil</span>
}

func (svm *StandardizedValidationMixin) checkWritePermission(path string) error <span class="cov0" title="0">{
        // For directories, try to create a temp file
        if stat, err := os.Stat(path); err == nil &amp;&amp; stat.IsDir() </span><span class="cov0" title="0">{
                tempFile := filepath.Join(path, ".write_test")
                file, err := os.Create(tempFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">file.Close()
                os.Remove(tempFile)
                return nil</span>
        }

        // For files, try to open for writing
        <span class="cov0" title="0">file, err := os.OpenFile(path, os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">file.Close()
        return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package utils

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/Azure/container-kit/pkg/utils"
        "github.com/rs/zerolog"
)

// WorkspaceManager manages file system workspaces with quotas and sandboxing
type WorkspaceManager struct {
        baseDir           string
        maxSizePerSession int64 // Per-session disk quota
        totalMaxSize      int64 // Total disk quota across all sessions
        cleanup           bool  // Auto-cleanup after session ends
        sandboxEnabled    bool  // Enable sandboxed execution

        // Quota tracking
        diskUsage map[string]int64 // sessionID -&gt; bytes used
        mutex     sync.RWMutex

        // Docker command for sandboxing
        dockerCmd string

        // Logger
        logger zerolog.Logger
}

// WorkspaceConfig holds configuration for the workspace manager
type WorkspaceConfig struct {
        BaseDir           string
        MaxSizePerSession int64
        TotalMaxSize      int64
        Cleanup           bool
        SandboxEnabled    bool
        Logger            zerolog.Logger
}

// NewWorkspaceManager creates a new workspace manager
func NewWorkspaceManager(ctx context.Context, config WorkspaceConfig) (*WorkspaceManager, error) <span class="cov7" title="10">{
        if err := os.MkdirAll(config.BaseDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create base directory: %v", err)
        }</span>

        <span class="cov7" title="10">wm := &amp;WorkspaceManager{
                baseDir:           config.BaseDir,
                maxSizePerSession: config.MaxSizePerSession,
                totalMaxSize:      config.TotalMaxSize,
                cleanup:           config.Cleanup,
                sandboxEnabled:    config.SandboxEnabled,
                diskUsage:         make(map[string]int64),
                logger:            config.Logger,
        }

        // Initialize Docker command for sandboxing if enabled
        if config.SandboxEnabled </span><span class="cov4" title="3">{
                dockerPath, err := exec.LookPath("docker")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("docker command not found for sandboxing: %v", err)
                }</span>
                <span class="cov4" title="3">wm.dockerCmd = dockerPath</span>
        }

        // Initialize disk usage tracking
        <span class="cov7" title="10">if err := wm.refreshDiskUsage(ctx); err != nil </span><span class="cov0" title="0">{
                wm.logger.Warn().Err(err).Msg("Failed to initialize disk usage tracking")
        }</span>

        <span class="cov7" title="10">return wm, nil</span>
}

// InitializeWorkspace creates a new workspace for a session
func (wm *WorkspaceManager) InitializeWorkspace(ctx context.Context, sessionID string) (string, error) <span class="cov5" title="5">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)

        // Check if workspace already exists
        if _, err := os.Stat(workspaceDir); err == nil </span><span class="cov0" title="0">{
                wm.logger.Info().Str("session_id", sessionID).Str("workspace", workspaceDir).Msg("Workspace already exists")
                return workspaceDir, nil
        }</span>

        // Create workspace directory
        <span class="cov5" title="5">if err := os.MkdirAll(workspaceDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create workspace directory: %v", err)
        }</span>

        // Create subdirectories
        <span class="cov5" title="5">subdirs := []string{
                "repo",      // For cloned repositories
                "build",     // For build artifacts
                "manifests", // For generated manifests
                "logs",      // For execution logs
                "cache",     // For cached data
        }

        for _, subdir := range subdirs </span><span class="cov9" title="25">{
                subdirPath := filepath.Join(workspaceDir, subdir)
                if err := os.MkdirAll(subdirPath, 0o755); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("operation failed")
                }</span>
        }

        <span class="cov5" title="5">wm.logger.Info().Str("session_id", sessionID).Str("workspace", workspaceDir).Msg("Initialized workspace")
        return workspaceDir, nil</span>
}

// CloneRepository clones a Git repository to the session workspace
func (wm *WorkspaceManager) CloneRepository(ctx context.Context, sessionID, repoURL string) error <span class="cov0" title="0">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)
        repoDir := filepath.Join(workspaceDir, "repo")

        // Clean existing repo directory
        if err := os.RemoveAll(repoDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed")
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(repoDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed")
        }</span>

        // Check quota before cloning
        <span class="cov0" title="0">if err := wm.CheckQuota(sessionID, 100*1024*1024); err != nil </span><span class="cov0" title="0">{ // Reserve 100MB for clone
                return err
        }</span>

        // Clone repository with depth limit for security
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "git", "clone", "--depth", "1", "--single-branch", repoURL, repoDir)
        cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0") // Disable interactive prompts

        // Run command with context cancellation
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation cancelled")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("operation failed")</span>
        }

        // Update disk usage
        <span class="cov0" title="0">if err := wm.UpdateDiskUsage(ctx, sessionID); err != nil </span><span class="cov0" title="0">{
                wm.logger.Warn().Err(err).Str("session_id", sessionID).Msg("Failed to update disk usage after clone")
        }</span>

        <span class="cov0" title="0">wm.logger.Info().Str("session_id", sessionID).Str("repo_url", repoURL).Msg("Cloned repository")
        return nil</span>
}

// ValidateLocalPath validates and sanitizes a local path
func (wm *WorkspaceManager) ValidateLocalPath(ctx context.Context, path string) error <span class="cov7" title="12">{
        // Check for empty path first
        if path == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("path cannot be empty")
        }</span>

        // Convert to absolute path - relative paths are relative to workspace base directory
        <span class="cov7" title="11">var absPath string
        if filepath.IsAbs(path) </span><span class="cov5" title="5">{
                absPath = path
        }</span> else<span class="cov5" title="6"> {
                absPath = filepath.Join(wm.baseDir, path)
        }</span>

        // Check for absolute paths outside workspace
        <span class="cov7" title="11">if filepath.IsAbs(path) &amp;&amp; !strings.HasPrefix(absPath, wm.baseDir) </span><span class="cov2" title="2">{
                return fmt.Errorf("absolute paths not allowed outside workspace")
        }</span>

        // Check for path traversal attempts (before conversion to absolute path)
        <span class="cov7" title="9">if strings.Contains(path, "..") </span><span class="cov2" title="2">{
                return fmt.Errorf("path traversal attempts are not allowed")
        }</span>

        // Check for hidden files - check each path component
        <span class="cov6" title="7">pathComponents := strings.Split(path, string(filepath.Separator))
        for _, component := range pathComponents </span><span class="cov9" title="20">{
                if component != "" &amp;&amp; strings.HasPrefix(component, ".") &amp;&amp; component != "." &amp;&amp; component != ".." </span><span class="cov2" title="2">{
                        return fmt.Errorf("hidden files are not allowed")
                }</span>
        }

        // Check if path exists
        <span class="cov5" title="5">if _, err := os.Stat(absPath); err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("path does not exist: %s", path)
        }</span>

        // Additional security checks can be added here
        // e.g., check against allowed base paths

        <span class="cov4" title="3">return nil</span>
}

// GetFilePath returns a safe file path within the session workspace
func (wm *WorkspaceManager) GetFilePath(sessionID, relativePath string) string <span class="cov6" title="7">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)
        return filepath.Join(workspaceDir, relativePath)
}</span>

// CleanupWorkspace removes a session's workspace
func (wm *WorkspaceManager) CleanupWorkspace(ctx context.Context, sessionID string) error <span class="cov6" title="7">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)

        if err := os.RemoveAll(workspaceDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed")
        }</span>

        // Remove from disk usage tracking
        <span class="cov6" title="7">wm.mutex.Lock()
        delete(wm.diskUsage, sessionID)
        wm.mutex.Unlock()

        wm.logger.Info().Str("session_id", sessionID).Msg("Cleaned up workspace")
        return nil</span>
}

// GenerateFileTree creates a string representation of the file tree
func (wm *WorkspaceManager) GenerateFileTree(ctx context.Context, path string) (string, error) <span class="cov0" title="0">{
        // Check for context cancellation
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return "", ctx.Err()
        }</span>
        <span class="cov0" title="0">return utils.GenerateSimpleFileTree(path)</span>
}

// CheckQuota verifies if additional disk space can be allocated
func (wm *WorkspaceManager) CheckQuota(sessionID string, additionalBytes int64) error <span class="cov7" title="11">{
        wm.mutex.RLock()
        defer wm.mutex.RUnlock()

        currentUsage := wm.diskUsage[sessionID]

        // Check per-session quota
        if currentUsage+additionalBytes &gt; wm.maxSizePerSession </span><span class="cov2" title="2">{
                return fmt.Errorf("SESSION_QUOTA_EXCEEDED: session disk quota would be exceeded: %d + %d &gt; %d",
                        currentUsage, additionalBytes, wm.maxSizePerSession)
        }</span>

        // Check global quota
        <span class="cov7" title="9">totalUsage := wm.getTotalDiskUsage()
        if totalUsage+additionalBytes &gt; wm.totalMaxSize </span><span class="cov1" title="1">{
                return fmt.Errorf("GLOBAL_QUOTA_EXCEEDED: global disk quota would be exceeded: %d + %d &gt; %d",
                        totalUsage, additionalBytes, wm.totalMaxSize)
        }</span>

        <span class="cov6" title="8">return nil</span>
}

// UpdateDiskUsage calculates and updates disk usage for a session
func (wm *WorkspaceManager) UpdateDiskUsage(ctx context.Context, sessionID string) error <span class="cov6" title="7">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)

        // Check if directory exists
        if _, err := os.Stat(workspaceDir); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // Directory doesn't exist, set usage to 0
                wm.mutex.Lock()
                wm.diskUsage[sessionID] = 0
                wm.mutex.Unlock()
                return nil
        }</span>

        <span class="cov5" title="6">var totalSize int64
        err := filepath.Walk(workspaceDir, func(path string, info os.FileInfo, err error) error </span><span class="cov9" title="25">{
                // Check for context cancellation
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
                <span class="cov9" title="25">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov9" title="25">if !info.IsDir() </span><span class="cov6" title="7">{
                        totalSize += info.Size()
                }</span>
                <span class="cov9" title="25">return nil</span>
        })
        <span class="cov5" title="6">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("operation failed")
        }</span>

        <span class="cov5" title="6">wm.mutex.Lock()
        wm.diskUsage[sessionID] = totalSize
        wm.mutex.Unlock()

        return nil</span>
}

// GetDiskUsage returns the current disk usage for a session
func (wm *WorkspaceManager) GetDiskUsage(sessionID string) int64 <span class="cov5" title="5">{
        wm.mutex.RLock()
        defer wm.mutex.RUnlock()
        return wm.diskUsage[sessionID]
}</span>

// GetBaseDir returns the base directory for workspaces
func (wm *WorkspaceManager) GetBaseDir() string <span class="cov0" title="0">{
        return wm.baseDir
}</span>

// EnforceGlobalQuota checks and enforces global disk quotas
func (wm *WorkspaceManager) EnforceGlobalQuota() error <span class="cov5" title="5">{
        totalUsage := wm.getTotalDiskUsage()

        if totalUsage &gt; wm.totalMaxSize </span><span class="cov2" title="2">{
                // Find sessions that can be cleaned up (oldest first)
                // This is a simplified implementation - could be more sophisticated
                return fmt.Errorf("GLOBAL_QUOTA_EXCEEDED: total disk usage %d exceeds limit %d", totalUsage, wm.totalMaxSize)
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// Sandboxing types and configuration

// SandboxOptions configures sandboxed execution
type SandboxOptions struct {
        BaseImage      string            `json:"base_image"`
        Environment    map[string]string `json:"environment"`
        MemoryLimit    int64             `json:"memory_limit"`
        CPUQuota       int64             `json:"cpu_quota"`
        Timeout        time.Duration     `json:"timeout"`
        ReadOnly       bool              `json:"read_only"`
        NetworkAccess  bool              `json:"network_access"`
        SecurityPolicy SecurityPolicy    `json:"security_policy"`
}

// SecurityPolicy defines security constraints for sandboxed execution
type SecurityPolicy struct {
        AllowNetworking   bool           `json:"allow_networking"`
        AllowFileSystem   bool           `json:"allow_filesystem"`
        AllowedSyscalls   []string       `json:"allowed_syscalls"`
        ResourceLimits    ResourceLimits `json:"resource_limits"`
        TrustedRegistries []string       `json:"trusted_registries"`
        RequireNonRoot    bool           `json:"require_non_root"`
}

// ResourceLimits defines resource constraints
type ResourceLimits struct {
        Memory    int64 `json:"memory"`
        CPUQuota  int64 `json:"cpu_quota"`
        DiskSpace int64 `json:"disk_space"`
}

// ExecResult contains the result of sandboxed execution
type ExecResult struct {
        ExitCode int              `json:"exit_code"`
        Stdout   string           `json:"stdout"`
        Stderr   string           `json:"stderr"`
        Duration time.Duration    `json:"duration"`
        Metrics  ExecutionMetrics `json:"metrics"`
}

// ExecutionMetrics provides runtime metrics for sandboxed execution
type ExecutionMetrics struct {
        MemoryUsage int64 `json:"memory_usage"`
        CPUUsage    int64 `json:"cpu_usage"`
        NetworkIO   int64 `json:"network_io"`
        DiskIO      int64 `json:"disk_io"`
}

// Sandboxing methods

// ExecuteSandboxed runs commands in a secure Docker container
func (wm *WorkspaceManager) ExecuteSandboxed(ctx context.Context, sessionID string, cmd []string, options SandboxOptions) (*ExecResult, error) <span class="cov4" title="3">{
        if !wm.sandboxEnabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sandboxing is disabled")
        }</span>

        <span class="cov2" title="2">if wm.dockerCmd == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("docker command not initialized")
        }</span>

        // Validate security policy
        <span class="cov2" title="2">if err := wm.validateSecurityPolicy(options.SecurityPolicy); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("security policy validation failed: %v", err)
        }</span>

        // Build Docker run command
        <span class="cov2" title="2">dockerArgs, err := wm.buildDockerRunCommand(sessionID, cmd, options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build docker command: %v", err)
        }</span>

        // Execute with monitoring and timeout
        <span class="cov2" title="2">ctx, cancel := context.WithTimeout(ctx, options.Timeout)
        defer cancel()

        return wm.executeDockerCommand(ctx, dockerArgs, sessionID)</span>
}

// SandboxedAnalysis runs repository analysis in a sandboxed environment
func (wm *WorkspaceManager) SandboxedAnalysis(ctx context.Context, sessionID, repoPath string, options interface{}) (interface{}, error) <span class="cov2" title="2">{
        if !wm.sandboxEnabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sandboxing is disabled")
        }</span>

        // Create sandboxed analysis options
        <span class="cov1" title="1">sandboxOpts := SandboxOptions{
                BaseImage:     "alpine:latest",
                MemoryLimit:   256 * 1024 * 1024, // 256MB
                CPUQuota:      50000,             // 50% of one CPU
                Timeout:       5 * time.Minute,
                ReadOnly:      true,
                NetworkAccess: false,
                SecurityPolicy: SecurityPolicy{
                        AllowNetworking:   false,
                        AllowFileSystem:   true,
                        RequireNonRoot:    true,
                        TrustedRegistries: []string{"docker.io", "alpine"},
                },
        }

        // Analyze repository structure safely
        cmd := []string{"sh", "-c", "find /workspace/repo -type f -name '*.go' -o -name '*.js' -o -name '*.py' | head -100"}
        result, err := wm.ExecuteSandboxed(ctx, sessionID, cmd, sandboxOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sandboxed analysis failed: %v", err)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// SandboxedBuild runs Docker build in a sandboxed environment
func (wm *WorkspaceManager) SandboxedBuild(ctx context.Context, sessionID, dockerfilePath string, options interface{}) (interface{}, error) <span class="cov2" title="2">{
        if !wm.sandboxEnabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("sandboxing is disabled")
        }</span>

        // Create sandboxed build options with more resources
        <span class="cov1" title="1">sandboxOpts := SandboxOptions{
                BaseImage:     "docker:dind",
                MemoryLimit:   1024 * 1024 * 1024, // 1GB
                CPUQuota:      100000,             // 100% of one CPU
                Timeout:       15 * time.Minute,
                ReadOnly:      false,
                NetworkAccess: true, // Needed for pulling base images
                SecurityPolicy: SecurityPolicy{
                        AllowNetworking:   true,
                        AllowFileSystem:   true,
                        RequireNonRoot:    false, // Docker-in-Docker requires privileged access
                        TrustedRegistries: []string{"docker.io", "alpine", "ubuntu"},
                },
        }

        // Build Docker image safely
        cmd := []string{"docker", "build", "-t", "temp-build", "/workspace/repo"}
        result, err := wm.ExecuteSandboxed(ctx, sessionID, cmd, sandboxOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sandboxed build failed: %v", err)
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// Helper methods for sandboxing

// ValidateSecurityPolicy validates a security policy (public method for testing)
func (wm *WorkspaceManager) ValidateSecurityPolicy(policy SecurityPolicy) error <span class="cov6" title="7">{
        return wm.validateSecurityPolicy(policy)
}</span>

func (wm *WorkspaceManager) validateSecurityPolicy(policy SecurityPolicy) error <span class="cov7" title="11">{
        // Validate trusted registries
        if len(policy.TrustedRegistries) == 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("at least one trusted registry must be specified")
        }</span>

        // Validate resource limits
        <span class="cov7" title="9">if policy.ResourceLimits.Memory &gt; 0 &amp;&amp; policy.ResourceLimits.Memory &lt; 64*1024*1024 </span><span class="cov0" title="0">{
                return fmt.Errorf("memory limit too low: minimum 64MB required")
        }</span>

        <span class="cov7" title="9">return nil</span>
}

func (wm *WorkspaceManager) buildDockerRunCommand(sessionID string, cmd []string, options SandboxOptions) ([]string, error) <span class="cov4" title="4">{
        workspaceDir := filepath.Join(wm.baseDir, sessionID)

        args := []string{"run", "--rm"}

        // Resource limits
        if options.MemoryLimit &gt; 0 </span><span class="cov4" title="4">{
                args = append(args, fmt.Sprintf("--memory=%d", options.MemoryLimit))
        }</span>
        <span class="cov4" title="4">if options.CPUQuota &gt; 0 </span><span class="cov4" title="4">{
                cpuLimit := float64(options.CPUQuota) / 100000.0 // Convert from Docker quota to CPU limit
                args = append(args, fmt.Sprintf("--cpus=%.2f", cpuLimit))
        }</span>

        // Security settings
        <span class="cov4" title="4">if options.SecurityPolicy.RequireNonRoot </span><span class="cov2" title="2">{
                args = append(args, "--user=1000:1000")
        }</span>

        <span class="cov4" title="4">if options.ReadOnly </span><span class="cov2" title="2">{
                args = append(args, "--read-only")
        }</span>

        // Network access
        <span class="cov4" title="4">if !options.NetworkAccess || !options.SecurityPolicy.AllowNetworking </span><span class="cov2" title="2">{
                args = append(args, "--network=none")
        }</span>

        // Environment variables
        <span class="cov4" title="4">env := wm.sanitizeEnvironment(options.Environment)
        for _, envVar := range env </span><span class="cov0" title="0">{
                args = append(args, "-e", envVar)
        }</span>

        // Mount workspace
        <span class="cov4" title="4">mountType := "bind"
        if options.ReadOnly </span><span class="cov2" title="2">{
                mountType = "bind,readonly"
        }</span>
        <span class="cov4" title="4">args = append(args, "-v", fmt.Sprintf("%s:/workspace:%s", workspaceDir, mountType))

        // Add temporary directory
        args = append(args, "--tmpfs", "/tmp:size=100m")

        // Add Docker socket for Docker-in-Docker if needed
        if strings.Contains(options.BaseImage, "dind") </span><span class="cov2" title="2">{
                args = append(args, "-v", "/var/run/docker.sock:/var/run/docker.sock")
                args = append(args, "--privileged")
        }</span>

        // Working directory
        <span class="cov4" title="4">args = append(args, "-w", "/workspace")

        // Image
        args = append(args, options.BaseImage)

        // Command
        args = append(args, cmd...)

        return args, nil</span>
}

func (wm *WorkspaceManager) sanitizeEnvironment(env map[string]string) []string <span class="cov7" title="12">{
        var sanitized []string

        // Allow list of safe environment variables
        allowedPrefixes := []string{"PATH", "HOME", "USER", "LANG", "LC_"}

        for key, value := range env </span><span class="cov6" title="7">{
                safe := false
                for _, prefix := range allowedPrefixes </span><span class="cov9" title="25">{
                        if strings.HasPrefix(key, prefix) </span><span class="cov4" title="4">{
                                safe = true
                                break</span>
                        }
                }

                // Additional validation for specific variables
                <span class="cov6" title="7">if safe &amp;&amp; !strings.Contains(value, ";") &amp;&amp; !strings.Contains(value, "|") </span><span class="cov4" title="4">{
                        sanitized = append(sanitized, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }

        <span class="cov7" title="12">return sanitized</span>
}

func (wm *WorkspaceManager) executeDockerCommand(ctx context.Context, dockerArgs []string, sessionID string) (*ExecResult, error) <span class="cov4" title="4">{
        startTime := time.Now()

        // Create the docker command
        cmd := exec.CommandContext(ctx, wm.dockerCmd, dockerArgs...)

        // Capture stdout and stderr separately
        stdoutBuf := &amp;strings.Builder{}
        stderrBuf := &amp;strings.Builder{}
        cmd.Stdout = stdoutBuf
        cmd.Stderr = stderrBuf

        // Execute the command
        err := cmd.Run()
        duration := time.Since(startTime)

        // Get exit code
        exitCode := 0
        if err != nil </span><span class="cov2" title="2">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov2" title="2">{
                        exitCode = exitError.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        // Non-exit error (e.g., command not found)
                        return nil, fmt.Errorf("failed to execute docker command: %v", err)
                }</span>
        }

        <span class="cov4" title="4">stdout := stdoutBuf.String()
        stderr := stderrBuf.String()

        wm.logger.Info().
                Str("session_id", sessionID).
                Int("exit_code", exitCode).
                Dur("duration", duration).
                Msg("Sandboxed execution completed")

        return &amp;ExecResult{
                ExitCode: exitCode,
                Stdout:   stdout,
                Stderr:   stderr,
                Duration: duration,
                Metrics:  ExecutionMetrics{}, // Basic metrics - could be enhanced
        }, nil</span>
}

// Helper methods

func (wm *WorkspaceManager) refreshDiskUsage(ctx context.Context) error <span class="cov7" title="10">{
        sessions, err := os.ReadDir(wm.baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="10">for _, session := range sessions </span><span class="cov0" title="0">{
                // Check for context cancellation
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
                <span class="cov0" title="0">if session.IsDir() </span><span class="cov0" title="0">{
                        sessionID := session.Name()
                        if err := wm.UpdateDiskUsage(ctx, sessionID); err != nil </span><span class="cov0" title="0">{
                                wm.logger.Warn().Err(err).Str("session_id", sessionID).Msg("Failed to update disk usage")
                        }</span>
                }
        }

        <span class="cov7" title="10">return nil</span>
}

func (wm *WorkspaceManager) getTotalDiskUsage() int64 <span class="cov9" title="21">{
        var total int64
        for _, usage := range wm.diskUsage </span><span class="cov10" title="26">{
                total += usage
        }</span>
        <span class="cov9" title="21">return total</span>
}

// GetStats returns workspace statistics
func (wm *WorkspaceManager) GetStats() *WorkspaceStats <span class="cov6" title="7">{
        wm.mutex.RLock()
        defer wm.mutex.RUnlock()

        return &amp;WorkspaceStats{
                TotalSessions:   len(wm.diskUsage),
                TotalDiskUsage:  wm.getTotalDiskUsage(),
                TotalDiskLimit:  wm.totalMaxSize,
                PerSessionLimit: wm.maxSizePerSession,
                SandboxEnabled:  wm.sandboxEnabled,
        }
}</span>

// WorkspaceStats provides statistics about workspace usage
type WorkspaceStats struct {
        TotalSessions   int   `json:"total_sessions"`
        TotalDiskUsage  int64 `json:"total_disk_usage_bytes"`
        TotalDiskLimit  int64 `json:"total_disk_limit_bytes"`
        PerSessionLimit int64 `json:"per_session_limit_bytes"`
        SandboxEnabled  bool  `json:"sandbox_enabled"`
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
