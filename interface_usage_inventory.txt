pkg/mcp/validation/chains/composite.go:func (c *CompositeValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/chains/composite.go:func (w *conditionalValidatorWrapper) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/chains/composite.go:func (p *ParallelValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/client_factory.go:func (a *llmClientAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/client_factory.go:func (n *noOpAIAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/validation/migration.go:func ConvertBuildValidationResult(oldResult interface{}) *core.ValidationResult {
pkg/mcp/validation/migration.go:	case map[string]interface{}:
pkg/mcp/validation/migration.go:		if errors, ok := v["errors"].([]interface{}); ok {
pkg/mcp/validation/migration.go:				if errMap, ok := errInterface.(map[string]interface{}); ok {
pkg/mcp/validation/migration.go:func convertLegacyError(errData map[string]interface{}) *core.ValidationError {
pkg/mcp/validation/migration.go:func ValidateWithLegacyCompatibility(validationType string, data interface{}, options map[string]interface{}) *core.ValidationResult {
pkg/mcp/validation/migration.go:func convertLegacyOptions(legacy map[string]interface{}) *core.ValidationOptions {
pkg/mcp/validation/migration.go:func GetMigrationStatus(packagePath string) map[string]interface{} {
pkg/mcp/validation/migration.go:	return map[string]interface{}{
pkg/mcp/validation/doc.go://	func (m *MyValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/deployment.go:func (d *DeploymentValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/deployment.go:	case map[string]interface{}:
pkg/mcp/validation/validators/deployment.go:	Metadata     map[string]interface{} `json:"metadata"`
pkg/mcp/validation/validators/deployment.go:	HealthResult        interface{}            `json:"health_result"`
pkg/mcp/validation/validators/deployment.go:	Metadata            map[string]interface{} `json:"metadata"`
pkg/mcp/validation/validators/deployment.go:func (d *DeploymentValidator) validateDeploymentData(data map[string]interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/deployment.go:func (d *DeploymentValidator) validateTimeout(timeout interface{}, field string, result *core.ValidationResult) {
pkg/mcp/validation/validators/deployment.go:func ValidateDeploymentConfig(config map[string]interface{}) *core.ValidationResult {
pkg/mcp/validation/validators/context.go:func (c *ContextValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/context.go:func (c *ContextValidator) validateDockerfileContext(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/context.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:			if instructions, ok := m["instructions"].([]interface{}); ok {
pkg/mcp/validation/validators/context.go:					if instMap, ok := inst.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:func (c *ContextValidator) validateBuildFiles(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/context.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:func (c *ContextValidator) validateCopyOperations(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/context.go:	operations, ok := data.([]map[string]interface{})
pkg/mcp/validation/validators/context.go:func (c *ContextValidator) autoDetectAndValidate(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/context.go:	case map[string]interface{}:
pkg/mcp/validation/validators/context.go:func getStringFromMap(m map[string]interface{}, key string) string {
pkg/mcp/validation/validators/context.go:func getIntFromMap(m map[string]interface{}, key string) int {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) validateIP(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) validatePort(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) validateHostname(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) validateCIDR(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) validateMACAddress(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/network.go:func (n *NetworkValidator) autoDetectAndValidate(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/image.go:func (i *ImageValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/image.go:func (i *ImageValidator) validateImageReference(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/image.go:func (i *ImageValidator) validateImageList(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/image.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/image.go:			Context: map[string]interface{}{
pkg/mcp/validation/validators/image.go:func (i *ImageValidator) validateBaseImage(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/image.go:	case map[string]interface{}:
pkg/mcp/validation/validators/image.go:func (i *ImageValidator) autoDetectAndValidate(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/image.go:	case map[string]interface{}:
pkg/mcp/validation/validators/image.go:func getImageStringFromMap(m map[string]interface{}, key string) string {
pkg/mcp/validation/validators/image.go:func getImageIntFromMap(m map[string]interface{}, key string) int {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/kubernetes.go:	case map[string]interface{}:
pkg/mcp/validation/validators/kubernetes.go:	case []map[string]interface{}:
pkg/mcp/validation/validators/kubernetes.go:	Metadata   map[string]interface{} `json:"metadata"`
pkg/mcp/validation/validators/kubernetes.go:	Spec       map[string]interface{} `json:"spec"`
pkg/mcp/validation/validators/kubernetes.go:	Data       map[string]interface{} `json:"data,omitempty"`
pkg/mcp/validation/validators/kubernetes.go:	Raw        map[string]interface{} `json:"raw,omitempty"` // Full manifest data
pkg/mcp/validation/validators/kubernetes.go:	var manifest map[string]interface{}
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateManifest(manifest map[string]interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateManifestWithIndex(manifest map[string]interface{}, index int, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/kubernetes.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if spec, ok := manifest["spec"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateRequiredFields(manifest map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateMetadata(metadata map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if labelsMap, ok := labels.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if annotationsMap, ok := annotations.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateLabels(labels map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateAnnotations(annotations map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateSpec(kind string, spec map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateDeploymentSpec(spec map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if selectorMap, ok := selector.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateServiceSpec(spec map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if portsList, ok := ports.([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if portMap, ok := port.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateIngressSpec(spec map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validatePodSpec(spec map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if containersList, ok := containers.([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateContainer(container map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateSelector(selector map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if labelsMap, ok := matchLabels.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateServicePort(port map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) performSecurityValidation(manifest map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if spec, ok := manifest["spec"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:			if containers, ok := spec["containers"].([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateContainerSecurity(container map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:		if secCtx, ok := securityContext.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateResourceSpecific(manifest map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateConfigMapData(manifest map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/kubernetes.go:func (k *KubernetesValidator) validateSecretData(manifest map[string]interface{}, fieldPrefix string, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateSecrets(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/security.go:	case map[string]interface{}:
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validatePermissions(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:	case map[string]interface{}:
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateSensitiveData(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateCompliance(data interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateMapForSecrets(m map[string]interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:		if nestedMap, ok := value.(map[string]interface{}); ok {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validatePCICompliance(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateHIPAACompliance(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security.go:func (s *SecurityValidator) validateGDPRCompliance(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/security_scan.go:func (s *SecurityScanValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/security_scan.go:	case map[string]interface{}:
pkg/mcp/validation/validators/security_scan.go:	ScanContext       map[string]interface{} `json:"scan_context"`
pkg/mcp/validation/validators/security_scan.go:	Metadata         map[string]interface{} `json:"metadata"`
pkg/mcp/validation/validators/security_scan.go:func (s *SecurityScanValidator) validateScanData(data map[string]interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/security_scan.go:func ValidateSecretScanArgs(args interface{}) *core.ValidationResult {
pkg/mcp/validation/validators/security_scan.go:func ValidateImageScanArgs(args interface{}) *core.ValidationResult {
pkg/mcp/validation/validators/security_scan.go:func ValidateSecurityScanResult(result interface{}) *core.ValidationResult {
pkg/mcp/validation/validators/base.go:	config            map[string]interface{}
pkg/mcp/validation/validators/base.go:		config:         make(map[string]interface{}),
pkg/mcp/validation/validators/base.go:func (b *BaseValidatorImpl) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/base.go:			Context:          make(map[string]interface{}),
pkg/mcp/validation/validators/base.go:func (b *BaseValidatorImpl) Configure(config map[string]interface{}) error {
pkg/mcp/validation/validators/base.go:		b.config = make(map[string]interface{})
pkg/mcp/validation/validators/base.go:func (b *BaseValidatorImpl) GetConfiguration() map[string]interface{} {
pkg/mcp/validation/validators/base.go:	result := make(map[string]interface{})
pkg/mcp/validation/validators/base.go:func (a *AlwaysFailValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/docker.go:func (d *DockerfileValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/docker.go:			Context:          make(map[string]interface{}),
pkg/mcp/validation/validators/docker.go:func (d *DockerImageValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) validateEmail(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) validateURL(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) validateJSON(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/format.go:	var jsonData interface{}
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) validateYAML(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/format.go:	var yamlData interface{}
pkg/mcp/validation/validators/format.go:func (f *FormatValidator) autoDetectAndValidate(data interface{}, result *core.ValidationResult) {
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) Validate(ctx context.Context, data interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/validation/validators/health.go:	case map[string]interface{}:
pkg/mcp/validation/validators/health.go:	Metadata     map[string]interface{} `json:"metadata"`
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) validateHealthData(data map[string]interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/health.go:	if pods, ok := data["pods"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:	if services, ok := data["services"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) validatePods(pods []interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/health.go:		if podMap, ok := pod.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:			if containers, ok := podMap["containers"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) validateContainers(containers []interface{}, podIndex int, result *core.ValidationResult) {
pkg/mcp/validation/validators/health.go:		if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) validateServices(services []interface{}, result *core.ValidationResult, options *core.ValidationOptions) {
pkg/mcp/validation/validators/health.go:		if serviceMap, ok := service.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:	metrics := make(map[string]interface{})
pkg/mcp/validation/validators/health.go:func (h *HealthValidator) calculateRiskLevel(metrics map[string]interface{}) string {
pkg/mcp/core/interfaces.go:	Execute(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	Validate(ctx context.Context, args interface{}) error
pkg/mcp/core/interfaces.go:	Input       map[string]interface{} `json:"input"`
pkg/mcp/core/interfaces.go:	Output      map[string]interface{} `json:"output"`
pkg/mcp/core/interfaces.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/core/interfaces.go:	ExecuteTool(ctx context.Context, toolName string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	ValidateToolArgs(toolName string, args interface{}) error
pkg/mcp/core/interfaces.go:	Metadata map[string]interface{} `json:"metadata"`
pkg/mcp/core/interfaces.go:	Params map[string]interface{} `json:"params"`
pkg/mcp/core/interfaces.go:	Result interface{} `json:"result,omitempty"`
pkg/mcp/core/interfaces.go:	Data    interface{} `json:"data,omitempty"`
pkg/mcp/core/interfaces.go:	Metadata  map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/core/interfaces.go:	GetLogger() interface{} // Returns the logger instance
pkg/mcp/core/interfaces.go:	AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error)
pkg/mcp/core/interfaces.go:	AllAttempts     []interface{} `json:"all_attempts"`
pkg/mcp/core/interfaces.go:	ShareContext(ctx context.Context, sessionID string, contextType string, data interface{}) error
pkg/mcp/core/interfaces.go:	GetSharedContext(ctx context.Context, sessionID string, contextType string) (interface{}, error)
pkg/mcp/core/interfaces.go:	BuildImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	PushImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	PullImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	TagImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	GenerateManifests(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	DeployKubernetes(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	CheckHealth(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	AnalyzeRepository(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	ValidateDockerfile(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	ScanSecurity(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	ScanSecrets(ctx context.Context, sessionID string, args interface{}) (interface{}, error)
pkg/mcp/core/interfaces.go:	GetSession(sessionID string) (interface{}, error)
pkg/mcp/core/interfaces.go:	GetOrCreateSession(sessionID string) (interface{}, error)
pkg/mcp/core/interfaces.go:	CreateSession(userID string) (interface{}, error)
pkg/mcp/core/interfaces.go:	ListSessions(ctx context.Context, filter map[string]interface{}) ([]interface{}, error)
pkg/mcp/core/interfaces.go:	PrepareForRetry(ctx context.Context, fixAttempt interface{}) error
pkg/mcp/core/interfaces.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/core/interfaces.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/scan/api_key_scanner.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/scan/api_key_scanner.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/scan/scan_image_security_atomic.go:	pipelineAdapter interface{}
pkg/mcp/internal/scan/scan_image_security_atomic.go:	sessionManager  interface{}
pkg/mcp/internal/scan/scan_image_security_atomic.go:func NewAtomicScanImageSecurityTool(adapter interface{}, sessionManager interface{}, logger zerolog.Logger) *AtomicScanImageSecurityTool {
pkg/mcp/internal/scan/scan_image_security_atomic.go:func (t *AtomicScanImageSecurityTool) SetAnalyzer(analyzer interface{}) {
pkg/mcp/internal/scan/scan_image_security_atomic.go:func (t *AtomicScanImageSecurityTool) performSecurityScan(ctx context.Context, args AtomicScanImageSecurityArgs, reporter interface{}) (*AtomicScanImageSecurityResult, error) {
pkg/mcp/internal/scan/scan_image_security_atomic.go:	response.ScanContext = map[string]interface{}{
pkg/mcp/internal/scan/scan_image_security_atomic.go:		Context: map[string]interface{}{
pkg/mcp/internal/scan/scan_image_security_atomic.go:func (t *AtomicScanImageSecurityTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/scan/scan_image_security_atomic.go:func (t *AtomicScanImageSecurityTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/scan/scan_image_security_atomic.go:	securityData := map[string]interface{}{
pkg/mcp/internal/scan/secrets_types.go:	ScanContext map[string]interface{} `json:"scan_context"`
pkg/mcp/internal/scan/common.go:	Metadata   map[string]interface{}
pkg/mcp/internal/scan/common.go:	Metadata    map[string]interface{}
pkg/mcp/internal/scan/common.go:		Summary:        make(map[string]interface{}),
pkg/mcp/internal/scan/common.go:	Summary        map[string]interface{}
pkg/mcp/internal/scan/common.go:func (r *ScannerRegistry) generateSummary(result *CombinedScanResult) map[string]interface{} {
pkg/mcp/internal/scan/common.go:	summary := map[string]interface{}{
pkg/mcp/internal/scan/regex_scanner.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/scan/regex_scanner.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/scan/regex_scanner.go:						Metadata: map[string]interface{}{
pkg/mcp/internal/scan/secret_scanner.go:func (s *FileSecretScanner) PerformSecretScan(scanPath string, filePatterns, excludePatterns []string, reporter interface{}) ([]ScannedSecret, []FileSecretScanResult, int, error) {
pkg/mcp/internal/scan/validators_unified.go:func (t *AtomicScanSecretsTool) ValidateUnified(ctx context.Context, args interface{}) (*core.ValidationResult, error) {
pkg/mcp/internal/scan/validators_unified.go:func (t *AtomicScanImageSecurityTool) ValidateUnified(ctx context.Context, args interface{}) (*core.ValidationResult, error) {
pkg/mcp/internal/scan/validators_unified.go:		Metadata:         make(map[string]interface{}),
pkg/mcp/internal/scan/validators_unified.go:func ValidateSecretScanConfigUnified(config map[string]interface{}) *core.ValidationResult {
pkg/mcp/internal/scan/validators_unified.go:func ValidateImageScanConfigUnified(config map[string]interface{}) *core.ValidationResult {
pkg/mcp/internal/scan/validators_unified.go:func GetSecretScanValidationMetrics(result AtomicScanSecretsResult) map[string]interface{} {
pkg/mcp/internal/scan/validators_unified.go:	metrics := map[string]interface{}{
pkg/mcp/internal/scan/validators_unified.go:func GetImageScanValidationMetrics(result AtomicScanImageSecurityResult) map[string]interface{} {
pkg/mcp/internal/scan/validators_unified.go:	metrics := map[string]interface{}{
pkg/mcp/internal/scan/validators_unified.go:func ValidateScanPipeline(config map[string]interface{}) *core.ValidationResult {
pkg/mcp/internal/scan/validators_unified.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/scan/result_processor.go:func (rp *ResultProcessor) GenerateScanContext(secrets []ScannedSecret, fileResults []FileSecretScanResult, args AtomicScanSecretsArgs) map[string]interface{} {
pkg/mcp/internal/scan/result_processor.go:	context := make(map[string]interface{})
pkg/mcp/internal/scan/result_processor.go:	context["scan_configuration"] = map[string]interface{}{
pkg/mcp/internal/scan/certificate_scanner.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/scan/certificate_scanner.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/scan/certificate_scanner.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/scan/scan_secrets_tool.go:	pipelineAdapter interface{}
pkg/mcp/internal/scan/scan_secrets_tool.go:	sessionManager  interface{}
pkg/mcp/internal/scan/scan_secrets_tool.go:func newAtomicScanSecretsToolImpl(adapter interface{}, sessionManager interface{}, logger zerolog.Logger) *AtomicScanSecretsTool {
pkg/mcp/internal/scan/scan_secrets_tool.go:				ScanContext:         make(map[string]interface{}),
pkg/mcp/internal/scan/scan_secrets_tool.go:func (t *AtomicScanSecretsTool) executeWithProgress(ctx context.Context, args AtomicScanSecretsArgs, startTime time.Time, reporter interface{}) (*AtomicScanSecretsResult, error) {
pkg/mcp/internal/scan/scan_secrets_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/scan/scan_secrets_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/scan/scan_secrets_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/scan/scan_secrets_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/scan/scan_secrets_tool.go:func (t *AtomicScanSecretsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/scan/scan_secrets_tool.go:func (t *AtomicScanSecretsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/scan/scan_secrets_atomic.go:func NewAtomicScanSecretsTool(adapter interface{}, sessionManager interface{}, logger zerolog.Logger) *AtomicScanSecretsTool {
pkg/mcp/internal/scan/scan_secrets_atomic.go:func ExecuteScanSecrets(ctx context.Context, args AtomicScanSecretsArgs, adapter interface{}, sessionManager interface{}, logger zerolog.Logger) (*AtomicScanSecretsResult, error) {
pkg/mcp/internal/scan/scan_secrets_atomic.go:func ExecuteWithContext(serverCtx *server.Context, args AtomicScanSecretsArgs, adapter interface{}, sessionManager interface{}, logger zerolog.Logger) (*AtomicScanSecretsResult, error) {
pkg/mcp/internal/scan/scan_security_types.go:	ScanContext map[string]interface{} `json:"scan_context"`
pkg/mcp/errors/errors.go:	Context     map[string]interface{}
pkg/mcp/errors/errors.go:func (e *MCPError) WithContext(key string, value interface{}) *MCPError {
pkg/mcp/errors/errors.go:		e.Context = make(map[string]interface{})
pkg/mcp/errors/errors.go:		Context:  make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Newf(module string, category ErrorCategory, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:		Context:  make(map[string]interface{}),
pkg/mcp/errors/errors.go:			Context:     make(map[string]interface{}),
pkg/mcp/errors/errors.go:		Context:  make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Wrapf(err error, module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:func Validationf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:		Context:   make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Networkf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:		Context:   make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Internalf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:func Resourcef(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:		Context:   make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Timeoutf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:		Context:   make(map[string]interface{}),
pkg/mcp/errors/errors.go:func Configf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/errors/errors.go:func Authf(module, format string, args ...interface{}) *MCPError {
pkg/mcp/internal/analyze/analyze_error_handling_test.go:		invalidArgs := []interface{}{
pkg/mcp/internal/analyze/analyze_error_handling_test.go:			map[string]interface{}{"key": "value"},
pkg/mcp/internal/analyze/analyze_error_handling_test.go:		invalidArgs := []interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) performAnalysis(ctx context.Context, args AtomicAnalyzeRepositoryArgs, reporter interface{}) (*AtomicAnalysisResult, error) {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if resumedFrom, ok := session.Metadata["resumed_from"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			return result, mcperror.NewWithData(mcperror.CodeAnalysisRequired, "Failed to clone repository", map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			scanSummary := scanSummaryData.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:						if deps, ok := scanSummary["dependencies"].([]interface{}); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		return result, mcperror.NewWithData(mcperror.CodeAnalysisRequired, "Failed to analyze repository", map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				oldSessionInfo := map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:					newSession.Metadata = make(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	session.Metadata["scan_summary"] = map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		return mcperror.NewWithData("invalid_arguments", "Invalid argument type for atomic_analyze_repository", map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		return mcperror.NewWithData("missing_required_field", "RepoURL is required", map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			return nil, mcperror.NewWithData("invalid_arguments", "Invalid argument type for atomic_analyze_repository", map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) convertFromOrchestrationArgs(args interface{}) *AtomicAnalyzeRepositoryArgs {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	case interface{}:
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) extractFieldsFromInterface(v interface{}) *AtomicAnalyzeRepositoryArgs {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func (t *AtomicAnalyzeRepositoryTool) convertViaJSON(v interface{}) *AtomicAnalyzeRepositoryArgs {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func getIntFromSummary(summary map[string]interface{}, key string) int {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func getInt64FromSummary(summary map[string]interface{}, key string) int64 {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func getFloat64FromSummary(summary map[string]interface{}, key string) float64 {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func getBoolFromSummary(summary map[string]interface{}, key string) bool {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:func getStringSliceFromSummary(summary map[string]interface{}, key string) []string {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if slice, ok := val.([]interface{}); ok {
pkg/mcp/internal/analyze/repository_analyzer_core.go:			Metadata:      make(map[string]interface{}),
pkg/mcp/internal/analyze/repository_analyzer_core.go:	metadata := map[string]interface{}{
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) getSessionState(args GenerateDockerfileArgs) (map[string]interface{}, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:	sessionMap := make(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:	sessionMap["repository_analysis"] = make(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) selectTemplateFromSession(args GenerateDockerfileArgs, session map[string]interface{}) string {
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) autoSelectTemplate(session map[string]interface{}) string {
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, ok := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) handleDryRun(templateName string, args GenerateDockerfileArgs, session map[string]interface{}, response *GenerateDockerfileResult) (*GenerateDockerfileResult, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, _ := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) generateDockerfileContent(templateName string, args GenerateDockerfileArgs, session map[string]interface{}, response *GenerateDockerfileResult) error {
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, _ := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) generateRichContext(repositoryData map[string]interface{}, content string, args GenerateDockerfileArgs, response *GenerateDockerfileResult) {
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) extractDependencies(repositoryData map[string]interface{}) []string {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if depMap, ok := repositoryData["dependencies"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) extractConfigFiles(repositoryData map[string]interface{}) []string {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if fileList, ok := repositoryData["config_files"].([]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) previewDockerfile(templateName string, args GenerateDockerfileArgs, repoAnalysis map[string]interface{}) (string, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) generateDockerfile(templateName, dockerfilePath string, args GenerateDockerfileArgs, repoAnalysis map[string]interface{}) (string, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:				Input:       map[string]interface{}{"session_id": "session-123"},
pkg/mcp/internal/analyze/generate_dockerfile.go:				Output:      map[string]interface{}{"message": "Dockerfile generated successfully"},
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/analyze/generate_dockerfile.go:		if mapArgs, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:			return fmt.Errorf("invalid argument type: expected GenerateDockerfileArgs or map[string]interface{}")
pkg/mcp/internal/analyze/generate_dockerfile.go:func (t *AtomicGenerateDockerfileTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:		if mapArgs, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:func convertToGenerateDockerfileArgs(args map[string]interface{}) (GenerateDockerfileArgs, error) {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/dockerfile_optimizer.go:func (do *DockerfileOptimizer) ApplyCustomizations(content string, args GenerateDockerfileArgs, repoAnalysis map[string]interface{}) string {
pkg/mcp/internal/analyze/dockerfile_optimizer.go:		Context:     make(map[string]interface{}),
pkg/mcp/internal/analyze/redirect_tool_simple_test.go:	args := map[string]interface{}{
pkg/mcp/internal/analyze/redirect_tool_simple_test.go:		args        interface{}
pkg/mcp/internal/analyze/redirect_tool_simple_test.go:			args:        map[string]interface{}{},
pkg/mcp/internal/analyze/redirect_tool_simple_test.go:			args: map[string]interface{}{
pkg/mcp/internal/analyze/common_test.go:		Structure: map[string]interface{}{
pkg/mcp/internal/analyze/common.go:	Structure map[string]interface{} `json:"structure"`
pkg/mcp/internal/analyze/common.go:	Metadata   map[string]interface{}
pkg/mcp/internal/analyze/common.go:	Metadata    map[string]interface{}
pkg/mcp/internal/analyze/common.go:	Value       interface{}
pkg/mcp/internal/analyze/common.go:		Summary:       make(map[string]interface{}),
pkg/mcp/internal/analyze/common.go:	Summary       map[string]interface{}
pkg/mcp/internal/analyze/common.go:func (o *AnalysisOrchestrator) generateSummary(result *CombinedAnalysisResult) map[string]interface{} {
pkg/mcp/internal/analyze/common.go:	summary := map[string]interface{}{
pkg/mcp/internal/analyze/language_analyzer.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/analyze/language_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/language_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/language_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/language_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/language_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer_test.go:		Structure: map[string]interface{}{},
pkg/mcp/internal/analyze/configuration_analyzer_test.go:		Structure: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer_test.go:		Structure: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/analyze/build_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:			Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/build_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_simple.go:func (t *AnalyzeRepositoryTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/analyze/analyze_simple.go:	case map[string]interface{}:
pkg/mcp/internal/analyze/analyze_simple.go:func (t *AnalyzeRepositoryTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/analyze/analyze_simple.go:	case map[string]interface{}:
pkg/mcp/internal/analyze/analyze_simple.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_simple.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_simple.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_simple.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/analyzer.go:func (c *CallerAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/analyze/analyzer.go:func (s *StubAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/analyze/analyzer.go:func (f *AnalyzerFactory) CreateAnalyzer() interface{} {
pkg/mcp/internal/analyze/analyzer.go:func CreateAnalyzerFromEnv(logger zerolog.Logger) interface{} {
pkg/mcp/internal/analyze/analyzer.go:func CreateAnalyzerFromConfig(config interface{}, logger zerolog.Logger) interface{} {
pkg/mcp/internal/analyze/types.go:	Validation   interface{} `json:"validation,omitempty"`
pkg/mcp/internal/context/integration.go:func (a *AIAwareAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/context/integration.go:	AdditionalContext map[string]interface{}
pkg/mcp/internal/context/integration.go:func (a *AIAwareAnalyzer) AnalyzeError(ctx context.Context, err error, contextInfo map[string]interface{}) (*ErrorAnalysis, error) {
pkg/mcp/internal/context/integration.go:		AdditionalContext: make(map[string]interface{}),
pkg/mcp/internal/context/integration.go:	analysisRecord := map[string]interface{}{
pkg/mcp/internal/context/integration.go:		"metadata": map[string]interface{}{
pkg/mcp/internal/context/integration.go:func (i *AIContextIntegration) CreateContextAwareTools(toolFactory interface{}) error {
pkg/mcp/internal/context/integration.go:		if buildData, ok := buildCtx.Data["docker_build"].(map[string]interface{}); ok {
pkg/mcp/internal/context/enrichers.go:func (e *InsightEnricher) generateCrossToolInsights(data *ComprehensiveContext) []map[string]interface{} {
pkg/mcp/internal/context/enrichers.go:	insights := make([]map[string]interface{}, 0)
pkg/mcp/internal/context/enrichers.go:			if buildImages, ok := buildData["docker_build"].(map[string]interface{})["images_built"].(int); ok {
pkg/mcp/internal/context/enrichers.go:				if deployManifests, ok := deployData["kubernetes"].(map[string]interface{})["manifests_count"].(int); ok {
pkg/mcp/internal/context/enrichers.go:						insights = append(insights, map[string]interface{}{
pkg/mcp/internal/context/enrichers.go:		if secData, ok := secContext.Data["security_scans"].(map[string]interface{}); ok {
pkg/mcp/internal/context/enrichers.go:		if perfData, ok := perfContext.Data["performance_metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/context/providers.go:		Data:       make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		Metadata:   make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:	// Note: sessionState is interface{}, need to handle accordingly
pkg/mcp/internal/context/providers.go:			data.Data["docker_build"] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:		recentBuilds := make([]map[string]interface{}, 0)
pkg/mcp/internal/context/providers.go:				recentBuilds = append(recentBuilds, map[string]interface{}{
pkg/mcp/internal/context/providers.go:		Data:       make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		Metadata:   make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:			data.Data["kubernetes"] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:		deployments := make([]map[string]interface{}, 0)
pkg/mcp/internal/context/providers.go:				deployments = append(deployments, map[string]interface{}{
pkg/mcp/internal/context/providers.go:		Data:       make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		Metadata:   make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:			data.Data["security_scans"] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:		Data:       make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		Metadata:   make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		data.Data["resource_usage"] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:		data.Data["performance_metrics"] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:		Data:       make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:		Metadata:   make(map[string]interface{}),
pkg/mcp/internal/context/providers.go:	metricsData := make(map[string]interface{})
pkg/mcp/internal/context/providers.go:		metricsData[stateType] = map[string]interface{}{
pkg/mcp/internal/context/providers.go:	recentChanges := make([]map[string]interface{}, 0)
pkg/mcp/internal/context/providers.go:				recentChanges = append(recentChanges, map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	ValidationContext map[string]interface{} `json:"validation_context"`
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:func (t *AtomicValidateDockerfileTool) performValidation(ctx context.Context, args AtomicValidateDockerfileArgs, reporter interface{}) (*AtomicValidateDockerfileResult, error) {
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:		ValidationContext:   make(map[string]interface{}),
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:func (r *AtomicValidateDockerfileResult) CreateRemediationPlan() interface{} {
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	return map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:func (r *AtomicValidateDockerfileResult) GetAlternativeStrategies() interface{} {
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	return []map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:func (t *AtomicValidateDockerfileTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:func (t *AtomicValidateDockerfileTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/analyze/dependency_analyzer.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/analyze/dependency_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/dependency_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/dependency_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/dependency_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/dependency_analyzer.go:						Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/dependency_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository.go:func (t *AnalyzeRepositoryRedirectTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/analyze/analyze_repository.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository.go:		return nil, fmt.Errorf("invalid arguments: expected map[string]interface{}, got %T", args)
pkg/mcp/internal/analyze/analyze_repository.go:		return map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository.go:	return map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository.go:func (t *AnalyzeRepositoryRedirectTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/analyze/analyze_repository.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository.go:		return fmt.Errorf("invalid arguments: expected map[string]interface{}, got %T", args)
pkg/mcp/internal/analyze/analyze_repository.go:				Input: map[string]interface{}{
pkg/mcp/internal/analyze/analyze_repository.go:				Output: map[string]interface{}{
pkg/mcp/internal/analyze/template_selector.go:func (ts *TemplateSelector) SelectTemplate(repoAnalysis map[string]interface{}) (string, error) {
pkg/mcp/internal/analyze/configuration_analyzer.go:		Metadata: make(map[string]interface{}),
pkg/mcp/internal/analyze/configuration_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer.go:			Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer.go:						Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer.go:			Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer.go:					Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/configuration_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/analyze/clone_test.go:		Structure: map[string]interface{}{
pkg/mcp/internal/context/ai_context_aggregator.go:	Filters        map[string]interface{}
pkg/mcp/internal/context/ai_context_aggregator.go:	Data       map[string]interface{} `json:"data"`
pkg/mcp/internal/context/ai_context_aggregator.go:	Metadata   map[string]interface{} `json:"metadata"`
pkg/mcp/internal/context/ai_context_aggregator.go:	Metadata         map[string]interface{}  `json:"metadata"`
pkg/mcp/internal/context/ai_context_aggregator.go:	SessionState   interface{}            `json:"session_state"`
pkg/mcp/internal/context/ai_context_aggregator.go:	WorkflowStates map[string]interface{} `json:"workflow_states"`
pkg/mcp/internal/context/ai_context_aggregator.go:	ToolStates     map[string]interface{} `json:"tool_states"`
pkg/mcp/internal/context/ai_context_aggregator.go:	GlobalState    map[string]interface{} `json:"global_state"`
pkg/mcp/internal/context/ai_context_aggregator.go:	Data      map[string]interface{} `json:"data"`
pkg/mcp/internal/context/ai_context_aggregator.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/context/ai_context_aggregator.go:	Data        map[string]interface{} `json:"data"`
pkg/mcp/internal/context/ai_context_aggregator.go:		Metadata:      make(map[string]interface{}),
pkg/mcp/internal/context/ai_context_aggregator.go:		WorkflowStates: make(map[string]interface{}),
pkg/mcp/internal/context/ai_context_aggregator.go:		ToolStates:     make(map[string]interface{}),
pkg/mcp/internal/context/ai_context_aggregator.go:		GlobalState:    make(map[string]interface{}),
pkg/mcp/internal/context/ai_context_aggregator.go:				Data: map[string]interface{}{
pkg/mcp/internal/context/ai_context_aggregator.go:func (a *AIContextAggregator) GetAIContext(ctx context.Context, sessionID string) (map[string]interface{}, error) {
pkg/mcp/internal/context/ai_context_aggregator.go:	return map[string]interface{}{
pkg/mcp/internal/runtime/validator.go:	Validate(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:	ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:	CustomParams map[string]interface{}
pkg/mcp/internal/runtime/validator.go:	Context  map[string]interface{}
pkg/mcp/internal/runtime/validator.go:	Parameters       map[string]interface{}
pkg/mcp/internal/runtime/validator.go:func (v *BaseValidatorImpl) ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:		Context:  make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:			Parameters:       make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:	Logger     interface{}
pkg/mcp/internal/runtime/validator.go:	Custom     map[string]interface{}
pkg/mcp/internal/runtime/validator.go:		Custom:     make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:func (c *ValidatorChain) Validate(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:		Context:  make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:func (c *ValidatorChain) ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:			ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:				CustomParams: make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:				Context:          make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:		ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:func (r *RuntimeValidatorRegistry) ValidateWithRuntime(ctx context.Context, validatorName string, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:func (r *RuntimeValidatorRegistry) ValidateWithUnified(ctx context.Context, validatorName string, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:		ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:		ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error)
pkg/mcp/internal/runtime/validator.go:func (w *runtimeValidatorWrapper) Validate(ctx context.Context, input interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/internal/runtime/validator.go:				Context:          make(map[string]interface{}),
pkg/mcp/internal/runtime/validator.go:func ValidateRuntime(ctx context.Context, validatorName string, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator.go:func ValidateRuntimeUnified(ctx context.Context, validatorName string, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error) {
pkg/mcp/internal/runtime/registration_helper.go:type UtilityToolFunc[TArgs, TResult any] func(deps interface{}) (func(ctx *server.Context, args *TArgs) (*TResult, error), error)
pkg/mcp/internal/runtime/registration_helper.go:	deps interface{},
pkg/mcp/internal/runtime/registration_helper.go:type ResourceFunc[TArgs any] func(ctx *server.Context, args TArgs) (interface{}, error)
pkg/mcp/internal/runtime/registry_test.go:	executeFunc     func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/runtime/registry_test.go:	validateFunc    func(ctx context.Context, args interface{}) error
pkg/mcp/internal/runtime/registry_test.go:func (m *mockTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/runtime/registry_test.go:func (m *mockTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/runtime/registry_test.go:	properties, ok := inputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	messageField, ok := properties["message"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	countField, ok := properties["count"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	itemsField, ok := properties["items"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	outputProps, ok := outputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	successField, ok := outputProps["success"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:		executeFunc: func(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/runtime/registry_test.go:		executeFunc: func(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/runtime/registry_test.go:		schema   map[string]interface{}
pkg/mcp/internal/runtime/registry_test.go:			schema: map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:				"properties": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:					"items": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:			schema: map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:				"properties": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:					"name": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:			schema:   map[string]interface{}{},
pkg/mcp/internal/runtime/registry_test.go:			schema: map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:	inputSchema := map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:		"properties": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:			"test": map[string]interface{}{
pkg/mcp/internal/runtime/registry_test.go:	var testSchema map[string]interface{}
pkg/mcp/internal/runtime/validator_test.go:	validateFunc func(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error)
pkg/mcp/internal/runtime/validator_test.go:func (m *mockValidator) Validate(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator_test.go:		Context:  make(map[string]interface{}),
pkg/mcp/internal/runtime/validator_test.go:func (m *mockValidator) ValidateUnified(ctx context.Context, input interface{}, options *core.ValidationOptions) (*core.ValidationResult, error) {
pkg/mcp/internal/runtime/validator_test.go:		CustomParams: make(map[string]interface{}),
pkg/mcp/internal/runtime/validator_test.go:		Context: map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:		Context: map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:		validateFunc: func(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator_test.go:				Context: map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:		validateFunc: func(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/validator_test.go:				Context: map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:		CustomParams: map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/validator_test.go:		Context: map[string]interface{}{
pkg/mcp/internal/runtime/progress.go:	logger  interface{} // zerolog.Logger
pkg/mcp/internal/runtime/progress.go:func NewSimpleProgressReporter(stages []ProgressStage, logger interface{}) *SimpleProgressReporter {
pkg/mcp/internal/runtime/auto_registration.go:// Uses interface{} to avoid import cycles - the actual tools implement mcptypes.Tool
pkg/mcp/internal/runtime/auto_registration.go:var generatedToolRegistry = map[string]func() interface{}{
pkg/mcp/internal/runtime/auto_registration.go:	"build_image":                 func() interface{} { return &build.BuildImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_build_image":          func() interface{} { return &build.AtomicBuildImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_pull_image":           func() interface{} { return &build.AtomicPullImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"push_image":                  func() interface{} { return &build.PushImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_push_image":           func() interface{} { return &build.AtomicPushImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_tag_image":            func() interface{} { return &build.AtomicTagImageTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_check_health":         func() interface{} { return &deploy.AtomicCheckHealthTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_deploy_kubernetes":    func() interface{} { return &deploy.AtomicDeployKubernetesTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"generate_manifests":          func() interface{} { return &deploy.GenerateManifestsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_generate_manifests":   func() interface{} { return &deploy.AtomicGenerateManifestsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"validate_deployment":         func() interface{} { return &deploy.AtomicValidateDeploymentTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_scan_image_security":  func() interface{} { return &scan.AtomicScanImageSecurityTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_scan_secrets":         func() interface{} { return &scan.AtomicScanSecretsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"analyze_repository_redirect": func() interface{} { return &analyze.AnalyzeRepositoryRedirectTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_analyze_repository":   func() interface{} { return &analyze.AtomicAnalyzeRepositoryTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"analyze_repository":          func() interface{} { return &analyze.AnalyzeRepositoryTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"generate_dockerfile":         func() interface{} { return &analyze.AtomicGenerateDockerfileTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"atomic_validate_dockerfile":  func() interface{} { return &analyze.AtomicValidateDockerfileTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"delete_session":              func() interface{} { return &session.DeleteSessionTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"list_sessions":               func() interface{} { return &session.ListSessionsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"add_session_label":           func() interface{} { return &session.AddSessionLabelTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"remove_session_label":        func() interface{} { return &session.RemoveSessionLabelTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"update_session_labels":       func() interface{} { return &session.UpdateSessionLabelsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"list_session_labels":         func() interface{} { return &session.ListSessionLabelsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"check_registry_health":       func() interface{} { return &server.CheckRegistryHealthTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"get_job_status":              func() interface{} { return &server.GetJobStatusTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"get_logs":                    func() interface{} { return &server.GetLogsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"get_telemetry_metrics":       func() interface{} { return &server.GetTelemetryMetricsTool{} },
pkg/mcp/internal/runtime/auto_registration.go:	"chat":                        func() interface{} { return &conversation.ChatTool{} },
pkg/mcp/internal/runtime/auto_registration.go:func RegisterAllTools(registry interface{}) error {
pkg/mcp/internal/runtime/auto_registration.go:		Register(name string, factory func() interface{}) error
pkg/mcp/internal/runtime/auto_registration.go:			if err := reg.Register(name, func() interface{} { return tool }); err != nil {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:func (pm *PromptManager) getStringSliceFromMap(m map[string]interface{}, key string, defaultValue []string) []string {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:	if val, ok := m[key].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:		if values, ok := selectedOption.Value.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_test.go:func (m *MockToolExecutor) ExecuteTool(ctx context.Context, toolName string, args interface{}) (interface{}, error) {
pkg/mcp/internal/runtime/conversation/prompt_manager_test.go:	return map[string]interface{}{
pkg/mcp/internal/runtime/conversation/prompt_manager_test.go:func (m *MockToolExecutor) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if analysis, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:				state.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:			if suggestions, ok := analysis["suggestions"].([]interface{}); ok && len(suggestions) > 0 {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if dockerResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					state.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:				if validationData, ok := dockerResult["validation"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					if errors, ok := validationData["errors"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:							if errMap, ok := err.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					if warnings, ok := validationData["warnings"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:							if warnMap, ok := warn.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_forms_test.go:		Values: map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_forms_test.go:		Values:  map[string]interface{}{},
pkg/mcp/internal/runtime/conversation/conversation_forms.go:	DefaultValue interface{}      `json:"default_value,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_forms.go:	Values  map[string]interface{} `json:"values"`
pkg/mcp/internal/runtime/conversation/conversation_forms.go:		Values: make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/conversation_forms.go:func GetFormValue(state *ConversationState, formID, fieldID string, defaultValue interface{}) interface{} {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:				Values: map[string]interface{}{
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:				Values: map[string]interface{}{
pkg/mcp/internal/runtime/conversation/common_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/common_stage.go:	if scanResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:			if k8sManifests, ok := state.SessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:					if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if k8sManifests, ok := state.SessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:				if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/common_stage.go:	if healthResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:func extractVulnerabilities(scanResult map[string]interface{}) []map[string]interface{} {
pkg/mcp/internal/runtime/conversation/common_stage.go:	if vulns, ok := scanResult["vulnerabilities"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		vulnerabilities := make([]map[string]interface{}, 0, len(vulns))
pkg/mcp/internal/runtime/conversation/common_stage.go:			if vuln, ok := v.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:func formatSecurityScanResults(vulnerabilities []map[string]interface{}) string {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:			state.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		var repoAnalysis map[string]interface{}
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if existing, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:			repoAnalysis = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if err := pm.sessionManager.UpdateSession(state.SessionState.SessionID, func(s interface{}) {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		Context:   make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if repoAnalysis, ok := internalSession.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:			if ctx, ok := repoAnalysis["_context"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if history, ok := internalSession.Metadata["conversation_history"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:				if turnMap, ok := turnData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:					if toolCallsData, ok := turnMap["tool_calls"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:							if tcMap, ok := tcData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:								if params, ok := tcMap["parameters"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:	err = pm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:				sess.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Context   map[string]interface{} `json:"conversation_context"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Result     interface{}            `json:"result,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Context  map[string]interface{} `json:"context,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Value       interface{} `json:"value,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	CustomValue interface{} `json:"custom_value,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:	Metadata  map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/internal/runtime/conversation/conversation_state.go:			Metadata:     make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/conversation_state.go:		Context:   make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/conversation_state.go:		cs.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_state.go:	historyData := make([]map[string]interface{}, 0, len(cs.History))
pkg/mcp/internal/runtime/conversation/conversation_state.go:		turnData := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_state.go:			toolCallsData := make([]map[string]interface{}, 0, len(t.ToolCalls))
pkg/mcp/internal/runtime/conversation/conversation_state.go:				tcData := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_state.go:					tcData["error"] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_state.go:			if repoAnalysis, ok := cs.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	Transport          interface{}                        // Accept both core.Transport and internal transport.Transport
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		options := make([]map[string]interface{}, len(finalResponse.Options))
pkg/mcp/internal/runtime/conversation/conversation_handler.go:			options[i] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		result.Progress = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					if repoAnalysis, ok := coreSession.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:						if sessionCtx, ok := repoAnalysis["_context"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	var failureAnalysis map[string]interface{}
pkg/mcp/internal/runtime/conversation/conversation_handler.go:			if resultMap, ok := lastToolCall.Result.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					failureAnalysis, _ = fa.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		Context:   make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		ErrorContext: map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		Context:      make(map[string]interface{}),
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if history, ok := internalSession.Metadata["conversation_history"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if turnMap, ok := turnData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					if toolCallsData, ok := turnMap["tool_calls"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:							if tcMap, ok := tcData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:								if params, ok := tcMap["parameters"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		params := make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	enhancedParams := make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	var failureAnalysisData map[string]interface{}
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if resultMap, ok := lastToolCall.Result.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:						failureAnalysisData, _ = fa.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	err = ch.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				sess.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	redirectParams := make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	redirectParams["error_context"] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	err = ch.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				sess.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:func getIntFromMap(m map[string]interface{}, key string) int {
pkg/mcp/internal/runtime/conversation/build_stage.go:		sessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		sessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		sessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		sessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	var details map[string]interface{}
pkg/mcp/internal/runtime/conversation/build_stage.go:		details, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	var details map[string]interface{}
pkg/mcp/internal/runtime/conversation/build_stage.go:		details, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		state.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/runtime/conversation/build_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/build_stage.go:		var dryResultMap map[string]interface{}
pkg/mcp/internal/runtime/conversation/build_stage.go:		if resultMap, ok := dryResult.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:				dryResultMap, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		state.SessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_types.go:func mapMCPStageToDetailedStage(stage core.ConversationStage, context map[string]interface{}) types.ConversationStage {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:func getK8sManifestsFromMetadata(sessionState *session.SessionState) map[string]interface{} {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if manifests, ok := sessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		sessionState.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		sessionState.Metadata["k8s_manifests"] = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	k8sManifests := sessionState.Metadata["k8s_manifests"].(map[string]interface{})
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	k8sManifests[name] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		params["resources"] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if resultData, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		if manifests, ok := resultData["manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if toolResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/deploy_stage.go:func (pm *PromptManager) checkDeploymentHealth(ctx context.Context, state *ConversationState, deployResult interface{}) *ConversationResponse {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	params := map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:func (a *testSessionManagerAdapter) GetSession(sessionID string) (interface{}, error) {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:func (a *testSessionManagerAdapter) UpdateSession(sessionID string, updater func(interface{})) error {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:	executeFunc  func(ctx context.Context, toolName string, params map[string]interface{}, session interface{}) (interface{}, error)
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:	params   map[string]interface{}
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:	session  interface{}
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:func (m *mockOrchestrator) ExecuteTool(ctx context.Context, toolName string, params map[string]interface{}, session interface{}) (interface{}, error) {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:	return map[string]interface{}{"result": "success"}, nil
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:		err = sessionMgr.UpdateSession("auto-advance-test", func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:					state.Metadata = make(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:				state.Metadata["repo_analysis"] = map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:					"_context": map[string]interface{}{
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:		err = adapter.UpdateSession(updatedSession.SessionID, func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:		err := adapter.UpdateSession("", func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:		err := adapter.UpdateSession("nonexistent-session-id", func(s interface{}) {
pkg/mcp/internal/runtime/conversation/conversation_state_test.go:	newContext := map[string]interface{}{
pkg/mcp/internal/runtime/analyzer.go:	Analyze(ctx context.Context, input interface{}, options AnalysisOptions) (*AnalysisResult, error)
pkg/mcp/internal/runtime/analyzer.go:	CustomParams map[string]interface{}
pkg/mcp/internal/runtime/analyzer.go:	Metrics map[string]interface{}
pkg/mcp/internal/runtime/analyzer.go:	Context  map[string]interface{}
pkg/mcp/internal/runtime/analyzer.go:	Parameters      map[string]interface{}
pkg/mcp/internal/runtime/analyzer.go:		Metrics:         make(map[string]interface{}),
pkg/mcp/internal/runtime/analyzer.go:		Context:         make(map[string]interface{}),
pkg/mcp/internal/runtime/analyzer.go:			Parameters:      make(map[string]interface{}),
pkg/mcp/internal/runtime/analyzer.go:	Custom     map[string]interface{}
pkg/mcp/internal/runtime/analyzer.go:		Custom:     make(map[string]interface{}),
pkg/mcp/internal/runtime/analyzer.go:func (c *AnalyzerChain) Analyze(ctx context.Context, input interface{}, options AnalysisOptions) (*AnalysisResult, error) {
pkg/mcp/internal/runtime/analyzer.go:		Metrics:         make(map[string]interface{}),
pkg/mcp/internal/runtime/analyzer.go:		Context:         make(map[string]interface{}),
pkg/mcp/internal/runtime/registry.go:	Handler      func(ctx context.Context, args json.RawMessage) (interface{}, error)
pkg/mcp/internal/runtime/registry.go:		Handler: func(ctx context.Context, raw json.RawMessage) (interface{}, error) {
pkg/mcp/internal/runtime/registry.go:func sanitizeInvopopSchema(schema *jsonschema.Schema) map[string]interface{} {
pkg/mcp/internal/runtime/registry.go:		return make(map[string]interface{})
pkg/mcp/internal/runtime/registry.go:	var schemaMap map[string]interface{}
pkg/mcp/internal/runtime/registry.go:		return make(map[string]interface{})
pkg/mcp/internal/runtime/registry.go:func containsArrays(schema map[string]interface{}) bool {
pkg/mcp/internal/runtime/registry.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/registry.go:			if propMap, ok := prop.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/registry.go:	ExecuteWithProgress(ctx context.Context, args interface{},
pkg/mcp/internal/runtime/registry.go:		cb ToolProgressCallback) (interface{}, error)
pkg/mcp/internal/runtime/registry.go:func (r *ToolRegistry) ExecuteTool(ctx context.Context, name string, raw json.RawMessage) (interface{}, error) {
pkg/mcp/internal/runtime/atomic_tool_base.go:	Session      interface{}
pkg/mcp/internal/runtime/atomic_tool_base.go:	args interface{},
pkg/mcp/internal/runtime/atomic_tool_base.go:func (base *AtomicToolBase) LogOperationStart(operation string, details map[string]interface{}) {
pkg/mcp/internal/runtime/atomic_tool_base.go:func (base *AtomicToolBase) LogOperationComplete(operation string, success bool, duration interface{}) {
pkg/mcp/internal/runtime/atomic_tool_base.go:			if trackErr := base.sessionManager.TrackError(sessionID, err, map[string]interface{}{
pkg/mcp/internal/runtime/atomic_tool_base.go:			if trackErr := base.sessionManager.TrackError(sessionID, err, map[string]interface{}{
pkg/mcp/internal/runtime/atomic_tool_base.go:func (base *AtomicToolBase) CompleteJob(sessionID, jobID string, result interface{}) error {
pkg/mcp/internal/runtime/atomic_tool_base.go:func (base *AtomicToolBase) UpdateJobStatus(sessionID, jobID string, status session.JobStatus, result interface{}, err error) error {
pkg/mcp/internal/runtime/errors_test.go:		Fields: map[string]interface{}{
pkg/mcp/internal/runtime/tool_analyzer.go:func (t *ToolAnalyzer) Analyze(ctx context.Context, input interface{}, options AnalysisOptions) (*AnalysisResult, error) {
pkg/mcp/internal/runtime/tool_validator.go:func (v *ToolValidator) Validate(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/internal/runtime/tool_validator.go:func (v *ToolValidator) ValidateTool(ctx context.Context, input interface{}, options ValidationOptions) (*ValidationResult, error) {
pkg/mcp/errors/rich/builder.go:func (b *ErrorBuilder) Messagef(format string, args ...interface{}) *ErrorBuilder {
pkg/mcp/errors/rich/builder.go:func (b *ErrorBuilder) Context(key string, value interface{}) *ErrorBuilder {
pkg/mcp/errors/rich/builder.go:func Wrapf(err error, format string, args ...interface{}) *ErrorBuilder {
pkg/mcp/errors/rich/generic.go:func (b *GenericErrorBuilder[TContext]) Messagef(format string, args ...interface{}) *GenericErrorBuilder[TContext] {
pkg/mcp/errors/rich/generic.go:	Parameters    interface{}
pkg/mcp/errors/rich/generic.go:	ResourcesUsed map[string]interface{}
pkg/mcp/errors/rich/generic.go:	FieldValue      interface{}
pkg/mcp/errors/rich/generic.go:	RelatedFields   map[string]interface{}
pkg/mcp/errors/rich/generic.go:	Limits       map[string]interface{}
pkg/mcp/errors/rich/generic.go:func ToolExecutionGenericError(toolName string, params interface{}, cause error) *GenericRichError[ToolExecutionContext] {
pkg/mcp/errors/rich/generic.go:func ValidationGenericError(fieldName string, value interface{}, constraint string) *GenericRichError[ValidationContext] {
pkg/mcp/errors/rich/generic.go:func MergeContexts(contexts ...interface{}) map[string]interface{} {
pkg/mcp/errors/rich/generic.go:	merged := make(map[string]interface{})
pkg/mcp/errors/rich/constructors.go:func ToolExecutionError(toolName string, params interface{}, cause error) *RichError {
pkg/mcp/errors/rich/constructors.go:func ParameterValidationError(param string, value interface{}, constraint string) *RichError {
pkg/mcp/errors/rich/constructors.go:func TypeConversionError(from, to string, value interface{}) *RichError {
pkg/mcp/errors/rich/types.go:type ErrorContext map[string]interface{}
pkg/mcp/errors/rich/types.go:func (e *RichError) WithContext(key string, value interface{}) *RichError {
pkg/mcp/errors/rich/types.go:func (e *RichError) GetContext(key string) (interface{}, bool) {
pkg/mcp/internal/transport/llm_http.go:		requestPayload := map[string]interface{}{
pkg/mcp/internal/core/server_lifecycle.go:	if setter, ok := s.transport.(interface{ SetHandler(interface{}) }); ok {
pkg/mcp/internal/core/gomcp_handlers.go:			Details: map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:				"services": map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:					"session_manager": map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:					"workspace_manager": map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:	var sessionData []map[string]interface{}
pkg/mcp/internal/core/gomcp_handlers.go:		sessionInfo := map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:			Details: map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:				Details: map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:		details := map[string]interface{}{
pkg/mcp/internal/core/gomcp_handlers.go:		Details: map[string]interface{}{
pkg/mcp/internal/core/event_bus.go:	Data      map[string]interface{} `json:"data"`
pkg/mcp/internal/core/event_bus.go:func (eb *EventBus) Publish(eventType EventType, data map[string]interface{}) {
pkg/mcp/internal/core/event_bus.go:func (eb *EventBus) PublishWorkflowEvent(eventType EventType, workflowID, sessionID string, data map[string]interface{}) {
pkg/mcp/internal/core/event_bus.go:		data = make(map[string]interface{})
pkg/mcp/internal/core/event_bus.go:func (eb *EventBus) PublishStageEvent(eventType EventType, stageID, workflowID, sessionID string, data map[string]interface{}) {
pkg/mcp/internal/core/event_bus.go:		data = make(map[string]interface{})
pkg/mcp/internal/core/event_bus.go:func (eb *EventBus) PublishContextEvent(eventType EventType, sessionID, contextType string, data map[string]interface{}) {
pkg/mcp/internal/core/event_bus.go:		data = make(map[string]interface{})
pkg/mcp/internal/core/communication_manager.go:	Parameters    map[string]interface{} `json:"parameters"`
pkg/mcp/internal/core/communication_manager.go:	Context       map[string]interface{} `json:"context"`
pkg/mcp/internal/core/communication_manager.go:	Result        interface{}            `json:"result,omitempty"`
pkg/mcp/internal/core/communication_manager.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/internal/core/communication_manager.go:	Context       map[string]interface{} `json:"context"`
pkg/mcp/internal/core/communication_manager.go:	cm.eventBus.Publish(EventTypeToolRequestStarted, map[string]interface{}{
pkg/mcp/internal/core/communication_manager.go:		cm.eventBus.Publish(EventTypeToolRequestFailed, map[string]interface{}{
pkg/mcp/internal/core/communication_manager.go:	cm.eventBus.Publish(EventTypeToolRequestCompleted, map[string]interface{}{
pkg/mcp/internal/core/communication_manager.go:			Result: map[string]interface{}{
pkg/mcp/internal/core/communication_manager.go:			Metadata:  map[string]interface{}{"retry_count": request.RetryCount},
pkg/mcp/internal/core/request_logger.go:	Metadata    map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/internal/core/request_logger.go:	Metadata  map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/internal/core/request_logger.go:		Metadata:  make(map[string]interface{}),
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) AddTraceEvent(ctx context.Context, event string, metadata map[string]interface{}) {
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) LogWithRequestID(ctx context.Context, level slog.Level, msg string, args ...interface{}) {
pkg/mcp/internal/core/request_logger.go:	logArgs := []interface{}{"request_id", requestID}
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) Info(ctx context.Context, msg string, args ...interface{}) {
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) Error(ctx context.Context, msg string, args ...interface{}) {
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) Warn(ctx context.Context, msg string, args ...interface{}) {
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) Debug(ctx context.Context, msg string, args ...interface{}) {
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) StartOperation(ctx context.Context, operation string, metadata map[string]interface{}) {
pkg/mcp/internal/core/request_logger.go:	metadata := map[string]interface{}{
pkg/mcp/internal/core/request_logger.go:func (rl *RequestLogger) GetMetrics() map[string]interface{} {
pkg/mcp/internal/core/request_logger.go:	return map[string]interface{}{
pkg/mcp/internal/core/schema_regression_test.go:	InputSchema map[string]interface{} `json:"inputSchema"`
pkg/mcp/internal/core/schema_regression_test.go:	ID      interface{} `json:"id"`
pkg/mcp/internal/core/schema_regression_test.go:	Result  interface{} `json:"result,omitempty"`
pkg/mcp/internal/core/schema_regression_test.go:	Data    interface{} `json:"data,omitempty"`
pkg/mcp/internal/core/schema_regression_test.go:	ID      interface{} `json:"id"`
pkg/mcp/internal/core/schema_regression_test.go:	Params  interface{} `json:"params,omitempty"`
pkg/mcp/internal/core/schema_regression_test.go:func (c *MCPClient) SendRequest(method string, params interface{}) error {
pkg/mcp/internal/core/schema_regression_test.go:func (c *MCPClient) SendNotification(method string, params interface{}) error {
pkg/mcp/internal/core/schema_regression_test.go:	req := map[string]interface{}{
pkg/mcp/internal/core/schema_regression_test.go:	initParams := map[string]interface{}{
pkg/mcp/internal/core/schema_regression_test.go:		"capabilities":    map[string]interface{}{},
pkg/mcp/internal/core/schema_regression_test.go:		"clientInfo": map[string]interface{}{
pkg/mcp/internal/core/schema_regression_test.go:	resultMap, ok := resp.Result.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:	toolsArray, ok := toolsInterface.([]interface{})
pkg/mcp/internal/core/schema_regression_test.go:	var schemaValidation interface{}
pkg/mcp/internal/core/schema_regression_test.go:		propertiesMap, ok := properties.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:		properties, ok := tool.InputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:			if sessionIDMap, ok := sessionID.(map[string]interface{}); ok {
pkg/mcp/internal/core/schema_regression_test.go:			var parsedSchema map[string]interface{}
pkg/mcp/internal/core/schema_regression_test.go:				_, isMap := properties.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:func validateArrayFields(t *testing.T, toolName string, schema map[string]interface{}) {
pkg/mcp/internal/core/schema_regression_test.go:		case map[string]interface{}:
pkg/mcp/internal/core/schema_regression_test.go:		case []interface{}:
pkg/mcp/internal/transport/stdio.go:	gomcpManager interface{} // GomcpManager interface for shutdown
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) SendMessage(message interface{}) error {
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) ReceiveMessage() (interface{}, error) {
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) SetGomcpManager(manager interface{}) {
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) RegisterTool(name, description string, handler interface{}) error {
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) HandleToolError(ctx context.Context, toolName string, err error) (interface{}, error) {
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) CreateErrorResponse(id interface{}, code int, message string, data interface{}) map[string]interface{} {
pkg/mcp/internal/transport/stdio.go:		return map[string]interface{}{
pkg/mcp/internal/transport/stdio.go:			"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio.go:func (s *StdioTransport) CreateRecoveryResponse(originalError error, recoverySteps, alternatives []string) interface{} {
pkg/mcp/internal/transport/stdio.go:		return map[string]interface{}{
pkg/mcp/internal/core/conversation_test.go:			Context:      make(map[string]interface{}),
pkg/mcp/internal/core/conversation_test.go:func (m *MockConversationOrchestrator) ExecuteTool(ctx context.Context, toolName string, args interface{}) (interface{}, error) {
pkg/mcp/internal/core/conversation_test.go:	return map[string]interface{}{
pkg/mcp/internal/core/conversation_test.go:func (m *MockConversationOrchestrator) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/transport/llm_stdio_test.go:func (m *MockStdioClient) SimulateResponse(id interface{}, result interface{}, err error) error {
pkg/mcp/internal/transport/llm_stdio_test.go:	response := map[string]interface{}{
pkg/mcp/internal/transport/llm_stdio_test.go:		response["error"] = map[string]interface{}{
pkg/mcp/internal/transport/llm_stdio_test.go:func (m *MockStdioClient) GetLastRequest() (map[string]interface{}, error) {
pkg/mcp/internal/transport/llm_stdio_test.go:			var req map[string]interface{}
pkg/mcp/internal/transport/llm_stdio_test.go:			var result map[string]interface{}
pkg/mcp/internal/transport/llm_stdio_test.go:			var result map[string]interface{}
pkg/mcp/internal/transport/llm_stdio_test.go:	request := map[string]interface{}{
pkg/mcp/internal/transport/llm_stdio_test.go:		"params": map[string]interface{}{
pkg/mcp/internal/transport/llm_stdio_test.go:			"arguments": map[string]interface{}{
pkg/mcp/internal/transport/llm_stdio_test.go:	err = mockClient.SimulateResponse(1, map[string]interface{}{"content": "Tool executed successfully"}, nil)
pkg/mcp/internal/transport/llm_stdio_test.go:	var response map[string]interface{}
pkg/mcp/internal/core/server_lifecycle_test.go:func (m *mockFailingTransport) SendMessage(message interface{}) error {
pkg/mcp/internal/core/server_lifecycle_test.go:func (m *mockFailingTransport) ReceiveMessage() (interface{}, error) {
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) HandleToolError(ctx context.Context, toolName string, err error) (interface{}, error) {
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) handleCoreError(coreErr *errors.CoreError, toolName string) interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	response := map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"content": []map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		if errorMap, ok := response["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_handler.go:		steps := make([]map[string]interface{}, len(coreErr.Resolution.ImmediateSteps))
pkg/mcp/internal/transport/stdio_error_handler.go:			steps[i] = map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		alternatives := make([]map[string]interface{}, len(coreErr.Resolution.Alternatives))
pkg/mcp/internal/transport/stdio_error_handler.go:			alternatives[i] = map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		response["retry_strategy"] = map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		response["diagnostics"] = map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) handleToolError(toolErr *types.ToolError, toolName string) interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	return map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"content": []map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) handleGenericError(err error, toolName string) interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	return map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"content": []map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) createCancellationResponse(ctxErr error, toolName string) interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	return map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"content": []map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) CreateErrorResponse(id interface{}, code int, message string, data interface{}) map[string]interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	response := map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		if errorMap, ok := response["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) EnhanceErrorWithContext(errorResponse map[string]interface{}, sessionID, toolName string) {
pkg/mcp/internal/transport/stdio_error_handler.go:	if errorResp, ok := errorResponse["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_handler.go:		errorResp["debug"] = map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:func (h *StdioErrorHandler) CreateRecoveryResponse(originalError error, recoverySteps, alternatives []string) interface{} {
pkg/mcp/internal/transport/stdio_error_handler.go:	return map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"content": []map[string]interface{}{
pkg/mcp/internal/transport/stdio_error_handler.go:		"error": map[string]interface{}{
pkg/mcp/internal/core/mcp_server_test.go:		sessionState.Metadata = map[string]interface{}{
pkg/mcp/internal/core/mcp_server_test.go:			"repo_analysis": map[string]interface{}{
pkg/mcp/internal/core/mcp_server_test.go:		err = sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/core/mcp_server_test.go:		if repoAnalysis, ok := retrieved.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/core/mcp_server_test.go:		testMap := map[string]interface{}{
pkg/mcp/internal/core/mcp_server_test.go:		err := utils.NewError("test operation: something went wrong", map[string]interface{}{"operation": "test"})
pkg/mcp/internal/core/mcp_server_test.go:func (m *MockSessionManager) GetSession(sessionID string) (interface{}, error) {
pkg/mcp/internal/core/mcp_server_test.go:func (m *MockSessionManager) UpdateSession(sessionID string, updater func(interface{})) error {
pkg/mcp/internal/transport/client_test.go:		Params:  map[string]interface{}{"key": "value", "number": 42},
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:		input     interface{}
pkg/mcp/internal/core/tool_argument_mapping_test.go:		expected  interface{}
pkg/mcp/internal/core/tool_argument_mapping_test.go:			argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:	argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_argument_mapping_test.go:		argsMap := map[string]interface{}{
pkg/mcp/internal/core/error_handling_test.go:			var recoveredValue interface{}
pkg/mcp/internal/core/error_handling_test.go:		input     interface{}
pkg/mcp/internal/core/error_handling_test.go:		operation func(interface{}) (interface{}, error)
pkg/mcp/internal/core/error_handling_test.go:		expected  interface{}
pkg/mcp/internal/core/error_handling_test.go:			operation: func(input interface{}) (interface{}, error) {
pkg/mcp/internal/core/error_handling_test.go:			operation: func(input interface{}) (interface{}, error) {
pkg/mcp/internal/core/error_handling_test.go:			operation: func(input interface{}) (interface{}, error) {
pkg/mcp/internal/core/error_handling_test.go:			operation: func(input interface{}) (interface{}, error) {
pkg/mcp/internal/core/error_handling_test.go:			operation: func(input interface{}) (interface{}, error) {
pkg/mcp/internal/transport/llm_e2e_test.go:	ID      interface{} ` + "`json:\"id\"`" + `
pkg/mcp/internal/transport/llm_e2e_test.go:	Params  interface{} ` + "`json:\"params\"`" + `
pkg/mcp/internal/transport/llm_e2e_test.go:	ID      interface{}     ` + "`json:\"id\"`" + `
pkg/mcp/internal/transport/llm_e2e_test.go:	Result  interface{}     ` + "`json:\"result,omitempty\"`" + `
pkg/mcp/internal/transport/llm_e2e_test.go:	Data    interface{} ` + "`json:\"data,omitempty\"`" + `
pkg/mcp/internal/transport/llm_e2e_test.go:			params, ok := req.Params.(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:			args, _ := params["arguments"].(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:				result := map[string]interface{}{
pkg/mcp/internal/transport/llm_e2e_test.go:func sendResult(id interface{}, result interface{}) {
pkg/mcp/internal/transport/llm_e2e_test.go:func sendError(id interface{}, code int, message string) {
pkg/mcp/internal/transport/llm_e2e_test.go:func (c *DummyStdioClient) SendRequest(method string, params interface{}) error {
pkg/mcp/internal/transport/llm_e2e_test.go:	req := map[string]interface{}{
pkg/mcp/internal/transport/llm_e2e_test.go:func (c *DummyStdioClient) ReadResponse() (map[string]interface{}, error) {
pkg/mcp/internal/transport/llm_e2e_test.go:		var resp map[string]interface{}
pkg/mcp/internal/transport/llm_e2e_test.go:		err := client.SendRequest("tools/call", map[string]interface{}{
pkg/mcp/internal/transport/llm_e2e_test.go:			"arguments": map[string]interface{}{
pkg/mcp/internal/transport/llm_e2e_test.go:		result := resp["result"].(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:		err := client.SendRequest("tools/call", map[string]interface{}{
pkg/mcp/internal/transport/llm_e2e_test.go:			"arguments": map[string]interface{}{},
pkg/mcp/internal/transport/llm_e2e_test.go:		errObj := resp["error"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:		message interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:			message: map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				"params": map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				var msg map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:			message: map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				"result": map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				var msg map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:				result, ok := msg["result"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:			message: map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				var msg map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:				error, ok := msg["error"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:			message: map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				"params": map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				var msg map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:		args := map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:		var decoded map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:		args := map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:		var decoded map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:		buildArgs, ok := decoded["build_args"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:		errorData interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:			errorResp := map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_mapping_test.go:				if errorMap, ok := errorResp["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_mapping_test.go:			var decoded map[string]interface{}
pkg/mcp/internal/transport/stdio_mapping_test.go:			errorObj, ok := decoded["error"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:			var decoded map[string]interface{}
pkg/mcp/internal/core/tool_integration_test.go:		input    map[string]interface{}
pkg/mcp/internal/core/tool_integration_test.go:		expected map[string]interface{}
pkg/mcp/internal/core/tool_integration_test.go:			input: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			expected: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			input: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			expected: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			input: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			expected: map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			argsMap := map[string]interface{}{
pkg/mcp/internal/core/tool_integration_test.go:			argsMap := map[string]interface{}{
pkg/mcp/internal/transport/client.go:	ID      interface{} `json:"id"`
pkg/mcp/internal/transport/client.go:	Params  interface{} `json:"params"`
pkg/mcp/internal/transport/client.go:	ID      interface{}     `json:"id"`
pkg/mcp/internal/transport/client.go:	Data    interface{} `json:"data,omitempty"`
pkg/mcp/internal/transport/client.go:func (c *Client) Call(ctx context.Context, method string, params interface{}) (json.RawMessage, error) {
pkg/mcp/internal/core/gomcp_manager.go:	transport     interface{} // Injected transport (stdio or http)
pkg/mcp/internal/core/gomcp_manager.go:func (gm *GomcpManager) WithTransport(t interface{}) *GomcpManager {
pkg/mcp/internal/core/gomcp_manager.go:func (gm *GomcpManager) GetTransport() interface{} {
pkg/mcp/internal/transport/http.go:	mcpServer      interface{}
pkg/mcp/internal/transport/http.go:type ToolHandler func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) SendMessage(message interface{}) error {
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) ReceiveMessage() (interface{}, error) {
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) RegisterTool(name, description string, handler interface{}) error {
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) SetServer(srv interface{}) {
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) GetServer() interface{} {
pkg/mcp/internal/transport/http.go:	t.sendJSON(w, http.StatusOK, map[string]interface{}{
pkg/mcp/internal/transport/http.go:	var args map[string]interface{}
pkg/mcp/internal/transport/http.go:	t.sendJSON(w, http.StatusOK, map[string]interface{}{
pkg/mcp/internal/transport/http.go:	t.sendJSON(w, http.StatusOK, map[string]interface{}{
pkg/mcp/internal/transport/http.go:	result, err := handler(r.Context(), map[string]interface{}{})
pkg/mcp/internal/transport/http.go:		listResponse, err := listTool(r.Context(), map[string]interface{}{
pkg/mcp/internal/transport/http.go:	result, err := handler(r.Context(), map[string]interface{}{
pkg/mcp/internal/transport/http.go:func (t *HTTPTransport) sendJSON(w http.ResponseWriter, status int, data interface{}) {
pkg/mcp/internal/transport/http.go:	t.sendJSON(w, status, map[string]interface{}{
pkg/mcp/internal/core/gomcp_tools.go:func (b *coreAnalyzerBridge) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/core/gomcp_tools.go:	Details   map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/core/gomcp_tools.go:	Sessions []map[string]interface{} `json:"sessions"`
pkg/mcp/internal/core/gomcp_tools.go:	Details map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/core/gomcp_tools.go:	atomicTools := map[string]interface{}{
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:			var argsMap map[string]interface{}
pkg/mcp/internal/core/gomcp_tools.go:		}) (interface{}, error) {
pkg/mcp/internal/core/gomcp_tools.go:		}) (interface{}, error) {
pkg/mcp/internal/core/gomcp_tools.go:			}) (interface{}, error) {
pkg/mcp/internal/core/gomcp_tools.go:			}) (interface{}, error) {
pkg/mcp/internal/core/gomcp_tools.go:	gm.server.Tool(toolName, description, func(ctx *gomcpserver.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/transport/llm_mock.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/transport/llm_mock.go:				Arguments:     map[string]interface{}{"repo_url": "./"},
pkg/mcp/internal/transport/llm_mock.go:				Arguments:     map[string]interface{}{},
pkg/mcp/internal/transport/llm_mock.go:				Arguments:     map[string]interface{}{"dry_run": false},
pkg/mcp/internal/transport/llm_stdio.go:		params := map[string]interface{}{
pkg/mcp/internal/core/request_logger_test.go:	logger.AddTraceEvent(ctx, "operation_start", map[string]interface{}{
pkg/mcp/internal/core/request_logger_test.go:	logger.AddTraceEvent(ctx, "operation_end", map[string]interface{}{
pkg/mcp/internal/core/request_logger_test.go:	logger.StartOperation(ctx, "test_operation", map[string]interface{}{
pkg/mcp/internal/transport/stdio_helpers.go:	ID      interface{}   `json:"id"`
pkg/mcp/internal/transport/stdio_helpers.go:	Result  interface{}   `json:"result,omitempty"`
pkg/mcp/internal/transport/stdio_helpers.go:	Data    interface{} `json:"data,omitempty"`
pkg/mcp/internal/transport/stdio_helpers.go:func CreateSuccessResponse(id interface{}, result interface{}) map[string]interface{} {
pkg/mcp/internal/transport/stdio_helpers.go:	return map[string]interface{}{
pkg/mcp/internal/transport/stdio_helpers.go:func CreateErrorResponse(id interface{}, code int, message string, data interface{}) map[string]interface{} {
pkg/mcp/internal/transport/stdio_helpers.go:	response := map[string]interface{}{
pkg/mcp/internal/transport/stdio_helpers.go:		"error": map[string]interface{}{
pkg/mcp/internal/transport/stdio_helpers.go:		response["error"].(map[string]interface{})["data"] = data
pkg/mcp/internal/transport/stdio_helpers.go:func CreateErrorResponseFromError(id interface{}, err error) map[string]interface{} {
pkg/mcp/internal/transport/stdio_helpers.go:func FormatMCPMessage(message interface{}) ([]byte, error) {
pkg/mcp/internal/transport/stdio_helpers.go:func ParseJSONMessage(data []byte) (map[string]interface{}, error) {
pkg/mcp/internal/transport/stdio_helpers.go:	var message map[string]interface{}
pkg/mcp/internal/transport/stdio_helpers.go:func LogTransportEvent(logger zerolog.Logger, event string, details map[string]interface{}) {
pkg/mcp/internal/transport/stdio_helpers.go:func LogTransportError(logger zerolog.Logger, operation string, err error, context map[string]interface{}) {
pkg/mcp/internal/transport/stdio_helpers.go:func ValidateJSONRPCRequest(request map[string]interface{}) error {
pkg/mcp/internal/core/server.go:	transport        interface{} // stdio or http transport
pkg/mcp/internal/core/server.go:	var transportInstance interface{}
pkg/mcp/internal/core/server.go:	if setter, ok := transportInstance.(interface{ SetGomcpManager(interface{}) }); ok {
pkg/mcp/internal/core/server.go:func (s *Server) GetTransport() interface{} {
pkg/mcp/internal/core/server.go:func (s *Server) GetSessionManager() interface{} {
pkg/mcp/internal/core/server.go:func (s *Server) GetWorkspaceManager() interface{} {
pkg/mcp/internal/core/server.go:	schemas := map[string]interface{}{
pkg/mcp/internal/core/server.go:		"metadata": map[string]interface{}{
pkg/mcp/internal/core/server.go:func (s *Server) getAvailableToolSchemas() map[string]interface{} {
pkg/mcp/internal/core/server.go:	tools := make(map[string]interface{})
pkg/mcp/internal/core/server.go:		tools[toolName] = map[string]interface{}{
pkg/mcp/internal/core/server.go:func (s *Server) GetLogger() interface{} {
pkg/mcp/internal/core/error_service.go:	Fields    map[string]interface{}
pkg/mcp/internal/core/telemetry_service.go:func (s *TelemetryService) TrackEvent(ctx context.Context, eventType string, data interface{}) {
pkg/mcp/internal/core/telemetry_service.go:	Data      interface{}
pkg/mcp/internal/core/telemetry_service.go:	Metadata  map[string]interface{}
pkg/mcp/internal/core/server_stats.go:func (s *Server) GetConversationAdapter() interface{} {
pkg/mcp/internal/core/server_stats.go:func (s *Server) GetTelemetry() interface{} {
pkg/mcp/internal/transport/stdio_error_test.go:			if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:				if errorField, ok := resultMap["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:				t.Errorf("Expected map[string]interface{} but got %T", result)
pkg/mcp/internal/transport/stdio_error_test.go:	if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:		if errorField, ok := resultMap["error"].(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	SessionState   interface{}            `json:"session_state"`
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	Metadata       map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	GetHealthMetrics() map[string]interface{}
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	Metrics     map[string]interface{} `json:"metrics"`
pkg/mcp/internal/pipeline/recovery_mechanisms.go:func (rm *RecoveryManager) CreateRecoveryPoint(ctx context.Context, sessionID string, metadata map[string]interface{}) (*RecoveryPoint, error) {
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	_, err := rm.CreateRecoveryPoint(ctx, recoveryOp.SessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/recovery_mechanisms.go:	return rm.sessionManager.UpdateSession(recoveryOp.SessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/recovery_mechanisms.go:		err := rm.sessionManager.UpdateSession(recoveryOp.SessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/production_validation.go:	Metrics         map[string]interface{} `json:"metrics"`
pkg/mcp/internal/pipeline/production_validation.go:	Details         interface{}            `json:"details"`
pkg/mcp/internal/pipeline/production_validation.go:	Parameters   map[string]interface{} `json:"parameters"`
pkg/mcp/internal/pipeline/production_validation.go:	Environment map[string]interface{} `json:"environment"`
pkg/mcp/internal/pipeline/production_validation.go:		Metrics:         make(map[string]interface{}),
pkg/mcp/internal/pipeline/production_validation.go:		Parameters: map[string]interface{}{
pkg/mcp/internal/pipeline/production_validation.go:		Parameters: map[string]interface{}{
pkg/mcp/internal/pipeline/production_validation.go:		Environment: map[string]interface{}{
pkg/mcp/internal/pipeline/auto_scaling.go:	Data     interface{}
pkg/mcp/internal/pipeline/auto_scaling.go:	Callback func(interface{}) error
pkg/mcp/internal/pipeline/helpers_test.go:	analysisData := map[string]interface{}{
pkg/mcp/internal/pipeline/helpers_test.go:	analysisNoPort := map[string]interface{}{
pkg/mcp/internal/pipeline/helpers_test.go:		pipeline.RepoAnalysisResultKey: map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	clients        interface{}
pkg/mcp/internal/pipeline/operations.go:	clients interface{},
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) UpdateSessionFromDockerResults(sessionID string, result interface{}) error {
pkg/mcp/internal/pipeline/operations.go:	return o.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) BuildDockerImage(sessionID, imageRef, dockerfilePath string) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		o.sessionManager.TrackError(sessionID, err, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		o.sessionManager.CompleteJob(sessionID, jobID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	err = o.UpdateSessionFromDockerResults(sessionID, map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) ConvertToDockerState(sessionID string) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) GenerateKubernetesManifests(sessionID, imageRef, appName string, port int, cpuRequest, memoryRequest, cpuLimit, memoryLimit string) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:		"Manifests": []map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) DeployToKubernetes(sessionID string, manifests []string) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) CheckApplicationHealth(sessionID, namespace, labelSelector string, timeout time.Duration) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:	return o.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) BuildImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) PushImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:			return map[string]interface{}{"success": err == nil}, err
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) PullImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:			return map[string]interface{}{"success": err == nil}, err
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) TagImage(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:				return map[string]interface{}{"success": err == nil}, err
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) GenerateManifests(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) DeployKubernetes(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) CheckHealth(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) AnalyzeRepository(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) ValidateDockerfile(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) ScanSecurity(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/operations.go:func (o *Operations) ScanSecrets(ctx context.Context, sessionID string, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/operations.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/docker_optimizer.go:func (opt *DockerOperationOptimizer) GetCacheStats() map[string]interface{} {
pkg/mcp/internal/pipeline/docker_optimizer.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/docker_optimizer.go:func (opt *DockerOperationOptimizer) GetResourceStats() map[string]interface{} {
pkg/mcp/internal/pipeline/docker_optimizer.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_operations.go:	Result           interface{}              `json:"result,omitempty"`
pkg/mcp/internal/pipeline/distributed_operations.go:	Metadata         map[string]interface{}   `json:"metadata"`
pkg/mcp/internal/pipeline/distributed_operations.go:	Result    interface{}            `json:"result,omitempty"`
pkg/mcp/internal/pipeline/distributed_operations.go:	Args      map[string]interface{} `json:"args"`
pkg/mcp/internal/pipeline/distributed_operations.go:	RouteOperation(operation string, args map[string]interface{}) RoutingDecision
pkg/mcp/internal/pipeline/distributed_operations.go:	Metadata     map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/distributed_operations.go:	args map[string]interface{},
pkg/mcp/internal/pipeline/distributed_operations.go:func (dom *DistributedOperationManager) executeLocalOperation(ctx context.Context, distOp *DistributedOperation, args map[string]interface{}) (*DistributedOperation, error) {
pkg/mcp/internal/pipeline/distributed_operations.go:func (dom *DistributedOperationManager) executeDistributedOperation(ctx context.Context, distOp *DistributedOperation, args map[string]interface{}) (*DistributedOperation, error) {
pkg/mcp/internal/pipeline/distributed_operations.go:	results := make(map[string]interface{})
pkg/mcp/internal/pipeline/distributed_operations.go:func (dom *DistributedOperationManager) executeReplicatedOperation(ctx context.Context, distOp *DistributedOperation, args map[string]interface{}) (*DistributedOperation, error) {
pkg/mcp/internal/pipeline/distributed_operations.go:		subOp.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_operations.go:		subOp.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_operations.go:		subOp.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_operations.go:	subOp.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_operations.go:func (dom *DistributedOperationManager) selectOptimalNodes(operation string, args map[string]interface{}) ([]string, error) {
pkg/mcp/internal/pipeline/distributed_operations.go:func (rp *DefaultRoutingPolicy) RouteOperation(operation string, args map[string]interface{}) RoutingDecision {
pkg/mcp/internal/pipeline/distributed_operations.go:		Metadata:     make(map[string]interface{}),
pkg/mcp/internal/pipeline/atomic_framework.go:	Metadata      map[string]interface{}
pkg/mcp/internal/pipeline/atomic_framework.go:	Result    interface{}            `json:"result"`
pkg/mcp/internal/pipeline/atomic_framework.go:	Metadata  map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/atomic_framework.go:		result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	af.sessionManager.TrackToolExecution(config.SessionID, "atomic_docker_pull", map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:		result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	af.sessionManager.TrackToolExecution(config.SessionID, "atomic_docker_push", map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:		result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	af.sessionManager.TrackToolExecution(config.SessionID, "atomic_docker_tag", map[string]interface{}{
pkg/mcp/internal/pipeline/atomic_framework.go:	result.Result = map[string]interface{}{
pkg/mcp/internal/pipeline/performance_optimizations.go:	connectionPool map[string]interface{}
pkg/mcp/internal/pipeline/performance_optimizations.go:	Result      interface{}   `json:"result"`
pkg/mcp/internal/pipeline/performance_optimizations.go:		connectionPool:   make(map[string]interface{}),
pkg/mcp/internal/pipeline/performance_optimizations.go:func (po *PerformanceOptimizer) OptimizeDockerOperation(ctx context.Context, operationType, sessionID string, args map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/performance_optimizations.go:	var result interface{}
pkg/mcp/internal/pipeline/performance_optimizations.go:		result = map[string]interface{}{
pkg/mcp/internal/pipeline/performance_optimizations.go:		result = map[string]interface{}{
pkg/mcp/internal/pipeline/performance_optimizations.go:		result = map[string]interface{}{
pkg/mcp/internal/pipeline/performance_optimizations.go:func (po *PerformanceOptimizer) BatchOptimizeOperations(ctx context.Context, operations []BatchOperation) ([]interface{}, error) {
pkg/mcp/internal/pipeline/performance_optimizations.go:	results := make([]interface{}, len(operations))
pkg/mcp/internal/pipeline/performance_optimizations.go:func (po *PerformanceOptimizer) generateCacheKey(operationType string, args map[string]interface{}) string {
pkg/mcp/internal/pipeline/performance_optimizations.go:func (po *PerformanceOptimizer) cacheResult(key string, result interface{}, ttl time.Duration) {
pkg/mcp/internal/pipeline/performance_optimizations.go:func (po *PerformanceOptimizer) shouldCache(operationType string, args map[string]interface{}) bool {
pkg/mcp/internal/pipeline/performance_optimizations.go:	Args      map[string]interface{} `json:"args"`
pkg/mcp/internal/pipeline/helpers.go:func (m *MetadataManager) ToStringMap() map[string]interface{} {
pkg/mcp/internal/pipeline/helpers.go:	result := make(map[string]interface{}, len(m.metadata))
pkg/mcp/internal/pipeline/helpers.go:func (c *AnalysisConverter) ToMap(analysis interface{}) (map[string]interface{}, error) {
pkg/mcp/internal/pipeline/helpers.go:	analysisMap, err := genericutils.SafeCast[map[string]interface{}](analysis)
pkg/mcp/internal/pipeline/helpers.go:func (c *AnalysisConverter) GetLanguage(analysisMap map[string]interface{}) string {
pkg/mcp/internal/pipeline/helpers.go:func (c *AnalysisConverter) GetFramework(analysisMap map[string]interface{}) string {
pkg/mcp/internal/pipeline/helpers.go:func (c *AnalysisConverter) GetPort(analysisMap map[string]interface{}) int {
pkg/mcp/internal/pipeline/workflow_integration.go:	Variables         map[string]interface{} `json:"variables"`
pkg/mcp/internal/pipeline/workflow_integration.go:		wsi.sessionManager.TrackError(config.SessionID, err, map[string]interface{}{
pkg/mcp/internal/pipeline/workflow_integration.go:func (wsi *WorkflowSessionIntegrator) CreateSessionForWorkflow(workflowID string, metadata map[string]interface{}) (string, error) {
pkg/mcp/internal/pipeline/workflow_integration.go:	err = wsi.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/workflow_integration.go:	return wsi.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/pipeline/workflow_integration.go:				session.Metadata = make(map[string]interface{})
pkg/mcp/internal/pipeline/workflow_integration.go:	WorkflowResult interface{}   `json:"workflow_result"`
pkg/mcp/internal/pipeline/workflow_integration.go:	SessionState   interface{}   `json:"session_state"`
pkg/mcp/internal/pipeline/workflow_integration.go:func (wsi *WorkflowSessionIntegrator) extractSessionID(sessionInterface interface{}) string {
pkg/mcp/internal/pipeline/security_hardening.go:	Context     map[string]interface{} `json:"context"`
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) ValidateDockerOperation(ctx context.Context, sessionID, operation string, args map[string]interface{}) error {
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) validatePullOperation(sessionID string, args map[string]interface{}) error {
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) validatePushOperation(sessionID string, args map[string]interface{}) error {
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) validateTagOperation(sessionID string, args map[string]interface{}) error {
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) SecureOperationWrapper(ctx context.Context, sessionID, operation string, args map[string]interface{}, operationFunc func() error) error {
pkg/mcp/internal/pipeline/security_hardening.go:		map[string]interface{}{
pkg/mcp/internal/pipeline/security_hardening.go:func (sm *SecurityManager) recordSecurityEvent(sessionID, operation, eventType, severity, description string, context map[string]interface{}) {
pkg/mcp/internal/deploy/template_processor.go:func (tp *TemplateProcessor) ProcessTemplate(templateName string, data interface{}) (string, error) {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (t *AtomicDeployKubernetesTool) performDeployment(ctx context.Context, session *core.SessionState, args AtomicDeployKubernetesArgs, result *AtomicDeployKubernetesResult, _ interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:	deployArgs := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		// Convert interface{} to expected structure
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:	deployArgs := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:	if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) PrepareForRetry(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) applyManifestFix(_ context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) applyDependencyFix(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) applyResourceFix(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) applyGenericFix(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:func (op *KubernetesDeployOperation) applyFileChange(change map[string]interface{}) error {
pkg/mcp/internal/deploy/validator_helpers.go:func (v *ManifestValidator) checkContainerReferences(container map[string]interface{}, configMaps, secrets map[string]bool, result *ValidationResult) {
pkg/mcp/internal/deploy/validator_helpers.go:	if envFrom, ok := container["envFrom"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:			if envMap, ok := env.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:				if cmRef, ok := envMap["configMapRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:				if secRef, ok := envMap["secretRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:	if env, ok := container["env"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:			if envMap, ok := envVar.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:				if valueFrom, ok := envMap["valueFrom"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:					if cmKeyRef, ok := valueFrom["configMapKeyRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:					if secKeyRef, ok := valueFrom["secretKeyRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:	if volumeMounts, ok := container["volumeMounts"].([]interface{}); ok {
pkg/mcp/validation/utils/pattern_analysis.go:			paramType := "interface{}"
pkg/mcp/validation/utils/pattern_analysis.go:			resultType := "interface{}"
pkg/mcp/validation/utils/pattern_analysis.go:		return "interface{}"
pkg/mcp/validation/utils/pattern_analysis.go:		return "interface{}"
pkg/mcp/internal/deploy/manifest_writer.go:func (w *Writer) WriteManifestFromTemplate(filePath, templatePath string, data interface{}) error {
pkg/mcp/internal/deploy/manifest_writer.go:		"default": func(def interface{}, val interface{}) interface{} {
pkg/mcp/internal/deploy/manifest_writer.go:	data := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:func (t *AtomicDeployKubernetesTool) performHealthCheckUnified(ctx context.Context, session *core.SessionState, args AtomicDeployKubernetesArgs, result *AtomicDeployKubernetesResult, _ interface{}) (*validationCore.ValidationResult, error) {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:				result.HealthResult.Context = make(map[string]interface{})
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:	errorData := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:func (t *AtomicDeployKubernetesTool) ValidateUnified(ctx context.Context, args interface{}) (*validationCore.ValidationResult, error) {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:		return result, utils.NewWithData("invalid_arguments", "Invalid argument type for atomic_deploy_kubernetes", map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:			criticalError = utils.NewWithData("VALIDATION_ERROR", err.Message, map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:			session.Metadata = make(map[string]interface{})
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:		validationSummary := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:			errorSummary := make([]map[string]interface{}, 0, len(validationResult.Errors))
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:				errorSummary = append(errorSummary, map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:func ValidateDeploymentConfigUnified(config map[string]interface{}) *validationCore.ValidationResult {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:func GetDeploymentValidationMetrics(result AtomicDeployKubernetesResult) map[string]interface{} {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:	metrics := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:func ValidateDeploymentPipeline(config map[string]interface{}) *validationCore.ValidationResult {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/deploy/operation.go:	PrepareFunc  func(ctx context.Context, fixAttempt interface{}) error
pkg/mcp/internal/deploy/operation.go:func (op *Operation) PrepareForRetry(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/health_validator_unified.go:		Metadata:  make(map[string]interface{}),
pkg/mcp/internal/deploy/health_validator_unified.go:	if metrics, ok := validationResult.Metadata.Context["health_metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_validator_unified.go:			result.AnalysisDetails = make(map[string]interface{})
pkg/mcp/internal/deploy/health_validator_unified.go:func ValidateHealthCheck(config map[string]interface{}) *core.ValidationResult {
pkg/mcp/internal/deploy/health_validator_unified.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/deploy/base.go:	ProgressReporter interface{} // Progress reporting interface
pkg/mcp/internal/deploy/generate_manifests_atomic.go:func (t *AtomicGenerateManifestsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/deploy/generate_manifests_atomic.go:func (t *AtomicGenerateManifestsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/deploy/generate_manifests_atomic.go:func (t *AtomicGenerateManifestsTool) SetAnalyzer(analyzer interface{}) {
pkg/mcp/internal/deploy/manifest_validator_unified.go:			Context:          make(map[string]interface{}),
pkg/mcp/internal/deploy/manifest_validator_unified.go:	var manifests []map[string]interface{}
pkg/mcp/internal/deploy/manifest_validator_unified.go:		var manifest map[string]interface{}
pkg/mcp/internal/deploy/manifest_validator_unified.go:			var singleManifest map[string]interface{}
pkg/mcp/internal/deploy/manifest_validator_unified.go:		var manifest map[string]interface{}
pkg/mcp/internal/deploy/manifest_validator_unified.go:			Context:          map[string]interface{}{"file_path": filePath},
pkg/mcp/internal/deploy/manifest_validator_unified.go:func ValidateManifestMap(manifest map[string]interface{}, options *core.ValidationOptions) *core.ValidationResult {
pkg/mcp/internal/deploy/manifest_validator_unified.go:func ValidateKubernetesResource(resource map[string]interface{}, strictMode bool, securityValidation bool) *core.ValidationResult {
pkg/mcp/internal/deploy/manifest_validator_unified.go:func (v *Validator) GetManifestValidationMetrics(ctx context.Context, manifestPath string) (map[string]interface{}, error) {
pkg/mcp/internal/deploy/manifest_validator_unified.go:	metrics := make(map[string]interface{})
pkg/mcp/internal/deploy/validate_deployment.go:	CreateJob(jobType, sessionID string, metadata map[string]interface{}) string
pkg/mcp/internal/deploy/validate_deployment.go:	UpdateJobStatus(jobID, status string, progress float64, result map[string]interface{})
pkg/mcp/internal/deploy/validate_deployment.go:func (t *AtomicValidateDeploymentTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/deploy/validate_deployment.go:	case map[string]interface{}:
pkg/mcp/internal/deploy/validate_deployment.go:func (t *AtomicValidateDeploymentTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/deploy/validate_deployment.go:	case map[string]interface{}:
pkg/mcp/internal/deploy/validate_deployment.go:				Input: map[string]interface{}{
pkg/mcp/internal/deploy/validate_deployment.go:				Output: map[string]interface{}{
pkg/mcp/internal/deploy/validate_deployment.go:				Input: map[string]interface{}{
pkg/mcp/internal/deploy/validate_deployment.go:				Output: map[string]interface{}{
pkg/mcp/internal/deploy/manifest_validator.go:	var manifest map[string]interface{}
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateBasicK8sStructure(manifest map[string]interface{}, validation *FileValidation) error {
pkg/mcp/internal/deploy/manifest_validator.go:		if metadataMap, ok := metadata.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateResourceSpecificFields(kind string, manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateDeploymentFields(manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateServiceFields(manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:				if portsList, ok := ports.([]interface{}); ok && len(portsList) == 0 {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateIngressFields(manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateConfigMapFields(manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/manifest_validator.go:func (v *Validator) validateSecretFields(manifest map[string]interface{}, validation *FileValidation) {
pkg/mcp/internal/deploy/health_types.go:	AnalysisDetails map[string]interface{} `json:"analysis_details"`
pkg/mcp/internal/deploy/generate_manifests_conversion.go:func getStringValue(m map[string]interface{}, key string) string {
pkg/mcp/internal/deploy/generate_manifests_conversion.go:func getIntValue(m map[string]interface{}, key string) int {
pkg/mcp/internal/deploy/generate_manifests_conversion.go:func getBoolValue(m map[string]interface{}, key string) bool {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:func (t *AtomicDeployKubernetesTool) performHealthCheck(ctx context.Context, session *core.SessionState, args AtomicDeployKubernetesArgs, result *AtomicDeployKubernetesResult, _ interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:	healthArgs := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:	// Convert from interface{} to kubernetes.HealthCheckResult
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		// Convert interface{} to expected structure
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		if healthMap, ok := healthResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		if healthMap, ok := healthResult.(map[string]interface{}); ok && !getBoolFromMap(healthMap, "healthy", false) {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:func (t *AtomicDeployKubernetesTool) Validate(_ context.Context, args interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		return utils.NewWithData("invalid_arguments", "Invalid argument type for atomic_deploy_kubernetes", map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		return utils.NewWithData("missing_required_field", "ImageRef is required", map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		return utils.NewWithData("missing_required_field", "SessionID is required", map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:func (t *AtomicDeployKubernetesTool) performManifestGeneration(ctx context.Context, session *core.SessionState, args AtomicDeployKubernetesArgs, result *AtomicDeployKubernetesResult, _ interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:	manifestArgs := map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:	// Convert from interface{} to kubernetes.ManifestGenerationResult
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:		// Convert interface{} to expected structure
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:		if manifestMap, ok := manifestResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:				if manifests, ok := manifestsData.([]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:						if manifestMap, ok := manifest.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:		if manifestMap, ok := manifestResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_tool.go:func (t *AtomicCheckHealthTool) executeWithProgress(ctx context.Context, args AtomicCheckHealthArgs, startTime time.Time, reporter interface{}) (*AtomicCheckHealthResult, error) {
pkg/mcp/internal/deploy/health_tool.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/deploy/health_tool.go:	session.Metadata["last_health_check"] = map[string]interface{}{
pkg/mcp/internal/deploy/health_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/deploy/health_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/deploy/health_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/deploy/health_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/deploy/health_tool.go:func (t *AtomicCheckHealthTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/deploy/health_tool.go:func (t *AtomicCheckHealthTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/pipeline/ai_optimization.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Metadata   map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Metadata   map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Metadata         map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Parameters       map[string]interface{}   `json:"parameters"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Value       interface{} `json:"value"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Characteristics map[string]interface{} `json:"characteristics"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Value    interface{}   `json:"value"`
pkg/mcp/internal/pipeline/ai_optimization.go:	SLACharacteristics  map[string]interface{}       `json:"sla_characteristics"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Context       map[string]interface{}     `json:"context"`
pkg/mcp/internal/pipeline/ai_optimization.go:	Metadata        map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/ai_optimization.go:func (aoe *AIOptimizationEngine) selectOptimizationStrategy(objectives []OptimizationObjective, workloadAnalysis interface{}) *OptimizationModel {
pkg/mcp/internal/pipeline/ai_optimization.go:func (aoe *AIOptimizationEngine) calculateOptimizationConfidence(request *OptimizationRequest, optimizedSpec ContainerSpecification, workloadAnalysis interface{}) float64 {
pkg/mcp/internal/pipeline/ai_optimization.go:func (wa *WorkloadAnalyzer) AnalyzeWorkload(ctx context.Context, spec ContainerSpecification) (interface{}, error) {
pkg/mcp/internal/pipeline/ai_optimization.go:	return map[string]interface{}{
pkg/mcp/internal/pipeline/distributed_caching.go:	Value        interface{}            `json:"value"`
pkg/mcp/internal/pipeline/distributed_caching.go:	Metadata     map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/distributed_caching.go:	Metadata   map[string]interface{} `json:"metadata"`
pkg/mcp/internal/pipeline/distributed_caching.go:	Value       interface{} `json:"value"`
pkg/mcp/internal/pipeline/distributed_caching.go:	Value       interface{} `json:"value"`
pkg/mcp/internal/pipeline/distributed_caching.go:	Value   interface{}   `json:"value"`
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error {
pkg/mcp/internal/pipeline/distributed_caching.go:		Metadata:     make(map[string]interface{}),
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) setLocal(key string, value interface{}, ttl time.Duration) {
pkg/mcp/internal/pipeline/distributed_caching.go:		Metadata:     make(map[string]interface{}),
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) calculateSize(value interface{}) int64 {
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) calculateChecksum(value interface{}) string {
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) compressValue(value interface{}) interface{} {
pkg/mcp/internal/pipeline/distributed_caching.go:func (dcm *DistributedCacheManager) encryptValue(value interface{}) interface{} {
pkg/mcp/types/validation_test.go:		Fields: map[string]interface{}{
pkg/mcp/types/interfaces_test.go:	Metadata            map[string]interface{}
pkg/mcp/types/interfaces_test.go:	Input       map[string]interface{} `json:"input"`
pkg/mcp/types/interfaces_test.go:	Output      map[string]interface{} `json:"output"`
pkg/mcp/types/interfaces_test.go:func (m *MockAIAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/types/interfaces_test.go:		Input:       map[string]interface{}{"key": "value"},
pkg/mcp/types/interfaces_test.go:		Output:      map[string]interface{}{"result": "success"},
pkg/mcp/types/interfaces_test.go:		Metadata:            map[string]interface{}{"test": "value"},
pkg/mcp/internal/deploy/validator.go:	var doc map[string]interface{}
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateRequiredFields(doc map[string]interface{}, kind string) error {
pkg/mcp/internal/deploy/validator.go:	metadata, ok := doc["metadata"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateDeployment(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:		containers, ok := templateSpec["containers"].([]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateContainer(container interface{}, index int) error {
pkg/mcp/internal/deploy/validator.go:	cont, ok := container.(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateService(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	ports, ok := spec["ports"].([]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateServicePort(port interface{}, index int) error {
pkg/mcp/internal/deploy/validator.go:	p, ok := port.(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateConfigMap(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateSecret(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validateIngress(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	rules, ok := spec["rules"].([]interface{})
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) validatePVC(doc map[string]interface{}) error {
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	var doc map[string]interface{}
pkg/mcp/internal/deploy/validator.go:	if metadata, ok := doc["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) checkDeploymentBestPractices(doc map[string]interface{}) []string {
pkg/mcp/internal/deploy/validator.go:	if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:		if template, ok := spec["template"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:			if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:				if containers, ok := templateSpec["containers"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:						if cont, ok := container.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:func (v *ManifestValidator) checkServiceBestPractices(doc map[string]interface{}) []string {
pkg/mcp/internal/deploy/validator.go:	if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:			var doc map[string]interface{}
pkg/mcp/internal/deploy/validator.go:			if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:				if template, ok := spec["template"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:					if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:						if containers, ok := templateSpec["containers"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:								if cont, ok := container.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:func (t *AtomicDeployKubernetesTool) SetAnalyzer(analyzer interface{}) {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:		operation.PrepareFunc = func(_ context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:func (t *AtomicDeployKubernetesTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:		return nil, utils.NewWithData("invalid_arguments", "Invalid argument type for atomic_deploy_kubernetes", map[string]interface{}{
pkg/mcp/internal/deploy/health_checker.go:func (hc *HealthChecker) PerformHealthCheck(ctx context.Context, args AtomicCheckHealthArgs, reporter interface{}) (*AtomicCheckHealthResult, error) {
pkg/mcp/internal/deploy/health_checker.go:	healthArgs := map[string]interface{}{
pkg/mcp/internal/deploy/health_checker.go:	// Convert from interface{} to kubernetes.HealthCheckResult
pkg/mcp/internal/deploy/health_checker.go:		kubernetesHealthResult = hc.convertHealthCheckResult(healthResult.(map[string]interface{}), namespace)
pkg/mcp/internal/deploy/health_checker.go:			healthArgs := map[string]interface{}{
pkg/mcp/internal/deploy/health_checker.go:				kubernetesResult := hc.convertHealthCheckResult(healthResult.(map[string]interface{}), namespace)
pkg/mcp/internal/deploy/health_checker.go:func (hc *HealthChecker) convertHealthCheckResult(result map[string]interface{}, namespace string) *kubernetes.HealthCheckResult {
pkg/mcp/internal/deploy/health_checker.go:	// Convert the map[string]interface{} result to kubernetes.HealthCheckResult
pkg/mcp/internal/deploy/health_checker.go:	if summaryData, ok := result["summary"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:	if pods, ok := result["pod_statuses"].([]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:			if podMap, ok := podInterface.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:	if services, ok := result["service_statuses"].([]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:			if serviceMap, ok := serviceInterface.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:func getStringFromMap(m map[string]interface{}, key, defaultValue string) string {
pkg/mcp/internal/deploy/health_checker.go:func getBoolFromMap(m map[string]interface{}, key string, defaultValue bool) bool {
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	var configMap map[string]interface{}
pkg/mcp/internal/deploy/generate_manifests_helpers.go:		binaryDataMap := make(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	secrets := []map[string]interface{}{}
pkg/mcp/internal/deploy/generate_manifests_helpers.go:		dockerConfig := map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:			"auths": map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:				regSecret.Registry: map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:		secret := map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:			"metadata": map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:			"data": map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	var deployment map[string]interface{}
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	spec, ok := deployment["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	templateSpec, ok := template["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	imagePullSecrets := []map[string]interface{}{
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	if existing, ok := templateSpec["imagePullSecrets"].([]interface{}); ok {
pkg/mcp/internal/deploy/generate_manifests_helpers.go:			if secretMap, ok := secret.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/generate_manifests.go:	validator     interface{} // Simplified for now
pkg/mcp/internal/deploy/generate_manifests.go:func NewGenerateManifestsToolWithValidator(logger zerolog.Logger, workspaceBase string, validator interface{}) *GenerateManifestsTool {
pkg/mcp/internal/deploy/generate_manifests.go:func (t *GenerateManifestsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/deploy/generate_manifests.go:	case map[string]interface{}:
pkg/mcp/internal/deploy/generate_manifests.go:func (t *GenerateManifestsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/deploy/generate_manifests.go:	case map[string]interface{}:
pkg/mcp/internal/deploy/generate_manifests.go:func GenerateManifests(ctx context.Context, args map[string]interface{}) (map[string]interface{}, error) {
pkg/mcp/internal/deploy/generate_manifests.go:func convertToGenerateManifestsArgs(args map[string]interface{}) (GenerateManifestsArgs, error) {
pkg/mcp/internal/deploy/generate_manifests.go:func convertGenerateManifestsResultToMap(result *GenerateManifestsResult) map[string]interface{} {
pkg/mcp/internal/deploy/generate_manifests.go:	var resultMap map[string]interface{}
pkg/mcp/internal/deploy/generate_manifests.go:		return make(map[string]interface{})
pkg/mcp/internal/deploy/health_validator.go:	context := make(map[string]interface{})
pkg/mcp/types/tools/migration.go:// TypeConverter converts between interface{} and specific types
pkg/mcp/types/tools/migration.go:type TypeConverter func(interface{}) (interface{}, error)
pkg/mcp/types/tools/migration.go:// ConvertFromInterface converts interface{} to a specific type
pkg/mcp/types/tools/migration.go:func (m *MigrationHelper) ConvertFromInterface(data interface{}, targetTypeName string) (interface{}, error) {
pkg/mcp/types/tools/migration.go:func ConvertToGenericParams[TParams ToolParams](data interface{}) (TParams, error) {
pkg/mcp/types/tools/migration.go:	// Try conversion from map[string]interface{}
pkg/mcp/types/tools/migration.go:	if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:func ConvertToGenericResult[TResult ToolResult](data interface{}) (TResult, error) {
pkg/mcp/types/tools/migration.go:	// Try conversion from map[string]interface{}
pkg/mcp/types/tools/migration.go:	if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:func convertMapToStruct[T any](data map[string]interface{}) (T, error) {
pkg/mcp/types/tools/migration.go:// setFieldValue sets a reflect.Value from an interface{} value
pkg/mcp/types/tools/migration.go:func setFieldValue(fieldValue reflect.Value, value interface{}) error {
pkg/mcp/types/tools/migration.go:		if mapData, ok := value.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:func convertMapToStructReflect(data map[string]interface{}, structType reflect.Type) (reflect.Value, error) {
pkg/mcp/types/tools/migration.go:func convertToString(value interface{}) (string, error) {
pkg/mcp/types/tools/migration.go:func convertToInt64(value interface{}) (int64, error) {
pkg/mcp/types/tools/migration.go:func convertToUint64(value interface{}) (uint64, error) {
pkg/mcp/types/tools/migration.go:func convertToFloat64(value interface{}) (float64, error) {
pkg/mcp/types/tools/migration.go:func convertToBool(value interface{}) (bool, error) {
pkg/mcp/types/tools/migration.go:func convertToSlice(value interface{}, elemType reflect.Type) (reflect.Value, error) {
pkg/mcp/types/tools/migration.go:func convertToMap(value interface{}, keyType, valueType reflect.Type) (reflect.Value, error) {
pkg/mcp/types/tools/migration.go:	m.RegisterType("string", reflect.TypeOf(""), func(data interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:	m.RegisterType("int", reflect.TypeOf(0), func(data interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:	m.RegisterType("float64", reflect.TypeOf(0.0), func(data interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:	m.RegisterType("bool", reflect.TypeOf(false), func(data interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:	// Map[string]interface{} converter (pass-through)
pkg/mcp/types/tools/migration.go:	m.RegisterType("map[string]interface{}", reflect.TypeOf(map[string]interface{}{}), func(data interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:		if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:		return nil, fmt.Errorf("expected map[string]interface{}, got %T", data)
pkg/mcp/types/tools/migration.go:func ConvertStandardErrorToRich(err error) interface{} {
pkg/mcp/types/tools/migration.go:	return map[string]interface{}{
pkg/mcp/types/tools/migration.go:	LegacyRegistry map[string]interface{}
pkg/mcp/types/tools/migration.go:	NewRegistry    interface{} // Would be typed as Registry[T, TParams, TResult] in real use
pkg/mcp/types/tools/migration.go:		LegacyRegistry: make(map[string]interface{}),
pkg/mcp/types/tools/migration.go:func (b *BackwardCompatibilityLayer) RegisterLegacyTool(name string, tool interface{}) {
pkg/mcp/types/tools/migration.go:// ExecuteLegacyTool executes a legacy tool with interface{} parameters
pkg/mcp/types/tools/migration.go:func (b *BackwardCompatibilityLayer) ExecuteLegacyTool(name string, params interface{}) (interface{}, error) {
pkg/mcp/types/tools/migration.go:func MigrateLegacyRegistry(legacyRegistry map[string]interface{}) error {
pkg/mcp/types/tools/migration.go:	// 2. Create a wrapper that converts between interface{} and generic types
pkg/mcp/types/tools/generic.go:	ChainWith(next interface{}) interface{}
pkg/mcp/types/tools/generic.go:	Value   interface{}
pkg/mcp/types/tools/generic.go:	ParamsSchema   interface{} // JSON Schema for parameters
pkg/mcp/types/tools/generic.go:	ResultSchema   interface{} // JSON Schema for results
pkg/mcp/types/tools/registry.go:	Create(config interface{}) (T, error)
pkg/mcp/types/tools/registry.go:	GetConfigSchema() interface{}
pkg/mcp/types/tools/registry.go:	Validate(config interface{}) error
pkg/mcp/types/tools/registry.go:	Context   map[string]interface{}
pkg/mcp/types/tools/schema.go:	RefResolver map[string]interface{}
pkg/mcp/types/tools/schema.go:	TypeRegistry map[reflect.Type]interface{}
pkg/mcp/types/tools/schema.go:		RefResolver:  make(map[string]interface{}),
pkg/mcp/types/tools/schema.go:		TypeRegistry: make(map[reflect.Type]interface{}),
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) GenerateSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateSchemaForType(t reflect.Type, visited map[reflect.Type]bool) (interface{}, error) {
pkg/mcp/types/tools/schema.go:		return map[string]interface{}{
pkg/mcp/types/tools/schema.go:		return map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateStringSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateIntegerSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateNumberSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateBooleanSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateArraySchema(t reflect.Type, visited map[reflect.Type]bool) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:		schema["example"] = []interface{}{}
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateMapSchema(t reflect.Type, visited map[reflect.Type]bool) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:		schema["example"] = map[string]interface{}{}
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateStructSchema(t reflect.Type, visited map[reflect.Type]bool) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:		"properties": make(map[string]interface{}),
pkg/mcp/types/tools/schema.go:	properties := schema["properties"].(map[string]interface{})
pkg/mcp/types/tools/schema.go:			if schemaMap, ok := fieldSchema.(map[string]interface{}); ok {
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) generateInterfaceSchema(t reflect.Type) (interface{}, error) {
pkg/mcp/types/tools/schema.go:	return map[string]interface{}{
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) applyValidationConstraints(schema interface{}, validateTag string) {
pkg/mcp/types/tools/schema.go:	schemaMap, ok := schema.(map[string]interface{})
pkg/mcp/types/tools/schema.go:func parseNumber(s string) (interface{}, error) {
pkg/mcp/types/tools/schema.go:func (g *SchemaGenerator) RegisterCustomType(t reflect.Type, schema interface{}) {
pkg/mcp/types/tools/schema.go:func GetSchemaAsJSON(schema interface{}) ([]byte, error) {
pkg/mcp/types/tools/schema.go:func ValidateAgainstSchema(data interface{}, schema interface{}) error {
pkg/mcp/types/tools/schema.go:	schemaMap, ok := schema.(map[string]interface{})
pkg/mcp/types/tools/schema.go:func getJSONType(v interface{}) string {
pkg/mcp/types/tools/schema.go:	case []interface{}, []int, []string: // etc.
pkg/mcp/types/tools/schema.go:	case map[string]interface{}:
pkg/mcp/types/tools/schema.go:func StringSchema(minLen, maxLen int, pattern string) map[string]interface{} {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func NumberSchema(min, max *float64, multipleOf *float64) map[string]interface{} {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func ArraySchema(itemSchema interface{}, minItems, maxItems int) map[string]interface{} {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/schema.go:func EnumSchema(values []interface{}) map[string]interface{} {
pkg/mcp/types/tools/schema.go:	return map[string]interface{}{
pkg/mcp/types/tools/schema.go:func ObjectSchema(properties map[string]interface{}, required []string) map[string]interface{} {
pkg/mcp/types/tools/schema.go:	schema := map[string]interface{}{
pkg/mcp/types/tools/constraints.go:	Validate(value interface{}) error
pkg/mcp/types/tools/constraints.go:func (c StringConstraint) Validate(value interface{}) error {
pkg/mcp/types/tools/constraints.go:func (c NumberConstraint) Validate(value interface{}) error {
pkg/mcp/types/tools/constraints.go:func (c ArrayConstraint) Validate(value interface{}) error {
pkg/mcp/types/tools/constraints.go:		seen := make(map[interface{}]bool)
pkg/mcp/types/tools/constraints.go:func (c BooleanConstraint) Validate(value interface{}) error {
pkg/mcp/types/tools/constraints.go:func (c DateTimeConstraint) Validate(value interface{}) error {
pkg/mcp/types/tools/constraints.go:func (c CompoundConstraint) Validate(value interface{}) error {
pkg/mcp/types/validation.go:	Fields    map[string]interface{}
pkg/mcp/types/validation.go:			Fields: map[string]interface{}{
pkg/mcp/types/validation.go:	Validate(data interface{}, options ValidationOptions) *ValidationResult
pkg/mcp/types/ai_context_base.go:func (b BaseAIContextResult) GetMetadataForAI() map[string]interface{} {
pkg/mcp/types/ai_context_base.go:	return map[string]interface{}{
pkg/mcp/types/mcp_clients.go:	AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error)
pkg/mcp/types/mcp_clients.go:func (s *stubAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/base_ai_context.go:func (b BaseAIContextResult) GetMetadataForAI() map[string]interface{} {
pkg/mcp/internal/base_ai_context.go:	return map[string]interface{}{
pkg/mcp/internal/monitoring/health.go:	Details        map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/monitoring/health.go:	Details      map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/monitoring/health.go:type ComponentCheckFunc func(ctx context.Context) (HealthStatus, map[string]interface{}, error)
pkg/mcp/internal/monitoring/health.go:type DependencyCheckFunc func(ctx context.Context) (HealthStatus, time.Duration, map[string]interface{}, error)
pkg/mcp/internal/monitoring/health.go:type HealthChangeCallback func(name string, oldStatus, newStatus HealthStatus, details map[string]interface{})
pkg/mcp/internal/monitoring/health.go:		Details:        make(map[string]interface{}),
pkg/mcp/internal/monitoring/health.go:		Details:   make(map[string]interface{}),
pkg/mcp/internal/monitoring/health.go:func (hc *HealthChecker) triggerHealthChangeCallbacks(name string, oldStatus, newStatus HealthStatus, details map[string]interface{}) {
pkg/mcp/internal/monitoring/health.go:		componentCopy.Details = make(map[string]interface{})
pkg/mcp/internal/monitoring/health.go:		dependencyCopy.Details = make(map[string]interface{})
pkg/mcp/internal/monitoring/health.go:	compCopy.Details = make(map[string]interface{})
pkg/mcp/internal/monitoring/health.go:	depCopy.Details = make(map[string]interface{})
pkg/mcp/internal/monitoring/health.go:	return func(ctx context.Context) (HealthStatus, time.Duration, map[string]interface{}, error) {
pkg/mcp/internal/monitoring/health.go:			return HealthStatusUnhealthy, responseTime, map[string]interface{}{
pkg/mcp/internal/monitoring/health.go:		details := map[string]interface{}{
pkg/mcp/internal/monitoring/observability.go:	Attributes map[string]interface{}
pkg/mcp/internal/monitoring/observability.go:func (om *ObservabilityManager) TraceHTTPRequest(next func(ctx context.Context, req interface{}) (interface{}, error)) func(ctx context.Context, req interface{}) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:	return func(ctx context.Context, req interface{}) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:func (om *ObservabilityManager) TraceDockerOperation(operation string, next func(ctx context.Context) (interface{}, error)) func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:	return func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:func (om *ObservabilityManager) TraceSessionOperation(operation string, sessionID string, next func(ctx context.Context) (interface{}, error)) func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:	return func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/monitoring/observability.go:type TraceableFunc func(ctx context.Context) (interface{}, error)
pkg/mcp/internal/monitoring/observability.go:	return func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/workflow/coordinator_test.go:			Results:   map[string]interface{}{"completed": true},
pkg/mcp/internal/workflow/coordinator_test.go:		SharedContext:    make(map[string]interface{}),
pkg/mcp/internal/workflow/coordinator_test.go:		ResourceBindings: make(map[string]interface{}),
pkg/mcp/internal/workflow/coordinator_test.go:		StageResults:     make(map[string]interface{}),
pkg/mcp/internal/workflow/coordinator_test.go:					Variables: map[string]interface{}{"var1": "value1"},
pkg/mcp/internal/workflow/coordinator_test.go:					Variables: map[string]interface{}{"var2": "value2"},
pkg/mcp/internal/workflow/coordinator_test.go:			Variables: map[string]interface{}{
pkg/mcp/internal/workflow/coordinator_test.go:		Variables: map[string]interface{}{
pkg/mcp/internal/workflow/coordinator_test.go:		SharedContext:    map[string]interface{}{"key": "value"},
pkg/mcp/internal/workflow/coordinator_test.go:		ResourceBindings: map[string]interface{}{"resource": "binding"},
pkg/mcp/internal/workflow/coordinator_test.go:		StageResults:     map[string]interface{}{"stage": "result"},
pkg/mcp/internal/workflow/coordinator_test.go:		Results:   map[string]interface{}{"result": "success"},
pkg/mcp/internal/workflow/coordinator_test.go:		Results:         map[string]interface{}{"final": "result"},
pkg/mcp/internal/workflow/coordinator.go:	SharedContext    map[string]interface{} `json:"shared_context"`
pkg/mcp/internal/workflow/coordinator.go:	ResourceBindings map[string]interface{} `json:"resource_bindings"`
pkg/mcp/internal/workflow/coordinator.go:	StageResults     map[string]interface{} `json:"stage_results"`
pkg/mcp/internal/workflow/coordinator.go:	Variables map[string]interface{} `json:"variables"`
pkg/mcp/internal/workflow/coordinator.go:	Variables   map[string]interface{} `json:"variables"`
pkg/mcp/internal/workflow/coordinator.go:	Results   map[string]interface{} `json:"results"`
pkg/mcp/internal/workflow/coordinator.go:	Results         map[string]interface{} `json:"results"`
pkg/mcp/internal/workflow/coordinator.go:	Variables            map[string]interface{} `json:"variables"`
pkg/mcp/internal/workflow/coordinator.go:		Results:    make(map[string]interface{}),
pkg/mcp/internal/workflow/coordinator.go:				session.StageResults = make(map[string]interface{})
pkg/mcp/internal/types/llm_contract.go:	Arguments     map[string]interface{} `json:"arguments"` // Only LLM populates this
pkg/mcp/internal/types/llm_contract.go:	Result        interface{}   `json:"result,omitempty"`
pkg/mcp/internal/types/llm_contract.go:	SessionState    map[string]interface{} `json:"session_state"`  // Persistent state
pkg/mcp/internal/types/llm_contract.go:	StageMetadata   map[string]interface{} `json:"stage_metadata"` // Current stage context
pkg/mcp/internal/types/llm_contract.go:	InputSchema  map[string]interface{} `json:"input_schema"`
pkg/mcp/internal/types/llm_contract.go:	OutputSchema map[string]interface{} `json:"output_schema"`
pkg/mcp/internal/types/llm_contract.go:	Metadata      map[string]interface{} `json:"metadata,omitempty"`    // Additional context
pkg/mcp/internal/types/llm_contract.go:	Metadata        map[string]interface{} `json:"metadata,omitempty"`    // Additional context
pkg/mcp/internal/types/common.go:	Context     map[string]interface{} `json:"context"`     // Additional error context
pkg/mcp/internal/state/integration.go:func (t *ToolStateTransaction) SetToolConfig(config interface{}) *ToolStateTransaction {
pkg/mcp/internal/state/integration.go:func (t *ToolStateTransaction) SetToolState(state interface{}) *ToolStateTransaction {
pkg/mcp/internal/state/integration.go:func (t *ToolStateTransaction) SetToolMetrics(metrics interface{}) *ToolStateTransaction {
pkg/mcp/internal/state/integration.go:	ConflictHandler func(local, remote interface{}) (interface{}, error)
pkg/mcp/internal/types/types_test.go:	var jsonMap map[string]interface{}
pkg/mcp/internal/types/types_test.go:	var jsonMap map[string]interface{}
pkg/mcp/internal/state/providers.go:func (p *SessionStateProvider) GetState(ctx context.Context, id string) (interface{}, error) {
pkg/mcp/internal/state/providers.go:func (p *SessionStateProvider) SetState(ctx context.Context, id string, state interface{}) error {
pkg/mcp/internal/state/providers.go:	return p.sessionManager.UpdateSession(id, func(current interface{}) {
pkg/mcp/internal/state/providers.go:	sessions, err := p.sessionManager.ListSessions(ctx, map[string]interface{}{})
pkg/mcp/internal/state/providers.go:func (p *ConversationStateProvider) GetState(ctx context.Context, id string) (interface{}, error) {
pkg/mcp/internal/state/providers.go:func (p *ConversationStateProvider) SetState(ctx context.Context, id string, state interface{}) error {
pkg/mcp/internal/state/providers.go:func (p *WorkflowStateProvider) GetState(ctx context.Context, id string) (interface{}, error) {
pkg/mcp/internal/state/providers.go:func (p *WorkflowStateProvider) SetState(ctx context.Context, id string, state interface{}) error {
pkg/mcp/internal/state/providers.go:	states map[string]interface{}
pkg/mcp/internal/state/providers.go:		states: make(map[string]interface{}),
pkg/mcp/internal/state/providers.go:func (p *ToolStateProvider) GetState(ctx context.Context, id string) (interface{}, error) {
pkg/mcp/internal/state/providers.go:func (p *ToolStateProvider) SetState(ctx context.Context, id string, state interface{}) error {
pkg/mcp/internal/state/providers.go:	states map[string]interface{}
pkg/mcp/internal/state/providers.go:		states: make(map[string]interface{}),
pkg/mcp/internal/state/providers.go:func (p *GlobalStateProvider) GetState(ctx context.Context, id string) (interface{}, error) {
pkg/mcp/internal/state/providers.go:func (p *GlobalStateProvider) SetState(ctx context.Context, id string, state interface{}) error {
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:	dryRunOp func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:	actualOp func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:		dryRunOp: func(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:		actualOp: func(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:func (m *MockTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:func (m *MockTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/state/unified_state_manager.go:	OldValue  interface{}
pkg/mcp/internal/state/unified_state_manager.go:	NewValue  interface{}
pkg/mcp/internal/state/unified_state_manager.go:	Metadata  map[string]interface{}
pkg/mcp/internal/state/unified_state_manager.go:	ValidateState(ctx context.Context, stateType StateType, state interface{}) error
pkg/mcp/internal/state/unified_state_manager.go:	GetState(ctx context.Context, id string) (interface{}, error)
pkg/mcp/internal/state/unified_state_manager.go:	SetState(ctx context.Context, id string, state interface{}) error
pkg/mcp/internal/state/unified_state_manager.go:func (m *UnifiedStateManager) GetState(ctx context.Context, stateType StateType, id string) (interface{}, error) {
pkg/mcp/internal/state/unified_state_manager.go:func (m *UnifiedStateManager) SetState(ctx context.Context, stateType StateType, id string, state interface{}) error {
pkg/mcp/internal/state/unified_state_manager.go:	return m.sessionManager.UpdateSession(sessionID, func(current interface{}) {
pkg/mcp/internal/state/state_sync_coordinator.go:	MapState(source interface{}) (target interface{}, err error)
pkg/mcp/internal/state/state_sync_coordinator.go:	ReverseMap(target interface{}) (source interface{}, err error)
pkg/mcp/internal/state/state_sync_coordinator.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/state/validators.go:func (v *SessionStateValidator) ValidateState(_ context.Context, stateType StateType, state interface{}) error {
pkg/mcp/internal/state/validators.go:func (v *ConversationStateValidator) ValidateState(ctx context.Context, _ StateType, state interface{}) error {
pkg/mcp/internal/state/validators.go:func (v *WorkflowStateValidator) ValidateState(ctx context.Context, stateType StateType, state interface{}) error {
pkg/mcp/internal/state/validators.go:	validators map[string]func(interface{}) error
pkg/mcp/internal/state/validators.go:		validators: make(map[string]func(interface{}) error),
pkg/mcp/internal/state/validators.go:func (v *ToolStateValidator) AddFieldValidator(fieldName string, validator func(interface{}) error) {
pkg/mcp/internal/state/validators.go:func (v *ToolStateValidator) ValidateState(ctx context.Context, stateType StateType, state interface{}) error {
pkg/mcp/internal/state/validators.go:	schema interface{}
pkg/mcp/internal/state/validators.go:func NewGlobalStateValidator(schema interface{}) StateValidator {
pkg/mcp/internal/state/validators.go:func (v *GlobalStateValidator) ValidateState(ctx context.Context, stateType StateType, state interface{}) error {
pkg/mcp/internal/state/validators.go:func (v *CompositeValidator) ValidateState(ctx context.Context, stateType StateType, state interface{}) error {
pkg/mcp/internal/registry/azure_cli_provider.go:	var response map[string]interface{}
pkg/mcp/internal/state/types.go:	SaveCheckpoint(ctx context.Context, sessionID string, data interface{}) error
pkg/mcp/internal/state/types.go:	LoadCheckpoint(ctx context.Context, sessionID string) (interface{}, error)
pkg/mcp/internal/state/types.go:	GetMetadata() map[string]interface{}
pkg/mcp/internal/state/types.go:	Metadata     map[string]interface{} `json:"metadata"`
pkg/mcp/internal/state/types.go:func (w *BasicWorkflowSession) GetMetadata() map[string]interface{} {
pkg/mcp/internal/state/types.go:	GetContent() interface{}
pkg/mcp/internal/state/types.go:	SessionState   interface{}              `json:"session_state"`
pkg/mcp/internal/state/types.go:	Content interface{} `json:"content"`
pkg/mcp/internal/state/types.go:func (a *BasicArtifact) GetContent() interface{} {
pkg/mcp/internal/registry/validator.go:	Details       map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/registry/validator.go:		Details:  make(map[string]interface{}),
pkg/mcp/internal/state/observers.go:	Changes   map[string]interface{}
pkg/mcp/internal/state/observers.go:	Metadata  map[string]interface{}
pkg/mcp/internal/state/observers.go:func (o *AuditObserver) calculateChanges(oldValue, newValue interface{}) map[string]interface{} {
pkg/mcp/internal/state/observers.go:	changes := make(map[string]interface{})
pkg/mcp/internal/state/mappings.go:func (m *SessionToConversationMapping) MapState(source interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:func (m *SessionToConversationMapping) ReverseMap(target interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:func (m *WorkflowToSessionMapping) MapState(source interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:	updates := map[string]interface{}{
pkg/mcp/internal/state/mappings.go:func (m *WorkflowToSessionMapping) ReverseMap(target interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:func (m *ToolStateMapping) MapState(source interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:	sourceMap, ok := source.(map[string]interface{})
pkg/mcp/internal/state/mappings.go:	targetMap := make(map[string]interface{})
pkg/mcp/internal/state/mappings.go:func (m *ToolStateMapping) ReverseMap(target interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:	targetMap, ok := target.(map[string]interface{})
pkg/mcp/internal/state/mappings.go:	sourceMap := make(map[string]interface{})
pkg/mcp/internal/state/mappings.go:func (m *CompositeMapping) MapState(source interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:func (m *CompositeMapping) ReverseMap(target interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:	filter      func(interface{}) bool
pkg/mcp/internal/state/mappings.go:func NewFilteredMapping(baseMapping StateMapping, filter func(interface{}) bool) StateMapping {
pkg/mcp/internal/state/mappings.go:func (m *FilteredMapping) MapState(source interface{}) (interface{}, error) {
pkg/mcp/internal/state/mappings.go:func (m *FilteredMapping) ReverseMap(target interface{}) (interface{}, error) {
pkg/mcp/internal/state/state_transaction.go:	State     interface{}
pkg/mcp/internal/state/state_transaction.go:	Validator func(interface{}) error
pkg/mcp/internal/state/state_transaction.go:func (t *StateTransaction) Set(stateType StateType, id string, state interface{}) *StateTransaction {
pkg/mcp/internal/state/state_transaction.go:func (t *StateTransaction) SetWithValidation(stateType StateType, id string, state interface{}, validator func(interface{}) error) *StateTransaction {
pkg/mcp/validation/core/interfaces.go:	Validate(ctx context.Context, data interface{}, options *ValidationOptions) *ValidationResult
pkg/mcp/validation/core/interfaces.go:	ValidateField(fieldName string, value interface{}, options *ValidationOptions) *ValidationError
pkg/mcp/validation/core/interfaces.go:	ShouldValidate(ctx context.Context, data interface{}, options *ValidationOptions) bool
pkg/mcp/validation/core/interfaces.go:	ValidateSecurity(ctx context.Context, data interface{}, options *ValidationOptions) *SecurityValidationResult
pkg/mcp/validation/core/interfaces.go:	CreateValidator(name string, config map[string]interface{}) (Validator, error)
pkg/mcp/validation/core/interfaces.go:	Execute(ctx context.Context, data interface{}, options *ValidationOptions) *ValidationError
pkg/mcp/validation/core/interfaces.go:	ExecuteRules(ctx context.Context, data interface{}, options *ValidationOptions) *ValidationResult
pkg/mcp/validation/core/interfaces.go:	ExecuteRule(ctx context.Context, ruleName string, data interface{}, options *ValidationOptions) *ValidationError
pkg/mcp/validation/core/interfaces.go:	Metadata  map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/validation/core/interfaces.go:	Configure(config map[string]interface{}) error
pkg/mcp/validation/core/interfaces.go:	GetConfiguration() map[string]interface{}
pkg/mcp/validation/core/interfaces.go:	GetCacheKey(data interface{}, options *ValidationOptions) string
pkg/mcp/validation/core/interfaces.go:	GetState() map[string]interface{}
pkg/mcp/validation/core/interfaces.go:	ValidateAsync(ctx context.Context, data interface{}, options *ValidationOptions) <-chan *ValidationResult
pkg/mcp/validation/core/interfaces.go:	ValidateBatch(ctx context.Context, items []interface{}, options *ValidationOptions) []*ValidationResult
pkg/mcp/validation/core/interfaces.go:	ValidateStream(ctx context.Context, stream <-chan interface{}, options *ValidationOptions) <-chan *ValidationResult
pkg/mcp/validation/core/types.go:	Context     map[string]interface{} `json:"context,omitempty"`
pkg/mcp/validation/core/types.go:		Context:   make(map[string]interface{}),
pkg/mcp/validation/core/types.go:		Context:   map[string]interface{}{"field": field},
pkg/mcp/validation/core/types.go:		Context:   map[string]interface{}{"line": line, "rule": rule},
pkg/mcp/validation/core/types.go:			Context:   make(map[string]interface{}),
pkg/mcp/validation/core/types.go:		e.Context = make(map[string]interface{})
pkg/mcp/validation/core/types.go:		e.Context = make(map[string]interface{})
pkg/mcp/validation/core/types.go:		e.Context = make(map[string]interface{})
pkg/mcp/validation/core/types.go:		e.Context = make(map[string]interface{})
pkg/mcp/validation/core/types.go:func (e *ValidationError) WithContext(key string, value interface{}) *ValidationError {
pkg/mcp/validation/core/types.go:		e.Context = make(map[string]interface{})
pkg/mcp/validation/core/types.go:	Context          map[string]interface{} `json:"context,omitempty"`
pkg/mcp/validation/core/types.go:	Context         map[string]interface{} `json:"context,omitempty"`
pkg/mcp/validation/core/types.go:		Context:         make(map[string]interface{}),
pkg/mcp/validation/core/types.go:func (o *ValidationOptions) WithContext(key string, value interface{}) *ValidationOptions {
pkg/mcp/validation/core/types.go:		o.Context = make(map[string]interface{})
pkg/mcp/internal/orchestration/job_manager.go:	Result      map[string]interface{} `json:"result,omitempty"`
pkg/mcp/internal/orchestration/job_manager.go:	Metadata    map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/internal/orchestration/job_manager.go:func (jm *JobManager) CreateJob(jobType JobType, sessionID string, metadata map[string]interface{}) string {
pkg/mcp/internal/orchestration/job_manager.go:		jobCopy.Result = make(map[string]interface{})
pkg/mcp/internal/orchestration/job_manager.go:		jobCopy.Metadata = make(map[string]interface{})
pkg/mcp/internal/orchestration/tool_orchestrator.go:	pipelineOperations interface{} // Store for passing to dispatcher
pkg/mcp/internal/orchestration/tool_orchestrator.go:func (o *MCPToolOrchestrator) SetPipelineOperations(operations interface{}) {
pkg/mcp/internal/orchestration/tool_orchestrator.go:	args interface{},
pkg/mcp/internal/orchestration/tool_orchestrator.go:) (interface{}, error) {
pkg/mcp/internal/orchestration/tool_orchestrator.go:func (o *MCPToolOrchestrator) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/orchestration/tool_orchestrator.go:		// Type assert Input and Output to map[string]interface{}
pkg/mcp/internal/orchestration/tool_orchestrator.go:		var input, output map[string]interface{}
pkg/mcp/internal/orchestration/tool_orchestrator.go:		if inputMap, ok := example.Input.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_orchestrator.go:			input = make(map[string]interface{})
pkg/mcp/internal/orchestration/tool_orchestrator.go:		if outputMap, ok := example.Output.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_orchestrator.go:			output = make(map[string]interface{})
pkg/mcp/internal/orchestration/tool_orchestrator.go:	args map[string]interface{},
pkg/mcp/internal/orchestration/tool_orchestrator.go:	args map[string]interface{},
pkg/mcp/internal/orchestration/error_types.go:	Value         interface{} `json:"value"`
pkg/mcp/internal/orchestration/error_types.go:	Parameters  map[string]interface{} `json:"parameters,omitempty"`
pkg/mcp/internal/orchestration/error_types.go:	Parameters map[string]interface{} `json:"parameters,omitempty"`
pkg/mcp/internal/orchestration/error_types.go:	Result     interface{}            `json:"result,omitempty"`
pkg/mcp/internal/orchestration/error_types.go:	Parameters           map[string]interface{}   `json:"parameters"`
pkg/mcp/internal/orchestration/error_redirection.go:		Parameters:          make(map[string]interface{}),
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	pipelineOperations interface{}
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func (o *NoReflectToolOrchestrator) SetPipelineOperations(operations interface{}) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func (o *NoReflectToolOrchestrator) extractConcreteSessionManager() interface{} {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	// The orchestration.SessionManager interface works with interface{} types
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	args interface{},
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:		return nil, fmt.Errorf("invalid arguments: expected map[string]interface{}, got %T", args)
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func (o *NoReflectToolOrchestrator) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:		return fmt.Errorf("arguments must be a map[string]interface{}")
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func (o *NoReflectToolOrchestrator) executeAnalyzeRepository(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func getString(m map[string]interface{}, key string) (string, bool) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func getInt(m map[string]interface{}, key string) (int, bool) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:func getBool(m map[string]interface{}, key string) (bool, bool) {
pkg/mcp/internal/build/build_image.go:	clients         interface{}
pkg/mcp/internal/build/build_image.go:	clients interface{},
pkg/mcp/internal/build/build_image.go:func (t *BuildImageTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/build/build_image.go:	case map[string]interface{}:
pkg/mcp/internal/orchestration/monitoring.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/orchestration/monitoring.go:	Fields    map[string]interface{} `json:"fields"`
pkg/mcp/internal/orchestration/monitoring.go:	Fields    map[string]interface{} `json:"fields"`
pkg/mcp/internal/orchestration/monitoring.go:	Attributes map[string]interface{} `json:"attributes"`
pkg/mcp/internal/orchestration/monitoring.go:	Extract(format interface{}, carrier interface{}) (SpanContext, error)
pkg/mcp/internal/orchestration/monitoring.go:	Inject(span SpanContext, format interface{}, carrier interface{}) error
pkg/mcp/internal/orchestration/monitoring.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/monitoring.go:	Config  map[string]interface{} `json:"config"`
pkg/mcp/internal/orchestration/monitoring.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/monitoring.go:	Config   map[string]interface{} `json:"config"`
pkg/mcp/internal/orchestration/monitoring.go:	Render(data interface{}) (interface{}, error)
pkg/mcp/internal/orchestration/monitoring.go:	GetConfig() map[string]interface{}
pkg/mcp/internal/orchestration/monitoring.go:	SetConfig(config map[string]interface{}) error
pkg/mcp/internal/orchestration/monitoring.go:func (am *AlertManager) sendNotification(alert *Alert, params map[string]interface{}) {
pkg/mcp/internal/orchestration/monitoring.go:func (am *AlertManager) callWebhook(alert *Alert, params map[string]interface{}) {
pkg/mcp/internal/orchestration/monitoring.go:func (am *AlertManager) autoScale(alert *Alert, params map[string]interface{}) {
pkg/mcp/internal/orchestration/monitoring.go:func (am *AlertManager) executeRemediation(alert *Alert, params map[string]interface{}) {
pkg/mcp/internal/orchestration/types.go:	GetSession(sessionID string) (interface{}, error)
pkg/mcp/internal/orchestration/types.go:	UpdateSession(sessionID string, updater func(interface{})) error
pkg/mcp/internal/orchestration/types.go:	OutputSchema map[string]interface{} `json:"output_schema"`
pkg/mcp/internal/orchestration/types.go:	Input       interface{} `json:"input"`
pkg/mcp/internal/orchestration/types.go:	Output      interface{} `json:"output"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Capabilities    map[string]interface{} `json:"capabilities"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Value    interface{} `json:"value"`
pkg/mcp/internal/orchestration/tool_coordinator.go:type DataTransformFunction func(sourceData interface{}) (interface{}, error)
pkg/mcp/internal/orchestration/tool_coordinator.go:	Payload     interface{}            `json:"payload"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Context     map[string]interface{} `json:"context"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Context        map[string]interface{}
pkg/mcp/internal/orchestration/tool_coordinator.go:	Output   interface{}
pkg/mcp/internal/orchestration/tool_coordinator.go:	Metadata map[string]interface{}
pkg/mcp/internal/orchestration/tool_coordinator.go:			Metadata: map[string]interface{}{"message": "no applicable rules"},
pkg/mcp/internal/orchestration/tool_coordinator.go:		if output, ok := event.Data.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:		if metrics, ok := event.Context["metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:func (tc *ToolCoordinator) compareValues(actual interface{}, operator string, expected interface{}) bool {
pkg/mcp/internal/orchestration/tool_coordinator.go:func (tc *ToolCoordinator) compareNumeric(actual, expected interface{}, op string) bool {
pkg/mcp/internal/orchestration/tool_coordinator.go:	Data       interface{}            `json:"data"`
pkg/mcp/internal/orchestration/tool_coordinator.go:	Context    map[string]interface{} `json:"context"`
pkg/mcp/internal/orchestration/types_test.go:		OutputSchema: map[string]interface{}{"result": "boolean"},
pkg/mcp/internal/orchestration/types_test.go:		Input:       map[string]interface{}{"dockerfile": "Dockerfile", "context": "."},
pkg/mcp/internal/orchestration/types_test.go:		Output:      map[string]interface{}{"image_id": "sha256:abc123", "success": true},
pkg/mcp/internal/orchestration/types_test.go:	inputMap, ok := example.Input.(map[string]interface{})
pkg/mcp/internal/orchestration/types_test.go:		t.Error("Expected Input to be a map[string]interface{}")
pkg/mcp/internal/orchestration/types_test.go:	outputMap, ok := example.Output.(map[string]interface{})
pkg/mcp/internal/orchestration/types_test.go:		t.Error("Expected Output to be a map[string]interface{}")
pkg/mcp/internal/config/manager.go:func loadEnvVars(configStruct interface{}) error {
pkg/mcp/internal/orchestration/workflow_templates.go:	Variables   map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/orchestration/workflow_templates.go:	DefaultValue interface{}         `json:"default_value,omitempty"`
pkg/mcp/internal/orchestration/workflow_templates.go:	MinValue      interface{}      `json:"min_value,omitempty"`
pkg/mcp/internal/orchestration/workflow_templates.go:	MaxValue      interface{}      `json:"max_value,omitempty"`
pkg/mcp/internal/orchestration/workflow_templates.go:	AllowedValues []interface{}    `json:"allowed_values,omitempty"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Parameters  map[string]interface{}   `json:"parameters"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Value     interface{} `json:"value"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Value       interface{} `json:"value"`
pkg/mcp/internal/orchestration/workflow_templates.go:	Parameters   map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/workflow_templates.go:	ValidateParameters(template *WorkflowTemplate, parameters map[string]interface{}) error
pkg/mcp/internal/orchestration/workflow_templates.go:	ValidateConditions(template *WorkflowTemplate, context map[string]interface{}) error
pkg/mcp/internal/orchestration/workflow_templates.go:	Parameters   map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) InstantiateWorkflow(ctx context.Context, templateID string, parameters map[string]interface{}) (*WorkflowInstantiation, error) {
pkg/mcp/internal/orchestration/workflow_templates.go:	contextData := map[string]interface{}{
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) createWorkflowSpec(template *WorkflowTemplate, parameters map[string]interface{}) (*WorkflowSpec, error) {
pkg/mcp/internal/orchestration/workflow_templates.go:	variables := make(map[string]interface{})
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) evaluateStageConditions(conditions []TemplateStageCondition, parameters, variables map[string]interface{}) bool {
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) evaluateStageCondition(condition TemplateStageCondition, parameters, variables map[string]interface{}) bool {
pkg/mcp/internal/orchestration/workflow_templates.go:	var actualValue interface{}
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) resolveParameters(templateParams map[string]interface{}, parameters, variables map[string]interface{}) (map[string]interface{}, error) {
pkg/mcp/internal/orchestration/workflow_templates.go:	resolved := make(map[string]interface{})
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) resolveValue(value interface{}, parameters, variables map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) compareValues(actual interface{}, operator string, expected interface{}) bool {
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) compareNumeric(actual, expected interface{}, op string) bool {
pkg/mcp/internal/orchestration/workflow_templates.go:func (wtm *WorkflowTemplateManager) toFloat64(value interface{}) (float64, bool) {
pkg/mcp/internal/build/build_context.go:) map[string]interface{} {
pkg/mcp/internal/build/build_context.go:	contextInfo := map[string]interface{}{
pkg/mcp/internal/build/build_context.go:		"session": map[string]interface{}{
pkg/mcp/internal/build/build_context.go:		"build_config": map[string]interface{}{
pkg/mcp/internal/build/build_context.go:		"environment": map[string]interface{}{
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeBuildImage(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if buildArgs, ok := argsMap["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executePushImage(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executePullImage(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeTagImage(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeScanImageSecurity(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if vulnTypes, ok := argsMap["vuln_types"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeScanSecrets(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if filePatterns, ok := argsMap["file_patterns"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if excludePatterns, ok := argsMap["exclude_patterns"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeGenerateManifests(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if environment, ok := argsMap["environment"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeDeployKubernetes(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if environment, ok := argsMap["environment"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeCheckHealth(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeGenerateDockerfile(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if buildArgs, ok := argsMap["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeValidateDockerfile(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if ignoreRules, ok := argsMap["ignore_rules"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if trustedRegistries, ok := argsMap["trusted_registries"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:func (o *NoReflectToolOrchestrator) executeValidateDeployment(ctx context.Context, argsMap map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_persistence.go:	Data      map[string]interface{} `json:"data,omitempty"`
pkg/mcp/internal/orchestration/execution_types_test.go:		Variables:  map[string]interface{}{"image": "nginx", "tag": "latest"},
pkg/mcp/internal/orchestration/execution_types_test.go:		Variables:        map[string]interface{}{"env": "production"},
pkg/mcp/internal/orchestration/execution_types_test.go:		Context:          map[string]interface{}{"user": "admin"},
pkg/mcp/internal/orchestration/execution_types_test.go:		SharedContext:    map[string]interface{}{"registry": "docker.io"},
pkg/mcp/internal/orchestration/execution_types_test.go:		ResourceBindings: map[string]interface{}{"cpu": "2", "memory": "4Gi"},
pkg/mcp/internal/orchestration/execution_types_test.go:		StageResults:     map[string]interface{}{"prepare": "success"},
pkg/mcp/internal/orchestration/execution_types_test.go:		ErrorContext:     map[string]interface{}{},
pkg/mcp/internal/orchestration/execution_types_test.go:		Metadata:  map[string]interface{}{"compression": "gzip", "checksum": "sha256:abc123"},
pkg/mcp/internal/orchestration/execution_types_test.go:		Variables:  map[string]interface{}{"branch": "main"},
pkg/mcp/internal/orchestration/execution_types_test.go:		State:        map[string]interface{}{"deployed": true},
pkg/mcp/internal/orchestration/execution_types_test.go:		SessionState: map[string]interface{}{"user": "admin"},
pkg/mcp/internal/orchestration/execution_types_test.go:		StageResults: map[string]interface{}{"deployment_id": "deploy-123"},
pkg/mcp/internal/profiling/testutil/mock_profiler.go:	Result    interface{}
pkg/mcp/internal/profiling/testutil/mock_profiler.go:func (m *MockProfiler) ProfileExecution(toolName, sessionID string, fn func(context.Context) (interface{}, error)) (interface{}, error) {
pkg/mcp/internal/profiling/testutil/mock_profiler.go:func (m *MockProfiler) RunBenchmark(toolName string, iterations, concurrency int, fn func(context.Context) (interface{}, error)) MockBenchmark {
pkg/mcp/internal/build/context_sharer.go:	Data          interface{}            `json:"data"`
pkg/mcp/internal/build/context_sharer.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/context_sharer.go:	Conditions  map[string]interface{} `json:"conditions"`
pkg/mcp/internal/build/context_sharer.go:func (c *DefaultContextSharer) ShareContext(ctx context.Context, sessionID string, contextType string, data interface{}) error {
pkg/mcp/internal/build/context_sharer.go:		Metadata:      make(map[string]interface{}),
pkg/mcp/internal/build/context_sharer.go:func (c *DefaultContextSharer) GetSharedContext(ctx context.Context, sessionID string, contextType string) (interface{}, error) {
pkg/mcp/internal/build/context_sharer.go:		if toolContext, ok := toolData.(map[string]interface{}); ok {
pkg/mcp/internal/build/context_sharer.go:			Conditions:  map[string]interface{}{"retry_count": 0},
pkg/mcp/internal/build/context_sharer.go:			Conditions:  map[string]interface{}{"can_regenerate": true},
pkg/mcp/internal/build/context_sharer.go:			Conditions:  map[string]interface{}{"severity": "high"},
pkg/mcp/internal/orchestration/error_recovery.go:					Parameters: map[string]interface{}{
pkg/mcp/internal/orchestration/error_recovery.go:			Parameters:  map[string]interface{}{"max_attempts": 3},
pkg/mcp/internal/orchestration/error_recovery.go:			Parameters:  map[string]interface{}{"mark_as_skipped": true},
pkg/mcp/internal/orchestration/error_recovery.go:		Parameters:  map[string]interface{}{"require_approval": true},
pkg/mcp/internal/orchestration/workflow_orchestrator.go:	sessionManager    interface{}                  // Session manager
pkg/mcp/internal/orchestration/workflow_orchestrator.go:	toolRegistry      interface{}                  // Tool registry
pkg/mcp/internal/orchestration/workflow_orchestrator.go:	contextSharer     interface{}                  // Context sharer
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func NewWorkflowOrchestrator(deps ...interface{}) *WorkflowOrchestrator {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func (wo *WorkflowOrchestrator) ExecuteWorkflow(ctx context.Context, workflowID string, options ...ExecutionOption) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		Context:          make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		SharedContext:    make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		ResourceBindings: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		StageResults:     make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		ErrorContext:     make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func (wo *WorkflowOrchestrator) ExecuteCustomWorkflow(ctx context.Context, spec *WorkflowSpec) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		var stageResult interface{}
pkg/mcp/internal/orchestration/workflow_orchestrator.go:				SessionState: map[string]interface{}{
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		Variables: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			Variables: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			Variables: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			Variables: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			Variables: make(map[string]interface{}),
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func (wo *WorkflowOrchestrator) executeWorkflowStages(ctx context.Context, spec *WorkflowSpec, session *ExecutionSession, options ExecutionOption) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		var stageResult interface{}
pkg/mcp/internal/orchestration/workflow_orchestrator.go:				SessionState: map[string]interface{}{
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func (wo *WorkflowOrchestrator) executeStage(ctx context.Context, stage *ExecutionStage, session *ExecutionSession, options ExecutionOption) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:	stageResults := make(map[string]interface{})
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			result interface{}
pkg/mcp/internal/orchestration/workflow_orchestrator.go:				var result interface{}
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			var result interface{}
pkg/mcp/internal/orchestration/workflow_orchestrator.go:func (wo *WorkflowOrchestrator) executeTool(ctx context.Context, toolName string, stage *ExecutionStage, session *ExecutionSession) (interface{}, error) {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:	return map[string]interface{}{
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:			Metadata:  map[string]interface{}{"stage_id": stageID},
pkg/mcp/internal/orchestration/tool_creation.go:func CreateTool(deps *ToolDependencies, toolName string) (interface{}, error) {
pkg/mcp/internal/orchestration/analyzer_helper.go:func (b *BuildToolInitializer) SetupAnalyzer(tool interface{}, toolName string) {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok && analyzer != nil {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetFixingMixin(interface{}) }); ok && fixingMixin != nil {
pkg/mcp/internal/orchestration/analyzer_helper.go:func (d *DeployToolInitializer) SetupAnalyzer(tool interface{}, toolName string) {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok {
pkg/mcp/internal/orchestration/analyzer_helper.go:func (s *ScanToolInitializer) SetupAnalyzer(tool interface{}, toolName string) {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok && analyzer != nil {
pkg/mcp/internal/orchestration/session_manager.go:		StageResults:     make(map[string]interface{}),
pkg/mcp/internal/orchestration/session_manager.go:		SharedContext:    make(map[string]interface{}),
pkg/mcp/internal/orchestration/session_manager.go:		ResourceBindings: make(map[string]interface{}),
pkg/mcp/internal/testutil/integration_test_suite.go:	mockOrchestrator.ExecuteFunc = func(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:			if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/testutil/integration_test_suite.go:			if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/testutil/integration_test_suite.go:		return map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:	its.sessionManager.CreateTestSession(context.sessionID, map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:func (ctx *WorkflowTestContext) ExecuteTool(toolName string, args interface{}) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:		func() (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:func (ctx *WorkflowTestContext) ExecuteToolWithProfiling(toolName string, args interface{}) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:	return ctx.profiler.ProfileExecution(toolName, ctx.sessionID, func(context.Context) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:func (ctx *WorkflowTestContext) BenchmarkTool(toolName string, args interface{}, iterations int) profilingtestutil.MockBenchmark {
pkg/mcp/internal/testutil/integration_test_suite.go:	return ctx.profiler.RunBenchmark(toolName, iterations, 1, func(context.Context) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:	testSessions map[string]map[string]interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:		testSessions: make(map[string]map[string]interface{}),
pkg/mcp/internal/testutil/integration_test_suite.go:func (tsm *TestSessionManager) CreateTestSession(sessionID string, metadata map[string]interface{}) {
pkg/mcp/internal/testutil/integration_test_suite.go:func (tsm *TestSessionManager) GetTestSessionMetadata(sessionID string) (map[string]interface{}, bool) {
pkg/mcp/internal/testutil/integration_test_suite.go:	analyzeRepositoryFunc func(sessionID, repoPath string) (interface{}, error)
pkg/mcp/internal/testutil/integration_test_suite.go:	buildImageFunc        func(sessionID, imageName, dockerfilePath string) (interface{}, error)
pkg/mcp/internal/testutil/integration_test_suite.go:	generateManifestsFunc func(sessionID, imageName, appName string, port int, cpuRequest, memoryRequest, cpuLimit, memoryLimit string) (interface{}, error)
pkg/mcp/internal/testutil/integration_test_suite.go:	Args      []interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:	Result    interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) AnalyzeRepository(sessionID, repoPath string) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:	var result interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:		result = map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:		Args:      []interface{}{repoPath},
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) BuildDockerImage(sessionID, imageName, dockerfilePath string) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:	var result interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:		result = map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:		Args:      []interface{}{imageName, dockerfilePath},
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) GenerateKubernetesManifests(sessionID, imageName, appName string, port int, cpuRequest, memoryRequest, cpuLimit, memoryLimit string) (interface{}, error) {
pkg/mcp/internal/testutil/integration_test_suite.go:	var result interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:		result = map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:			"manifests": []map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:		Args:      []interface{}{imageName, appName, port, cpuRequest, memoryRequest, cpuLimit, memoryLimit},
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) SetAnalyzeRepositoryFunc(fn func(sessionID, repoPath string) (interface{}, error)) {
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) SetBuildImageFunc(fn func(sessionID, imageName, dockerfilePath string) (interface{}, error)) {
pkg/mcp/internal/testutil/integration_test_suite.go:func (mpa *MockPipelineAdapter) SetGenerateManifestsFunc(fn func(sessionID, imageName, appName string, port int, cpuRequest, memoryRequest, cpuLimit, memoryLimit string) (interface{}, error)) {
pkg/mcp/internal/testutil/integration_test_suite.go:	analysisResult, err := ctx.ExecuteToolWithProfiling("analyze_repository_atomic", map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:	dockerfileResult, err := ctx.ExecuteToolWithProfiling("generate_dockerfile_atomic", map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:	buildResult, err := ctx.ExecuteToolWithProfiling("build_image_atomic", map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:	manifestResult, err := ctx.ExecuteToolWithProfiling("generate_manifests_atomic", map[string]interface{}{
pkg/mcp/internal/testutil/integration_test_suite.go:	Result    interface{}
pkg/mcp/internal/testutil/integration_test_suite.go:func getNoReflectDispatcher(orchestrator interface{}) interface{} {
pkg/mcp/internal/orchestration/error_router.go:	parameters := make(map[string]interface{})
pkg/mcp/internal/orchestration/error_router.go:			action.Parameters = make(map[string]interface{})
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:	ExecuteFunc func(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error)
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:	Args     interface{}
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:	Session  interface{}
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:	Result   interface{}
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:func (m *MockToolOrchestrator) ExecuteTool(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error) {
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:	var result interface{}
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:		result = map[string]interface{}{
pkg/mcp/internal/orchestration/testutil/mock_orchestrator.go:func (e *ExecutionCapture) CaptureExecution(ctx context.Context, toolName string, args interface{}, sessionID string, fn func() (interface{}, error)) (interface{}, error) {
pkg/mcp/internal/testutil/orchestration_mocks.go:	ExecuteFunc    func(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error)
pkg/mcp/internal/testutil/orchestration_mocks.go:	ValidateFunc   func(toolName string, args interface{}) error
pkg/mcp/internal/testutil/orchestration_mocks.go:	PipelineAdapter interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Args      interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Session   interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Result    interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Args      interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:func (m *MockToolOrchestrator) ExecuteTool(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error) {
pkg/mcp/internal/testutil/orchestration_mocks.go:	var result interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:		result = map[string]interface{}{
pkg/mcp/internal/testutil/orchestration_mocks.go:func (m *MockToolOrchestrator) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/testutil/orchestration_mocks.go:	RegisterFunc  func(name string, tool interface{}) error
pkg/mcp/internal/testutil/orchestration_mocks.go:	GetToolFunc   func(name string) (interface{}, bool)
pkg/mcp/internal/testutil/orchestration_mocks.go:	RegisteredTools   map[string]interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Tool      interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:		RegisteredTools:   make(map[string]interface{}),
pkg/mcp/internal/testutil/orchestration_mocks.go:func (m *MockToolRegistry) RegisterTool(name string, tool interface{}) error {
pkg/mcp/internal/testutil/orchestration_mocks.go:func (m *MockToolRegistry) GetTool(name string) (interface{}, bool) {
pkg/mcp/internal/testutil/orchestration_mocks.go:	m.RegisteredTools = make(map[string]interface{})
pkg/mcp/internal/testutil/orchestration_mocks.go:	CreateFunc   func(toolName string) (interface{}, error)
pkg/mcp/internal/testutil/orchestration_mocks.go:	CreatedTools  map[string]interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Tool      interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:		CreatedTools:  make(map[string]interface{}),
pkg/mcp/internal/testutil/orchestration_mocks.go:func (m *MockToolFactory) CreateTool(toolName string) (interface{}, error) {
pkg/mcp/internal/testutil/orchestration_mocks.go:	var tool interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	m.CreatedTools = make(map[string]interface{})
pkg/mcp/internal/testutil/orchestration_mocks.go:	executeFunc  func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/testutil/orchestration_mocks.go:	validateFunc func(args interface{}) error
pkg/mcp/internal/testutil/orchestration_mocks.go:func (b *TestToolBuilder) WithExecuteFunc(fn func(ctx context.Context, args interface{}) (interface{}, error)) *TestToolBuilder {
pkg/mcp/internal/testutil/orchestration_mocks.go:func (b *TestToolBuilder) WithValidateFunc(fn func(args interface{}) error) *TestToolBuilder {
pkg/mcp/internal/testutil/orchestration_mocks.go:	executeFunc  func(ctx context.Context, args interface{}) (interface{}, error)
pkg/mcp/internal/testutil/orchestration_mocks.go:	validateFunc func(args interface{}) error
pkg/mcp/internal/testutil/orchestration_mocks.go:	Args      interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:	Result    interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:func (t *TestTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/testutil/orchestration_mocks.go:	var result interface{}
pkg/mcp/internal/testutil/orchestration_mocks.go:		result = map[string]interface{}{
pkg/mcp/internal/testutil/orchestration_mocks.go:func (t *TestTool) Validate(args interface{}) error {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	Metadata   map[string]interface{} `json:"metadata,omitempty"`
pkg/mcp/internal/orchestration/checkpoint_manager.go:		SessionState: map[string]interface{}{
pkg/mcp/internal/orchestration/checkpoint_manager.go:			Metadata: map[string]interface{}{
pkg/mcp/internal/orchestration/checkpoint_manager.go:			Metadata: map[string]interface{}{
pkg/mcp/internal/orchestration/checkpoint_manager.go:) map[string]interface{} {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	delta := make(map[string]interface{})
pkg/mcp/internal/orchestration/checkpoint_manager.go:	lastCompleted := lastState["completed_stages"].([]interface{})
pkg/mcp/internal/orchestration/checkpoint_manager.go:	currentResults map[string]interface{},
pkg/mcp/internal/orchestration/checkpoint_manager.go:	lastResults map[string]interface{},
pkg/mcp/internal/orchestration/checkpoint_manager.go:) map[string]interface{} {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	delta := make(map[string]interface{})
pkg/mcp/internal/orchestration/checkpoint_manager.go:// deepEqual performs a deep comparison of two interface{} values
pkg/mcp/internal/orchestration/checkpoint_manager.go:func (cm *BoltCheckpointManager) deepEqual(a, b interface{}) bool {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].([]interface{}); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		ResourceBindings: func() map[string]interface{} {
pkg/mcp/internal/orchestration/checkpoint_manager.go:			interfaceMap := make(map[string]interface{})
pkg/mcp/internal/orchestration/checkpoint_manager.go:	if sharedContext, ok := sessionState["shared_context"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		session.SharedContext = make(map[string]interface{})
pkg/mcp/internal/orchestration/dependency_resolver.go:			Properties: make(map[string]interface{}),
pkg/mcp/internal/orchestration/dependency_resolver.go:				Properties: make(map[string]interface{}),
pkg/mcp/internal/orchestration/dependency_resolver.go:	Properties map[string]interface{} `json:"properties"`
pkg/mcp/internal/orchestration/dependency_resolver.go:	Properties map[string]interface{} `json:"properties"`
pkg/mcp/internal/orchestration/execution_types.go:	Variables   map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/execution_types.go:	Variables        map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/execution_types.go:	Context          map[string]interface{} `json:"context"`
pkg/mcp/internal/orchestration/execution_types.go:	SharedContext    map[string]interface{} `json:"shared_context"`
pkg/mcp/internal/orchestration/execution_types.go:	ResourceBindings map[string]interface{} `json:"resource_bindings"`
pkg/mcp/internal/orchestration/execution_types.go:	StageResults     map[string]interface{} `json:"stage_results"`
pkg/mcp/internal/orchestration/execution_types.go:	ErrorContext     map[string]interface{} `json:"error_context"`
pkg/mcp/internal/orchestration/execution_types.go:	Metadata  map[string]interface{} `json:"metadata"`
pkg/mcp/internal/orchestration/execution_types.go:	Variables  map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/execution_types.go:	State        map[string]interface{} `json:"state"`
pkg/mcp/internal/orchestration/execution_types.go:	SessionState map[string]interface{} `json:"session_state,omitempty"`
pkg/mcp/internal/orchestration/execution_types.go:	StageResults map[string]interface{} `json:"stage_results,omitempty"`
pkg/mcp/internal/orchestration/execution_types.go:		Results: make(map[string]interface{}),
pkg/mcp/internal/orchestration/execution_types.go:		Results:   make(map[string]interface{}),
pkg/mcp/internal/orchestration/execution_types.go:	Variables map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/execution_types.go:	Value     interface{}            `json:"value,omitempty"`
pkg/mcp/internal/orchestration/execution_types.go:	Variables  map[string]interface{} `json:"variables"`
pkg/mcp/internal/orchestration/execution_types.go:	Results         map[string]interface{} `json:"results"`
pkg/mcp/internal/orchestration/execution_types.go:	Results   map[string]interface{} `json:"results"`
pkg/mcp/internal/orchestration/execution_types.go:	Metrics   map[string]interface{} `json:"metrics"`
pkg/mcp/internal/orchestration/execution_types.go:	Variables   map[string]interface{} `json:"variables,omitempty"`
pkg/mcp/internal/orchestration/execution_types.go:) (interface{}, error)
pkg/mcp/internal/orchestration/execution_types.go:	Results   map[string]interface{} `json:"results"`
pkg/mcp/internal/orchestration/execution_types.go:	Metrics   map[string]interface{} `json:"metrics"`
pkg/mcp/internal/orchestration/execution_types.go:func extractArtifacts(toolResult interface{}) []ExecutionArtifact {
pkg/mcp/internal/orchestration/execution_types.go:	if resultMap, ok := toolResult.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/execution_types.go:			// Try to convert []interface{} to []ExecutionArtifact
pkg/mcp/internal/orchestration/execution_types.go:			if artifactInterfaces, ok := artifacts.([]interface{}); ok {
pkg/mcp/internal/orchestration/execution_types.go:func WithVariables(vars map[string]interface{}) ExecutionOption {
pkg/mcp/internal/orchestration/execution_types.go:	StageVars       map[string]interface{} `json:"stage_vars"`
pkg/mcp/internal/orchestration/execution_types.go:	SessionContext  map[string]interface{} `json:"session_context"`
pkg/mcp/internal/observability/tracing_integration.go:func (ti *TracingIntegration) TraceBatch(ctx context.Context, batchName string, items []interface{}, processFn func(context.Context, interface{}) error) error {
pkg/mcp/internal/observability/tracing_integration.go:func (ti *TracingIntegration) TraceCache(ctx context.Context, operation, key string, cacheFn func(context.Context) (interface{}, error)) (interface{}, error) {
pkg/mcp/internal/observability/tracing_integration.go:				tests := []interface{}{"unit", "integration", "e2e"}
pkg/mcp/internal/observability/tracing_integration.go:				return te.integration.TraceBatch(ctx, "test_suite", tests, func(ctx context.Context, test interface{}) error {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) ValidateParameters(template *WorkflowTemplate, parameters map[string]interface{}) error {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) ValidateConditions(template *WorkflowTemplate, context map[string]interface{}) error {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) validateParameterValue(param TemplateParameter, value interface{}) error {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) validateParameterType(paramType string, value interface{}) error {
pkg/mcp/internal/orchestration/template_registry.go:		case []interface{}, []string, []int, []float64:
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(map[string]interface{}); !ok {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) toFloat64(value interface{}) (float64, bool) {
pkg/mcp/internal/orchestration/template_registry.go:func (dtv *DefaultTemplateValidator) evaluateTemplateCondition(condition TemplateCondition, context map[string]interface{}) bool {
pkg/mcp/internal/orchestration/analyzer_helper_test.go:	analyzer    interface{}
pkg/mcp/internal/orchestration/analyzer_helper_test.go:	fixingMixin interface{}
pkg/mcp/internal/orchestration/analyzer_helper_test.go:func (m *mockToolWithSetters) SetAnalyzer(analyzer interface{}) {
pkg/mcp/internal/orchestration/analyzer_helper_test.go:func (m *mockToolWithSetters) SetFixingMixin(mixin interface{}) {
pkg/mcp/internal/orchestration/sprint_a_escalation_rules.go:func (er *DefaultErrorRouter) IsEscalatedOperation(parameters map[string]interface{}) bool {
pkg/mcp/internal/orchestration/sprint_a_escalation_rules.go:func (er *DefaultErrorRouter) GetEscalationSource(parameters map[string]interface{}) string {
pkg/mcp/internal/observability/profiling_test.go:		func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:		func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:	toolExecution := func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:	toolExecution := func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:	toolExecution := func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:	executeFunc    func(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error)
pkg/mcp/internal/observability/profiling_test.go:	validateFunc   func(toolName string, args interface{}) error
pkg/mcp/internal/observability/profiling_test.go:func (m *mockOrchestrator) ExecuteTool(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error) {
pkg/mcp/internal/observability/profiling_test.go:func (m *mockOrchestrator) ValidateToolArgs(toolName string, args interface{}) error {
pkg/mcp/internal/observability/profiling_test.go:func (m *mockOrchestrator) RegisterTool(name string, tool interface{}) error {
pkg/mcp/internal/observability/profiling_test.go:		map[string]interface{}{"key": "value"},
pkg/mcp/internal/observability/profiling_test.go:		map[string]interface{}{"key": "value"},
pkg/mcp/internal/observability/profiling_test.go:		func() (interface{}, error) {
pkg/mcp/internal/orchestration/tool_registry.go:	Instance     core.Tool    `json:"-"` // Use core.Tool interface instead of interface{}
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) RegisterTool(name string, tool interface{}) error {
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) GetTool(name string) (interface{}, error) {
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) registerTool(name string, tool interface{}) {
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) inferParameters(tool interface{}) map[string]string {
pkg/mcp/internal/orchestration/tool_registry.go:		var schemaMap map[string]interface{}
pkg/mcp/internal/orchestration/tool_registry.go:		if properties, ok := schemaMap["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:				if prop, ok := v.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) inferOutputSchema(tool interface{}) map[string]interface{} {
pkg/mcp/internal/orchestration/tool_registry.go:		return map[string]interface{}{}
pkg/mcp/internal/orchestration/tool_registry.go:			return map[string]interface{}{}
pkg/mcp/internal/orchestration/tool_registry.go:		var schemaMap map[string]interface{}
pkg/mcp/internal/orchestration/tool_registry.go:			return map[string]interface{}{}
pkg/mcp/internal/orchestration/tool_registry.go:	return map[string]interface{}{}
pkg/mcp/internal/orchestration/tool_registry.go:				Input: map[string]interface{}{
pkg/mcp/internal/orchestration/tool_registry.go:				Output: map[string]interface{}{
pkg/mcp/internal/orchestration/tool_registry.go:				Input: map[string]interface{}{
pkg/mcp/internal/orchestration/tool_registry.go:				Output: map[string]interface{}{
pkg/mcp/internal/orchestration/tool_registry.go:			Input:       map[string]interface{}{"session_id": "example-session"},
pkg/mcp/internal/orchestration/tool_registry.go:			Output:      map[string]interface{}{"success": true},
pkg/mcp/internal/orchestration/tool_registry.go:func (r *MCPToolRegistry) sanitizeInvopopSchema(schema map[string]interface{}) {
pkg/mcp/internal/orchestration/tool_registry.go:			schema["items"] = map[string]interface{}{
pkg/mcp/internal/orchestration/tool_registry.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:			if propSchema, ok := propValue.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	if items, ok := schema["items"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	if additionalProps, ok := schema["additionalProperties"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_types.go:	ExecuteTool(ctx context.Context, input ToolInput) (interface{}, error)
pkg/mcp/internal/orchestration/tool_types.go:	Parameters map[string]interface{} `json:"parameters"`
pkg/mcp/internal/orchestration/communication_bridge.go:	Data      interface{} `json:"data"`
pkg/mcp/internal/orchestration/communication_bridge.go:				Data: map[string]interface{}{
pkg/mcp/internal/orchestration/communication_bridge.go:		Data: map[string]interface{}{
pkg/mcp/internal/orchestration/communication_bridge.go:					Data: map[string]interface{}{
pkg/mcp/internal/orchestration/communication_bridge.go:				Data: map[string]interface{}{
pkg/mcp/internal/orchestration/communication_bridge.go:			Data: map[string]interface{}{
pkg/mcp/internal/orchestration/communication_bridge.go:func (dcb *DefaultCommunicationBridge) GetStats() map[string]interface{} {
pkg/mcp/internal/orchestration/communication_bridge.go:	stats := map[string]interface{}{
pkg/mcp/internal/utils/workspace.go:	Metadata        map[string]interface{} `json:"metadata"`
pkg/mcp/internal/utils/workspace.go:func (wm *WorkspaceManager) SandboxedAnalysis(ctx context.Context, sessionID, repoPath string, options interface{}) (interface{}, error) {
pkg/mcp/internal/utils/workspace.go:func (wm *WorkspaceManager) SandboxedBuild(ctx context.Context, sessionID, dockerfilePath string, options interface{}) (interface{}, error) {
pkg/mcp/internal/utils/slog_utils.go:		Fields:    make(map[string]interface{}),
pkg/mcp/internal/observability/distributed_tracing.go:	Attributes   map[string]interface{} `json:"attributes,omitempty"`
pkg/mcp/internal/utils/validation_standardizer.go:	Session      interface{} // The actual session object
pkg/mcp/internal/utils/validation_standardizer.go:	Value       interface{}       `json:"value"`
pkg/mcp/internal/utils/validation_standardizer.go:func (vr *ValidationResult) AddError(field, message, code string, value interface{}) {
pkg/mcp/internal/utils/validation_standardizer.go:func (vr *ValidationResult) AddWarning(field, message, code string, value interface{}) {
pkg/mcp/internal/utils/validation_standardizer.go:func (vr *ValidationResult) AddInfo(field, message, code string, value interface{}) {
pkg/mcp/internal/utils/validation_standardizer.go:		GetSession(sessionID string) (interface{}, error)
pkg/mcp/internal/utils/validation_standardizer.go:	args interface{},
pkg/mcp/internal/conversation/chat_tool_test.go:		args        interface{}
pkg/mcp/internal/conversation/chat_tool_test.go:							Options: []map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool_test.go:							Progress:  map[string]interface{}{"completed": 50},
pkg/mcp/internal/conversation/chat_tool_test.go:		args        interface{}
pkg/mcp/internal/conversation/chat_tool_test.go:		Options: []map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool_test.go:		Progress:  map[string]interface{}{"completed": 75},
pkg/mcp/internal/utils/ring_buffer.go:	Fields    map[string]interface{} `json:"fields,omitempty"`
pkg/mcp/internal/observability/interface.go:	AddSpanAttribute(spanCtx SpanContext, key string, value interface{})
pkg/mcp/internal/observability/interface.go:	SetAttribute(key string, value interface{})
pkg/mcp/internal/observability/interface.go:func (n *NoOpTracingProvider) AddSpanAttribute(spanCtx SpanContext, key string, value interface{}) {}
pkg/mcp/internal/observability/interface.go:func (n *NoOpSpanContext) SetAttribute(key string, value interface{}) {}
pkg/mcp/utils/validation_utils.go:	var js interface{}
pkg/mcp/internal/conversation/chat_tool.go:	Options   []map[string]interface{} `json:"options,omitempty"`
pkg/mcp/internal/conversation/chat_tool.go:	Progress  map[string]interface{}   `json:"progress,omitempty"`
pkg/mcp/internal/conversation/chat_tool.go:func (ct *ChatTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/conversation/chat_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool.go:				Input: map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool.go:				Output: map[string]interface{}{
pkg/mcp/internal/conversation/chat_tool.go:func (ct *ChatTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/observability/integration.go:	ExecuteTool(ctx context.Context, toolName string, args interface{}, session interface{}) (interface{}, error)
pkg/mcp/internal/observability/integration.go:	Result    interface{}
pkg/mcp/internal/observability/integration.go:	args interface{},
pkg/mcp/internal/observability/integration.go:	session interface{},
pkg/mcp/internal/observability/integration.go:) (interface{}, error) {
pkg/mcp/internal/observability/integration.go:	args interface{},
pkg/mcp/internal/observability/integration.go:	session interface{},
pkg/mcp/internal/observability/integration.go:	toolExecution := func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/integration.go:	args interface{},
pkg/mcp/internal/observability/integration.go:	session interface{},
pkg/mcp/internal/observability/integration.go:	args interface{},
pkg/mcp/internal/observability/integration.go:	session interface{},
pkg/mcp/internal/observability/integration.go:func (po *ProfiledOrchestrator) extractSessionID(session interface{}) string {
pkg/mcp/internal/observability/integration.go:// getTypeName returns the type name of an interface{}
pkg/mcp/internal/observability/integration.go:func getTypeName(v interface{}) string {
pkg/mcp/internal/observability/integration.go:	execution func() (interface{}, error),
pkg/mcp/internal/observability/integration.go:) (interface{}, error) {
pkg/mcp/internal/utils/mcperror_test.go:	data := map[string]interface{}{"field": "image_name"}
pkg/mcp/internal/utils/mcperror_test.go:	data, ok := err.Data.(map[string]interface{})
pkg/mcp/internal/utils/mcperror.go:	Data    interface{}         `json:"data,omitempty"`
pkg/mcp/internal/utils/mcperror.go:func (e *MCPError) GetData() interface{} {
pkg/mcp/internal/utils/mcperror.go:func NewWithData(code v20250326.ErrorCode, message string, data interface{}) *MCPError {
pkg/mcp/internal/utils/mcperror.go:	var data interface{}
pkg/mcp/internal/utils/mcperror.go:		data = map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	data := map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	data := map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	data := map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	data := map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	return NewWithData(CodeSessionNotFound, "session not found", map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	return NewWithData(CodeSessionExpired, "session expired", map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:	return NewWithData(CodeRequiredFieldMissing, "required field missing", map[string]interface{}{
pkg/mcp/internal/utils/mcperror.go:		if data, ok := mcpErr.Data.(map[string]interface{}); ok {
pkg/mcp/internal/utils/mcperror.go:func (e *MCPError) ToMCPErrorResponse(id interface{}) *v20250326.ErrorResponse {
pkg/mcp/internal/observability/otel_middleware.go:func convertAttributesToOTEL(attributes map[string]interface{}) []attribute.KeyValue {
pkg/mcp/internal/observability/otel_middleware.go:func (m *OTELMiddleware) StartToolSpan(ctx context.Context, toolName string, attributes map[string]interface{}) *ToolExecutionSpan {
pkg/mcp/internal/observability/otel_middleware.go:func (s *ToolExecutionSpan) AddEvent(name string, attributes map[string]interface{}) {
pkg/mcp/internal/observability/otel_middleware.go:func (s *ToolExecutionSpan) SetAttributes(attributes map[string]interface{}) {
pkg/mcp/internal/observability/otel_middleware.go:func (m *OTELMiddleware) StartRequestSpan(ctx context.Context, method string, attributes map[string]interface{}) *RequestSpan {
pkg/mcp/internal/observability/otel_middleware.go:func (r *RequestSpan) AddEvent(name string, attributes map[string]interface{}) {
pkg/mcp/internal/observability/otel_middleware.go:func (r *RequestSpan) SetAttributes(attributes map[string]interface{}) {
pkg/mcp/internal/observability/otel_middleware.go:func (c *ConversationSpan) AddEvent(name string, attributes map[string]interface{}) {
pkg/mcp/internal/observability/otel_middleware.go:func (msi *MCPServerInstrumentation) InstrumentTool(ctx context.Context, toolName string, fn func(context.Context) (interface{}, error)) (interface{}, error) {
pkg/mcp/internal/observability/otel_middleware.go:	span := msi.middleware.StartToolSpan(ctx, toolName, map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware.go:	span.SetAttributes(map[string]interface{}{
pkg/mcp/internal/utils/validation_standardizer_test.go:		args          interface{}
pkg/mcp/internal/observability/otel_middleware_test.go:		updates := map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span := middleware.StartToolSpan(ctx, "test_tool", map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span.AddEvent("tool_started", map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span.SetAttributes(map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span := middleware.StartRequestSpan(ctx, "tools/call", map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span.SetAttributes(map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		span.AddEvent("stage_started", map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		expectedResult := map[string]interface{}{
pkg/mcp/internal/observability/otel_middleware_test.go:		result, err := instrumentation.InstrumentTool(ctx, "test_tool", func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/otel_middleware_test.go:		result, err := instrumentation.InstrumentTool(ctx, "failing_tool", func(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/observability/otel_middleware_test.go:		telemetryMgr.UpdateOTELConfig(map[string]interface{}{
pkg/mcp/internal/utils/ring_buffer_test.go:			Fields:    map[string]interface{}{"path": "/api/users"},
pkg/mcp/internal/utils/ring_buffer_test.go:			Fields:    map[string]interface{}{"table": "users"},
pkg/mcp/internal/utils/ring_buffer_test.go:			Fields:    map[string]interface{}{"key": "config"},
pkg/mcp/internal/orchestration/retry_manager.go:	Execute(ctx context.Context) (interface{}, error)
pkg/mcp/internal/orchestration/retry_manager.go:	Result       interface{}    `json:"result,omitempty"`
pkg/mcp/internal/orchestration/retry_manager.go:func (w *WorkflowRetryableOperation) Execute(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/orchestration/retry_manager.go:		w.session.ErrorContext = make(map[string]interface{})
pkg/mcp/internal/orchestration/retry_manager.go:	w.session.ErrorContext[retryKey] = map[string]interface{}{
pkg/mcp/internal/orchestration/retry_manager.go:func (t *ToolRetryableOperation) Execute(ctx context.Context) (interface{}, error) {
pkg/mcp/internal/orchestration/retry_manager.go:func CreateRetryPolicy(config map[string]interface{}) *RetryPolicyExecution {
pkg/mcp/internal/utils/log_capture.go:		Fields:    make(map[string]interface{}),
pkg/mcp/internal/utils/log_capture.go:		Fields: make(map[string]interface{}),
pkg/mcp/internal/utils/schema_utils.go:func RemoveCopilotIncompatibleFromSchema(schema *jsonschema.Schema) map[string]interface{} {
pkg/mcp/internal/utils/schema_utils.go:		return make(map[string]interface{})
pkg/mcp/internal/utils/schema_utils.go:	var schemaMap map[string]interface{}
pkg/mcp/internal/utils/schema_utils.go:		return make(map[string]interface{})
pkg/mcp/internal/utils/schema_utils.go:func AddMissingArrayItems(schema map[string]interface{}) {
pkg/mcp/internal/utils/schema_utils.go:		case map[string]interface{}:
pkg/mcp/internal/utils/schema_utils.go:					v["items"] = map[string]interface{}{"type": "string"}
pkg/mcp/internal/utils/schema_utils.go:		case []interface{}:
pkg/mcp/internal/utils/schema_utils.go:				if m, ok := elem.(map[string]interface{}); ok {
pkg/mcp/internal/observability/telemetry_manager.go:func (tm *TelemetryManager) GetMetrics() (map[string]interface{}, error) {
pkg/mcp/internal/observability/telemetry_manager.go:	metrics := make(map[string]interface{})
pkg/mcp/internal/observability/telemetry_manager.go:func (tm *TelemetryManager) UpdateOTELConfig(updates map[string]interface{}) {
pkg/mcp/internal/server/registry.go:func (t *CheckRegistryHealthTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/server/registry.go:func (t *CheckRegistryHealthTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/server/registry.go:func (t *GetJobStatusTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/server/registry.go:func (t *GetJobStatusTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/server/registry.go:func (t *GetLogsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/server/registry.go:func (t *GetLogsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/observability/tool_profiler.go:	Metadata  map[string]interface{}
pkg/mcp/internal/observability/tool_profiler.go:	Result  interface{}
pkg/mcp/internal/observability/tool_profiler.go:		Metadata:       make(map[string]interface{}),
pkg/mcp/internal/observability/tool_profiler.go:	execution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/tool_profiler.go:func (p *ToolProfiler) SetMetadata(toolName, sessionID, key string, value interface{}) {
pkg/mcp/internal/server/core.go:	transport        interface{} // stdio or http transport
pkg/mcp/internal/server/core.go:	server interface{}
pkg/mcp/internal/server/core.go:	var mcpTransport interface{}
pkg/mcp/internal/server/core.go:	if setter, ok := s.transport.(interface{ SetHandler(interface{}) }); ok {
pkg/mcp/internal/observability/benchmarks.go:	toolExecution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/benchmarks.go:	toolExecution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/benchmarks.go:	toolExecution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/benchmarks.go:	toolExecution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/benchmarks.go:	toolExecution func(context.Context) (interface{}, error),
pkg/mcp/internal/observability/manifest_validator.go:	Details  map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/observability/manifest_validator.go:	Details    map[string]interface{} `json:"details,omitempty"`
pkg/mcp/internal/observability/manifest_validator.go:	var manifest map[string]interface{}
pkg/mcp/internal/observability/manifest_validator.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateBasicStructure(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:					Details: map[string]interface{}{
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateRequiredFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateDeploymentFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	templateSpec, ok := template["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	containers, ok := templateSpec["containers"].([]interface{})
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateServiceFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	ports, ok := spec["ports"].([]interface{})
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateConfigMapFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:			if dataMap, ok := data.(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateSecretFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateIngressFields(manifest map[string]interface{}, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:		if rulesList, ok := rules.([]interface{}); ok && len(rulesList) == 0 {
pkg/mcp/internal/observability/manifest_validator.go:		Details: map[string]interface{}{
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateRequiredLabels(manifest map[string]interface{}, requiredLabels []string, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:	metadata, ok := manifest["metadata"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	labels, ok := metadata["labels"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:		labels = make(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:				Details: map[string]interface{}{
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) validateForbiddenFields(manifest map[string]interface{}, forbiddenFields []string, result *ValidationResult) {
pkg/mcp/internal/observability/manifest_validator.go:				Details: map[string]interface{}{
pkg/mcp/internal/observability/manifest_validator.go:func (mv *ManifestValidator) hasField(manifest map[string]interface{}, fieldPath string) bool {
pkg/mcp/internal/observability/manifest_validator.go:		next, ok := current[part].(map[string]interface{})
pkg/mcp/internal/build/iterative_fixer.go:	fixHistory  []interface{}
pkg/mcp/internal/build/iterative_fixer.go:		fixHistory:  make([]interface{}, 0),
pkg/mcp/internal/build/iterative_fixer.go:		ErrorDetails:    make(map[string]interface{}),
pkg/mcp/internal/build/iterative_fixer.go:		AttemptHistory:  make([]interface{}, 0),
pkg/mcp/internal/build/iterative_fixer.go:		EnvironmentInfo: make(map[string]interface{}),
pkg/mcp/internal/build/iterative_fixer.go:		SessionMetadata: make(map[string]interface{}),
pkg/mcp/internal/build/iterative_fixer.go:		AllAttempts:   []interface{}{},
pkg/mcp/internal/build/iterative_fixer.go:		Context:   map[string]interface{}{"strategy": strategy.Name},
pkg/mcp/internal/server/telemetry.go:func (s *Server) GetLogger() interface{} {
pkg/mcp/internal/server/telemetry.go:func (t *GetTelemetryMetricsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/server/telemetry.go:func (t *GetTelemetryMetricsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/utils/sanitization_utils.go:func SanitizeJSONSchema(schema map[string]interface{}) map[string]interface{} {
pkg/mcp/utils/sanitization_utils.go:		return make(map[string]interface{})
pkg/mcp/utils/sanitization_utils.go:	result := make(map[string]interface{})
pkg/mcp/utils/sanitization_utils.go:func sanitizeSchemaRecursive(schema map[string]interface{}) {
pkg/mcp/utils/sanitization_utils.go:			schema["items"] = map[string]interface{}{
pkg/mcp/utils/sanitization_utils.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:			if propMap, ok := propSchema.(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:	if items, ok := schema["items"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:	if definitions, ok := schema["definitions"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:			if defMap, ok := defSchema.(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:func SanitizeJSONValue(value interface{}) interface{} {
pkg/mcp/utils/sanitization_utils.go:	case map[string]interface{}:
pkg/mcp/utils/sanitization_utils.go:		sanitized := make(map[string]interface{})
pkg/mcp/utils/sanitization_utils.go:	case []interface{}:
pkg/mcp/utils/sanitization_utils.go:		sanitized := make([]interface{}, len(v))
pkg/mcp/internal/observability/collector.go:func (c *Collector) CollectBuildDiagnostics(ctx context.Context, buildContext string) map[string]interface{} {
pkg/mcp/internal/observability/collector.go:	diag := make(map[string]interface{})
pkg/mcp/internal/observability/collector.go:func (c *Collector) CollectDeploymentDiagnostics(ctx context.Context, namespace string) map[string]interface{} {
pkg/mcp/internal/observability/collector.go:	diag := make(map[string]interface{})
pkg/mcp/internal/observability/collector.go:func (c *Collector) getDockerInfo() (map[string]interface{}, error) {
pkg/mcp/internal/observability/collector.go:	info := make(map[string]interface{})
pkg/mcp/internal/observability/collector.go:func (c *Collector) getNamespaceQuota(namespace string) (map[string]interface{}, error) {
pkg/mcp/internal/observability/collector.go:	quota := make(map[string]interface{})
pkg/mcp/internal/server/unified_server.go:	args map[string]interface{},
pkg/mcp/internal/server/unified_server.go:) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"message": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"context": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"limit": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"workflow_name": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"workflow_spec": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"variables": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"options": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"category": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:				"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:					"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:func (s *UnifiedMCPServer) executeChatTool(ctx context.Context, args map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:func (s *UnifiedMCPServer) executeWorkflowTool(ctx context.Context, args map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:			// Convert map[string]string to map[string]interface{}
pkg/mcp/internal/server/unified_server.go:			interfaceVars := make(map[string]interface{})
pkg/mcp/internal/server/unified_server.go:	if workflowSpec, ok := args["workflow_spec"].(map[string]interface{}); ok {
pkg/mcp/internal/server/unified_server.go:func (s *UnifiedMCPServer) listWorkflows() (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:func (s *UnifiedMCPServer) getWorkflowStatus(args map[string]interface{}) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:func (s *UnifiedMCPServer) buildInputSchema(metadata *orchestration.ToolMetadata) map[string]interface{} {
pkg/mcp/internal/server/unified_server.go:	schema := map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:		"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:			"session_id": map[string]interface{}{
pkg/mcp/internal/server/unified_server.go:		var fields map[string]interface{}
pkg/mcp/internal/server/unified_server.go:			properties := schema["properties"].(map[string]interface{})
pkg/mcp/internal/server/unified_server.go:	InputSchema map[string]interface{} `json:"inputSchema"`
pkg/mcp/internal/server/unified_server.go:func (dsm *directSessionManager) GetSession(sessionID string) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:func (dsm *directSessionManager) UpdateSession(sessionID string, updater func(interface{})) error {
pkg/mcp/internal/server/unified_server.go:func (adapter *RegistryAdapter) Register(name string, factory func() interface{}) error {
pkg/mcp/internal/server/unified_server.go:func (adapter *RegistryAdapter) Get(name string) (func() interface{}, error) {
pkg/mcp/internal/server/unified_server.go:	factory := func() interface{} {
pkg/mcp/internal/server/unified_server.go:func (adapter *RegistryAdapter) Create(name string) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:func (adapter *RegistryAdapter) GetTool(name string) (interface{}, error) {
pkg/mcp/internal/server/unified_server.go:// Helper function to convert parameters from map[string]interface{} to map[string]string
pkg/mcp/internal/server/unified_server.go:func convertParametersMapToString(params map[string]interface{}) map[string]string {
pkg/mcp/internal/server/unified_server.go:// Helper function to convert interface{} to map[string]interface{}
pkg/mcp/internal/server/unified_server.go:func convertToMapStringInterface(input interface{}) map[string]interface{} {
pkg/mcp/internal/server/unified_server.go:	if result, ok := input.(map[string]interface{}); ok {
pkg/mcp/internal/server/unified_server.go:	return make(map[string]interface{})
pkg/mcp/internal/observability/otel_config.go:func (p *OTELProvider) UpdateConfig(updates map[string]interface{}) {
pkg/mcp/internal/build/buildkit_strategy.go:func (s *BuildKitStrategy) ScoreCompatibility(info interface{}) int {
pkg/mcp/internal/observability/progress_tracker.go:	Data        map[string]interface{} `json:"data,omitempty"`
pkg/mcp/internal/observability/progress_tracker.go:	UpdateWithData(operationID string, progress float64, message string, data map[string]interface{})
pkg/mcp/internal/observability/progress_tracker.go:	Complete(operationID string, result interface{}, err error)
pkg/mcp/internal/observability/progress_tracker.go:	Result      interface{}      `json:"result,omitempty"`
pkg/mcp/internal/observability/progress_tracker.go:	pt.UpdateWithData(operationID, progress, message, map[string]interface{}{
pkg/mcp/internal/observability/progress_tracker.go:func (pt *ComprehensiveProgressTracker) UpdateWithData(operationID string, progress float64, message string, data map[string]interface{}) {
pkg/mcp/internal/observability/progress_tracker.go:func (pt *ComprehensiveProgressTracker) Complete(operationID string, result interface{}, err error) {
pkg/mcp/internal/observability/progress_tracker.go:		Data: map[string]interface{}{
pkg/mcp/internal/build/syntax_validator.go:func (v *SyntaxValidator) Analyze(lines []string, context ValidationContext) interface{} {
pkg/mcp/internal/build/ai_context_enhancer_test.go:		InputMetadata:     map[string]interface{}{"size": 1024},
pkg/mcp/internal/build/ai_context_enhancer_test.go:		OutputMetadata:   map[string]interface{}{"size": 2048},
pkg/mcp/internal/build/error_router.go:	SharedContext  map[string]interface{} `json:"shared_context"`
pkg/mcp/internal/build/error_router.go:	ToolContext    map[string]interface{} `json:"tool_context"`
pkg/mcp/internal/build/error_router.go:	TransformData   map[string]interface{} `json:"transform_data,omitempty"`
pkg/mcp/internal/build/error_router.go:	ContextUpdates  map[string]interface{} `json:"context_updates,omitempty"`
pkg/mcp/internal/build/error_router.go:	PublishErrorEvent(eventType string, data map[string]interface{})
pkg/mcp/internal/build/error_router.go:		if contextMap, ok := sharedData.(map[string]interface{}); ok {
pkg/mcp/internal/build/error_router.go:		er.eventBus.PublishErrorEvent("error_routed", map[string]interface{}{
pkg/mcp/internal/build/error_router.go:func (er *ErrorRouter) evaluateConditions(errorCtx *ErrorContext, conditions map[string]interface{}) bool {
pkg/mcp/internal/build/error_router.go:		ContextUpdates: make(map[string]interface{}),
pkg/mcp/internal/build/error_router.go:	decision.ContextUpdates["previous_error"] = map[string]interface{}{
pkg/mcp/internal/build/error_router.go:	decision.ContextUpdates["routing_metadata"] = map[string]interface{}{
pkg/mcp/internal/build/error_router.go:	routingData := map[string]interface{}{
pkg/mcp/internal/build/error_router.go:			TransformData: map[string]interface{}{
pkg/mcp/internal/build/error_router.go:			ContextUpdates: map[string]interface{}{
pkg/mcp/internal/build/error_router.go:				TransformData: map[string]interface{}{
pkg/mcp/internal/build/error_router.go:				ContextUpdates: map[string]interface{}{
pkg/mcp/internal/build/error_router.go:				TransformData: map[string]interface{}{
pkg/mcp/internal/build/error_router.go:func (er *ErrorRouter) GetRoutingHistory(ctx context.Context, sessionID string) ([]map[string]interface{}, error) {
pkg/mcp/internal/build/error_router.go:	if historyData, ok := data.([]map[string]interface{}); ok {
pkg/mcp/internal/build/error_router.go:	if routingData, ok := data.(map[string]interface{}); ok {
pkg/mcp/internal/build/error_router.go:		return []map[string]interface{}{routingData}, nil
pkg/mcp/utils/logging_test.go:		var result map[string]interface{}
pkg/mcp/utils/logging.go:	Value interface{}
pkg/mcp/utils/logging.go:func Any(key string, val interface{}) Field {
pkg/mcp/utils/typed_validation.go:	context map[string]interface{}
pkg/mcp/utils/typed_validation.go:	Value       interface{}
pkg/mcp/utils/typed_validation.go:func (tvr *TypedValidationResult) AddError(field, message, code string, value interface{}) {
pkg/mcp/internal/build/unified_analyzer.go:	Context       map[string]interface{} `json:"context"`
pkg/mcp/internal/build/unified_analyzer.go:	AnalysisMetadata map[string]interface{} `json:"analysis_metadata"`
pkg/mcp/internal/build/unified_analyzer.go:	Metadata           map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/unified_analyzer.go:	Context         map[string]interface{}  `json:"context"`
pkg/mcp/internal/build/unified_analyzer.go:	Metadata         map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/unified_analyzer.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/unified_analyzer.go:	Attributes   map[string]interface{} `json:"attributes"`
pkg/mcp/internal/build/unified_analyzer.go:	Context     map[string]interface{} `json:"context"`
pkg/mcp/internal/build/unified_analyzer.go:	Context          map[string]interface{} `json:"context"`
pkg/mcp/internal/build/unified_analyzer.go:	Environment  map[string]interface{} `json:"environment"`
pkg/mcp/internal/build/tag_image_atomic.go:func (t *AtomicTagImageTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/build/tag_image_atomic.go:	tagArgs := map[string]interface{}{
pkg/mcp/internal/build/tag_image_atomic.go:func (t *AtomicTagImageTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/build/tag_image_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/build/tag_image_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/build/tag_image_atomic.go:	tagArgs := map[string]interface{}{
pkg/mcp/internal/build/tag_image_atomic.go:func (t *AtomicTagImageTool) performTag(ctx context.Context, session *core.SessionState, args AtomicTagImageArgs, result *AtomicTagImageResult, reporter interface{}) error {
pkg/mcp/internal/build/tag_image_atomic.go:	tagArgs := map[string]interface{}{
pkg/mcp/internal/build/cross_tool_knowledge_base.go:func (kb *CrossToolKnowledgeBase) GetInsightStatistics() map[string]interface{} {
pkg/mcp/internal/build/cross_tool_knowledge_base.go:	stats := map[string]interface{}{
pkg/mcp/internal/build/cross_tool_knowledge_base.go:func (kb *CrossToolKnowledgeBase) Export() map[string]interface{} {
pkg/mcp/internal/build/cross_tool_knowledge_base.go:	return map[string]interface{}{
pkg/mcp/internal/build/ai_context_enhancer.go:	InputMetadata     map[string]interface{} `json:"input_metadata"`
pkg/mcp/internal/build/ai_context_enhancer.go:	OutputMetadata   map[string]interface{} `json:"output_metadata"`
pkg/mcp/internal/build/ai_context_enhancer.go:	ErrorMetadata     map[string]interface{} `json:"error_metadata"`
pkg/mcp/internal/build/ai_context_enhancer.go:	Metadata      map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/ai_context_enhancer.go:	toolResult interface{},
pkg/mcp/internal/build/ai_context_enhancer.go:func (e *AIContextEnhancer) analyzeInput(inputData interface{}) *InputAnalysis {
pkg/mcp/internal/build/ai_context_enhancer.go:		InputMetadata:     make(map[string]interface{}),
pkg/mcp/internal/build/ai_context_enhancer.go:	if inputMap, ok := inputData.(map[string]interface{}); ok {
pkg/mcp/internal/build/ai_context_enhancer.go:func (e *AIContextEnhancer) analyzeOutput(outputData interface{}) *OutputAnalysis {
pkg/mcp/internal/build/ai_context_enhancer.go:		OutputMetadata:   make(map[string]interface{}),
pkg/mcp/internal/build/ai_context_enhancer.go:	if outputMap, ok := outputData.(map[string]interface{}); ok {
pkg/mcp/internal/build/ai_context_enhancer.go:		ErrorMetadata:     make(map[string]interface{}),
pkg/mcp/internal/build/ai_context_enhancer.go:func (e *AIContextEnhancer) extractInputData(_ context.Context) interface{} {
pkg/mcp/internal/build/dockerfile_common.go:	Analyze(lines []string, context ValidationContext) interface{}
pkg/mcp/internal/build/build_image_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/build/build_image_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/build/build_image_atomic.go:func (t *AtomicBuildImageTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/build/build_image_atomic.go:func (t *AtomicBuildImageTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/retry/coordinator_test.go:	strategies, stratErr := provider.GetFixStrategies(context.Background(), err, map[string]interface{}{
pkg/mcp/internal/retry/coordinator_test.go:	strategies, stratErr := provider.GetFixStrategies(context.Background(), err, map[string]interface{}{})
pkg/mcp/internal/retry/coordinator_test.go:	strategies, stratErr := provider.GetFixStrategies(context.Background(), err, map[string]interface{}{})
pkg/mcp/internal/retry/coordinator_test.go:func (m *MockFixProvider) GetFixStrategies(_ context.Context, _ error, _ map[string]interface{}) ([]FixStrategy, error) {
pkg/mcp/internal/retry/coordinator_test.go:func (m *MockFixProvider) ApplyFix(_ context.Context, _ FixStrategy, _ map[string]interface{}) error {
pkg/mcp/internal/build/service.go:	schemas    map[string]interface{}
pkg/mcp/internal/build/service.go:	validators map[string]interface{}
pkg/mcp/internal/build/service.go:		schemas:    make(map[string]interface{}),
pkg/mcp/internal/build/service.go:		validators: make(map[string]interface{}),
pkg/mcp/internal/build/service.go:func (s *ValidationService) RegisterValidator(name string, validator interface{}) {
pkg/mcp/internal/build/service.go:func (s *ValidationService) RegisterSchema(name string, schema interface{}) {
pkg/mcp/internal/errors/core_error.go:	Context map[string]interface{} `json:"context,omitempty"` // Basic context information
pkg/mcp/internal/errors/core_error.go:	Input   map[string]interface{} `json:"input,omitempty"`   // Input that caused the error
pkg/mcp/internal/errors/core_error.go:	Output  map[string]interface{} `json:"output,omitempty"`  // Any partial output
pkg/mcp/internal/errors/core_error.go:func (e *CoreError) WithContext(key string, value interface{}) *CoreError {
pkg/mcp/internal/errors/core_error.go:		e.Context = make(map[string]interface{})
pkg/mcp/internal/errors/core_error.go:func (e *CoreError) WithInput(input map[string]interface{}) *CoreError {
pkg/mcp/internal/errors/core_error.go:func (e *CoreError) WithOutput(output map[string]interface{}) *CoreError {
pkg/mcp/internal/errors/core_error.go:		Context:     make(map[string]interface{}),
pkg/mcp/internal/errors/core_error.go:func Newf(module string, category ErrorCategory, format string, args ...interface{}) *CoreError {
pkg/mcp/internal/errors/core_error.go:		Context:     make(map[string]interface{}),
pkg/mcp/internal/errors/core_error.go:		Context:     make(map[string]interface{}),
pkg/mcp/internal/retry/comprehensive_test.go:	testProvider.OnApplyFix = func(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/comprehensive_test.go:	OnApplyFix func(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error
pkg/mcp/internal/retry/comprehensive_test.go:func (p *TestFixProvider) GetFixStrategies(ctx context.Context, err error, context map[string]interface{}) ([]FixStrategy, error) {
pkg/mcp/internal/retry/comprehensive_test.go:func (p *TestFixProvider) ApplyFix(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/utils/common.go:func NewError(message string, context ...map[string]interface{}) error {
pkg/mcp/internal/session/label_manager.go:	err = lm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/label_manager.go:	err = lm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/label_manager.go:	err = lm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/label_manager.go:	err = lm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/label_manager.go:	err = lm.sessionManager.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/errors/orchestration.go:	Value         interface{} `json:"value"`
pkg/mcp/internal/errors/orchestration.go:	Parameters  map[string]interface{} `json:"parameters,omitempty"`
pkg/mcp/internal/retry/coordinator.go:	Parameters  map[string]interface{} `json:"parameters"`
pkg/mcp/internal/retry/coordinator.go:	Context   map[string]interface{} `json:"context,omitempty"`
pkg/mcp/internal/retry/coordinator.go:	Context        map[string]interface{} `json:"context"`
pkg/mcp/internal/retry/coordinator.go:	GetFixStrategies(ctx context.Context, err error, context map[string]interface{}) ([]FixStrategy, error)
pkg/mcp/internal/retry/coordinator.go:	ApplyFix(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error
pkg/mcp/internal/retry/coordinator.go:			New: func() interface{} {
pkg/mcp/internal/retry/coordinator.go:		Context:        make(map[string]interface{}),
pkg/mcp/internal/retry/coordinator.go:		Context:        make(map[string]interface{}),
pkg/mcp/internal/build/image_validator.go:func (v *ImageValidator) Analyze(lines []string, context ValidationContext) interface{} {
pkg/mcp/internal/build/image_validator.go:	var grypeResult map[string]interface{}
pkg/mcp/internal/build/image_validator.go:	if matches, ok := grypeResult["matches"].([]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:			if matchMap, ok := match.(map[string]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:				if vuln, ok := matchMap["vulnerability"].(map[string]interface{}); ok {
pkg/mcp/internal/session/analytics_test.go:	err = sessionMgr.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/analytics_test.go:			state.Metadata = map[string]interface{}{
pkg/mcp/internal/session/analytics_test.go:		err = sessionMgr.UpdateSession(sessionState.SessionID, func(s interface{}) {
pkg/mcp/internal/session/analytics_test.go:				state.Metadata = map[string]interface{}{
pkg/mcp/internal/session/analytics_test.go:		err = sessionMgr.UpdateSession(sessionState.SessionID, func(s interface{}) {
pkg/mcp/internal/session/analytics_test.go:				state.Metadata = map[string]interface{}{
pkg/mcp/internal/session/analytics_test.go:	err = sessionMgr.UpdateSession(sessionState.SessionID, func(s interface{}) {
pkg/mcp/internal/session/analytics_test.go:			state.Metadata = map[string]interface{}{
pkg/mcp/internal/session/analytics_test.go:	err = sessionMgr.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/analytics_test.go:			state.Metadata = map[string]interface{}{
pkg/mcp/internal/build/failure_predictor.go:func (fp *FailurePredictor) predictEnvironmentFailures(environment map[string]interface{}) []*PredictedFailure {
pkg/mcp/internal/retry/integration.go:func BuildOperation(ctx context.Context, buildContext map[string]interface{}, fn func(ctx context.Context, retryCtx *Context) error) error {
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	var networkPolicy map[string]interface{}
pkg/mcp/internal/customizer/k8s_networkpolicy.go:func (nc *NetworkPolicyCustomizer) applyCustomizations(networkPolicy *map[string]interface{}, options NetworkPolicyCustomizationOptions) error {
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		np["spec"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	spec := np["spec"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:			spec["podSelector"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		podSelector := spec["podSelector"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		ingressRules := make([]interface{}, len(options.Ingress))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:			ingressRule := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:				ports := make([]interface{}, len(rule.Ports))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:					portMap := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:				fromRules := make([]interface{}, len(rule.From))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:					fromMap := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						fromMap["podSelector"] = map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						fromMap["namespaceSelector"] = map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						ipBlock := map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		egressRules := make([]interface{}, len(options.Egress))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:			egressRule := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:				ports := make([]interface{}, len(rule.Ports))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:					portMap := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:				toRules := make([]interface{}, len(rule.To))
pkg/mcp/internal/customizer/k8s_networkpolicy.go:					toMap := make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						toMap["podSelector"] = map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						toMap["namespaceSelector"] = map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:						ipBlock := map[string]interface{}{
pkg/mcp/internal/customizer/k8s_networkpolicy.go:func (nc *NetworkPolicyCustomizer) applyLabels(networkPolicy *map[string]interface{}, labels map[string]string) {
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		np["metadata"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadata := np["metadata"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		metadata["labels"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadataLabels := metadata["labels"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:func (nc *NetworkPolicyCustomizer) applyAnnotations(networkPolicy *map[string]interface{}, annotations map[string]string) {
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		np["metadata"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadata := np["metadata"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		metadata["annotations"] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadataAnnotations := metadata["annotations"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_service.go:	var service map[string]interface{}
pkg/mcp/internal/customizer/k8s_service.go:		spec = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_service.go:	specMap, ok := spec.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_service.go:func (c *ServiceCustomizer) updateServicePorts(service map[string]interface{}, servicePorts []ServicePort) error {
pkg/mcp/internal/customizer/k8s_service.go:	ports := make([]interface{}, len(servicePorts))
pkg/mcp/internal/customizer/k8s_service.go:		port := map[string]interface{}{
pkg/mcp/internal/server/unified_server_test.go:			_, err := server.ExecuteTool(context.Background(), tt.toolName, map[string]interface{}{})
pkg/mcp/internal/server/unified_server_test.go:	properties := schema["properties"].(map[string]interface{})
pkg/mcp/internal/server/unified_server_test.go:		InputSchema: map[string]interface{}{
pkg/mcp/internal/server/unified_server_test.go:			"properties": map[string]interface{}{
pkg/mcp/internal/server/unified_server_test.go:				"param1": map[string]interface{}{
pkg/mcp/internal/server/unified_server_test.go:	input := map[string]interface{}{
pkg/mcp/internal/server/unified_server_test.go:			Input:       map[string]interface{}{"param": "value"},
pkg/mcp/internal/server/unified_server_test.go:			Output:      map[string]interface{}{"result": "success"},
pkg/mcp/internal/server/unified_server_test.go:		input    interface{}
pkg/mcp/internal/server/unified_server_test.go:		expected map[string]interface{}
pkg/mcp/internal/server/unified_server_test.go:			input:    map[string]interface{}{"key": "value"},
pkg/mcp/internal/server/unified_server_test.go:			expected: map[string]interface{}{"key": "value"},
pkg/mcp/internal/server/unified_server_test.go:			expected: map[string]interface{}{},
pkg/mcp/internal/server/unified_server_test.go:			expected: map[string]interface{}{},
pkg/mcp/internal/customizer/types.go:	CustomValues   map[string]interface{}
pkg/mcp/internal/errors/types.go:	Input         map[string]interface{} `json:"input,omitempty"`          // Input that caused the error
pkg/mcp/internal/errors/types.go:	PartialOutput map[string]interface{} `json:"partial_output,omitempty"` // Any partial results
pkg/mcp/internal/errors/types.go:	Metrics     map[string]interface{} `json:"metrics,omitempty"`
pkg/mcp/internal/customizer/k8s_helpers.go:func updateNestedValue(obj interface{}, value interface{}, path ...interface{}) error {
pkg/mcp/internal/customizer/k8s_helpers.go:		case map[string]interface{}:
pkg/mcp/internal/customizer/k8s_helpers.go:				curr[keyStr] = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:		case []interface{}:
pkg/mcp/internal/customizer/k8s_helpers.go:	case map[string]interface{}:
pkg/mcp/internal/customizer/k8s_helpers.go:	case []interface{}:
pkg/mcp/internal/customizer/k8s_helpers.go:func updateLabelsInManifest(manifest map[string]interface{}, labels map[string]string) error {
pkg/mcp/internal/customizer/k8s_helpers.go:		metadata = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:	metadataMap, ok := metadata.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:		existingLabels = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:	labelsMap, ok := existingLabels.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:		labelsMap = make(map[string]interface{})
pkg/mcp/internal/session/manage_session_labels.go:func getSessionLabels(sessionInterface interface{}) ([]string, error) {
pkg/mcp/internal/session/manage_session_labels.go:func (t *AddSessionLabelTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/manage_session_labels.go:func (t *RemoveSessionLabelTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/manage_session_labels.go:func (t *UpdateSessionLabelsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/manage_session_labels.go:func (t *ListSessionLabelsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/manage_session_labels.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:func (t *AddSessionLabelTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/session/manage_session_labels.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:func (t *RemoveSessionLabelTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/session/manage_session_labels.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:func (t *UpdateSessionLabelsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/session/manage_session_labels.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:					"summary": map[string]interface{}{
pkg/mcp/internal/session/manage_session_labels.go:func (t *ListSessionLabelsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/errors/validation.go:	Value      interface{} // Actual value that failed
pkg/mcp/internal/errors/validation.go:	Expected   interface{} // Expected value/format
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddInvalidFormat(field string, value interface{}, expectedFormat string) {
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddOutOfRange(field string, value, min, max interface{}) {
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddInvalidType(field string, value interface{}, expectedType string) {
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddDuplicate(field string, value interface{}) {
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddInvalidReference(field string, value interface{}, target string) {
pkg/mcp/internal/errors/validation.go:func (v *ValidationErrors) AddConstraintViolation(field string, value interface{}, constraint string) {
pkg/mcp/internal/errors/validation.go:func ValidateRequired(field string, value interface{}, errors *ValidationErrors) bool {
pkg/mcp/internal/session/list_sessions.go:	State          interface{}
pkg/mcp/internal/session/list_sessions.go:func (t *ListSessionsTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/list_sessions.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:					"sessions": []map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:					"sessions": []map[string]interface{}{
pkg/mcp/internal/session/list_sessions.go:func (t *ListSessionsTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/session/delete_session.go:func (t *DeleteSessionTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/session/delete_session.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/delete_session.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/delete_session.go:				Input: map[string]interface{}{
pkg/mcp/internal/session/delete_session.go:				Output: map[string]interface{}{
pkg/mcp/internal/session/delete_session.go:func (t *DeleteSessionTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/build/analyzer_integration.go:	ErrorDetails    map[string]interface{}
pkg/mcp/internal/build/analyzer_integration.go:	AttemptHistory  []interface{}
pkg/mcp/internal/build/analyzer_integration.go:	EnvironmentInfo map[string]interface{}
pkg/mcp/internal/build/analyzer_integration.go:	SessionMetadata map[string]interface{}
pkg/mcp/internal/build/analyzer_integration.go:	contextSharer := &realContextSharer{context: make(map[string]interface{})}
pkg/mcp/internal/build/analyzer_integration.go:		ErrorDetails:    make(map[string]interface{}),
pkg/mcp/internal/build/analyzer_integration.go:		AttemptHistory:  []interface{}{},
pkg/mcp/internal/build/analyzer_integration.go:		EnvironmentInfo: make(map[string]interface{}),
pkg/mcp/internal/build/analyzer_integration.go:		SessionMetadata: make(map[string]interface{}),
pkg/mcp/internal/build/analyzer_integration.go:		shareErr := a.contextShare.ShareContext(ctx, sessionID, "failure_context", map[string]interface{}{
pkg/mcp/internal/build/analyzer_integration.go:			if failureMap, ok := failureCtx.(map[string]interface{}); ok {
pkg/mcp/internal/build/analyzer_integration.go:			if successMap, ok := successCtx.(map[string]interface{}); ok {
pkg/mcp/internal/build/analyzer_integration.go:	history     []interface{}
pkg/mcp/internal/build/analyzer_integration.go:func (m *mockIterativeFixer) Fix(ctx context.Context, issue interface{}) (*mcptypes.FixingResult, error) {
pkg/mcp/internal/build/analyzer_integration.go:	attempt := map[string]interface{}{
pkg/mcp/internal/build/analyzer_integration.go:		"FixStrategy": map[string]interface{}{
pkg/mcp/internal/build/analyzer_integration.go:		AllAttempts:    []interface{}{attempt},
pkg/mcp/internal/build/analyzer_integration.go:func (m *mockIterativeFixer) GetFixHistory() []interface{} {
pkg/mcp/internal/build/analyzer_integration.go:func (m *mockIterativeFixer) AttemptFix(ctx context.Context, issue interface{}, attempt int) (*mcptypes.FixingResult, error) {
pkg/mcp/internal/build/analyzer_integration.go:	context map[string]interface{}
pkg/mcp/internal/build/analyzer_integration.go:func (r *realContextSharer) ShareContext(ctx context.Context, sessionID string, contextType string, data interface{}) error {
pkg/mcp/internal/build/analyzer_integration.go:		r.context = make(map[string]interface{})
pkg/mcp/internal/build/analyzer_integration.go:func (r *realContextSharer) GetSharedContext(ctx context.Context, sessionID string, contextType string) (interface{}, error) {
pkg/mcp/internal/build/push_image_atomic.go:func (t *AtomicPushImageTool) performPush(ctx context.Context, session *core.SessionState, args AtomicPushImageArgs, result *AtomicPushImageResult, progressCallback interface{}) error {
pkg/mcp/internal/build/push_image_atomic.go:	pushArgs := map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:func (dfp *DockerFixProvider) GetFixStrategies(_ context.Context, err error, context map[string]interface{}) ([]FixStrategy, error) {
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:func (dfp *DockerFixProvider) ApplyFix(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (dfp *DockerFixProvider) fixDockerfileSyntax(_ context.Context, strategy FixStrategy, _ map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (dfp *DockerFixProvider) fixBaseImage(_ context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (dfp *DockerFixProvider) fixPortConflict(_ context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (cfp *ConfigFixProvider) GetFixStrategies(_ context.Context, err error, context map[string]interface{}) ([]FixStrategy, error) {
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:func (cfp *ConfigFixProvider) ApplyFix(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (cfp *ConfigFixProvider) createDefaultConfig(_ context.Context, strategy FixStrategy, _ map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (cfp *ConfigFixProvider) fixConfigFormat(_ context.Context, strategy FixStrategy, _ map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (dep *DependencyFixProvider) GetFixStrategies(_ context.Context, err error, _ map[string]interface{}) ([]FixStrategy, error) {
pkg/mcp/internal/retry/fix_providers.go:			Parameters: map[string]interface{}{
pkg/mcp/internal/retry/fix_providers.go:func (dep *DependencyFixProvider) ApplyFix(ctx context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/retry/fix_providers.go:func (dep *DependencyFixProvider) installMissingCommand(_ context.Context, strategy FixStrategy, context map[string]interface{}) error {
pkg/mcp/internal/customizer/k8s_ingress.go:	var ingress map[string]interface{}
pkg/mcp/internal/customizer/k8s_ingress.go:func (c *IngressCustomizer) updateIngressRules(ingress map[string]interface{}, hosts []IngressHost) error {
pkg/mcp/internal/customizer/k8s_ingress.go:	rules := make([]interface{}, len(hosts))
pkg/mcp/internal/customizer/k8s_ingress.go:		rule := map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:		paths := make([]interface{}, len(host.Paths))
pkg/mcp/internal/customizer/k8s_ingress.go:			pathConfig := map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:				"backend": map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:					"service": map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:						"port": map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:		rule["http"] = map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:func (c *IngressCustomizer) updateIngressTLS(ingress map[string]interface{}, tlsConfigs []IngressTLS) error {
pkg/mcp/internal/customizer/k8s_ingress.go:	tls := make([]interface{}, len(tlsConfigs))
pkg/mcp/internal/customizer/k8s_ingress.go:		tlsEntry := map[string]interface{}{
pkg/mcp/internal/customizer/k8s_ingress.go:func (c *IngressCustomizer) updateAnnotations(manifest map[string]interface{}, annotations map[string]string) error {
pkg/mcp/internal/customizer/k8s_ingress.go:		metadata = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_ingress.go:	metadataMap, ok := metadata.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_ingress.go:		existingAnnotations = make(map[string]interface{})
pkg/mcp/internal/customizer/k8s_ingress.go:	annotationsMap, ok := existingAnnotations.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_ingress.go:		annotationsMap = make(map[string]interface{})
pkg/mcp/internal/build/recovery_strategies.go:		Interface("network_config", map[string]interface{}{
pkg/mcp/internal/build/integration_test.go:func (m *MockAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/build/integration_test.go:	testData := map[string]interface{}{
pkg/mcp/internal/build/integration_test.go:	retrievedMap := retrieved.(map[string]interface{})
pkg/mcp/internal/build/integration_test.go:	prepareRetryFunc    func(ctx context.Context, fixAttempt interface{}) error
pkg/mcp/internal/build/integration_test.go:func (m *MockOperation) PrepareForRetry(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/build/integration_test.go:		metadata := map[string]interface{}{
pkg/mcp/internal/build/integration_test.go:		workflowContext := map[string]interface{}{
pkg/mcp/internal/build/integration_test.go:		errorContext := map[string]interface{}{
pkg/mcp/internal/build/integration_test.go:		metrics := map[string]interface{}{
pkg/mcp/internal/session/state.go:	RepoAnalysis map[string]interface{}       `json:"repo_analysis"`
pkg/mcp/internal/session/state.go:	Metadata map[string]interface{} `json:"metadata"`
pkg/mcp/internal/session/state.go:	Result    interface{}      `json:"result,omitempty"`
pkg/mcp/internal/session/state.go:		RepoAnalysis: make(map[string]interface{}),
pkg/mcp/internal/session/state.go:		Metadata:     make(map[string]interface{}),
pkg/mcp/internal/build/multistage_strategy.go:func (s *MultiStageBuildStrategy) ScoreCompatibility(info interface{}) int {
pkg/mcp/internal/build/performance_monitor.go:		Metrics: map[string]interface{}{
pkg/mcp/internal/build/performance_monitor.go:	Metrics     map[string]interface{} `json:"metrics"`
pkg/mcp/internal/build/context_validator.go:func (v *ContextValidator) Analyze(lines []string, context ValidationContext) interface{} {
pkg/mcp/internal/build/build_validator_test.go:				Context:         make(map[string]interface{}),
pkg/mcp/internal/build/pull_image_atomic.go:		return result, utils.NewWithData("prerequisites_validation_failed", "Pull prerequisites validation failed", map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:func (t *AtomicPullImageTool) performPull(ctx context.Context, session *core.SessionState, args AtomicPullImageArgs, result *AtomicPullImageResult, reporter interface{}) error {
pkg/mcp/internal/build/pull_image_atomic.go:		return utils.NewWithData("image_pull_failed", "Failed to pull image", map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:		session.Metadata = make(map[string]interface{})
pkg/mcp/internal/build/pull_image_atomic.go:func (r *AtomicPullImageResult) CreateRemediationPlan() interface{} {
pkg/mcp/internal/build/pull_image_atomic.go:				Input: map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:				Output: map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:func (t *AtomicPullImageTool) Validate(ctx context.Context, args interface{}) error {
pkg/mcp/internal/build/pull_image_atomic.go:		return utils.NewWithData("invalid_arguments", "Invalid argument type for atomic_pull_image", map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:		return utils.NewWithData("missing_required_field", "ImageRef is required", map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:		return utils.NewWithData("missing_required_field", "SessionID is required", map[string]interface{}{
pkg/mcp/internal/build/pull_image_atomic.go:func (t *AtomicPullImageTool) Execute(ctx context.Context, args interface{}) (interface{}, error) {
pkg/mcp/internal/build/pull_image_atomic.go:		return nil, utils.NewWithData("invalid_arguments", "Invalid argument type for atomic_pull_image", map[string]interface{}{
pkg/mcp/internal/build/enhanced_build_analyzer.go:func (e *EnhancedBuildAnalyzer) AnalyzeWithFormat(ctx context.Context, promptTemplate string, args ...interface{}) (string, error) {
pkg/mcp/internal/build/enhanced_build_analyzer.go:		AnalysisMetadata: map[string]interface{}{
pkg/mcp/internal/build/enhanced_build_analyzer.go:func (e *EnhancedBuildAnalyzer) identifyRootCause(err error, context map[string]interface{}) string {
pkg/mcp/internal/build/enhanced_build_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/build/enhanced_build_analyzer.go:func (e *EnhancedBuildAnalyzer) assessSeverity(err error, context map[string]interface{}) string {
pkg/mcp/internal/build/enhanced_build_analyzer.go:				Metadata: map[string]interface{}{
pkg/mcp/internal/build/enhanced_build_analyzer.go:		Metadata: map[string]interface{}{
pkg/mcp/internal/build/build_tool_integration.go:	originalTool interface{} // Reference to AtomicBuildImageTool
pkg/mcp/internal/build/build_validator.go:		Context:         make(map[string]interface{}),
pkg/mcp/internal/build/context_validator_unified.go:				Context: map[string]interface{}{
pkg/mcp/internal/build/build_strategizer.go:		ResourceRequirements: map[string]interface{}{
pkg/mcp/internal/build/build_strategizer.go:	Environment map[string]interface{} `json:"environment"`
pkg/mcp/internal/build/build_strategizer.go:	Metadata    map[string]interface{} `json:"metadata"`
pkg/mcp/internal/build/build_strategizer.go:	ResourceRequirements  map[string]interface{}    `json:"resource_requirements"`
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) UpdateSession(sessionID string, updater func(interface{})) error {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) GetSessionInterface(sessionID string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) GetSession(sessionID string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) GetOrCreateSession(sessionID string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) CreateSession(userID string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:			session.Metadata = make(map[string]interface{})
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) FindSessionByRepo(ctx context.Context, repoURL string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) ListSessions(ctx context.Context, filter map[string]interface{}) ([]interface{}, error) {
pkg/mcp/internal/session/session_manager.go:	// Convert sessions to interface{} slice for compatibility
pkg/mcp/internal/session/session_manager.go:	var results []interface{}
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) GetOrCreateSessionFromRepo(repoURL string) (interface{}, error) {
pkg/mcp/internal/session/session_manager.go:	err = sm.UpdateSession(session.SessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:		// Convert metadata from interface{} to string
pkg/mcp/internal/session/session_manager.go:	// Convert metadata from interface{} to string
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) TrackError(sessionID string, err error, context map[string]interface{}) error {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:	return jobID, sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) UpdateJobStatus(sessionID, jobID string, status JobStatus, result interface{}, err error) error {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) CompleteJob(sessionID, jobID string, result interface{}) error {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:				sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:func (sm *SessionManager) TrackToolExecution(sessionID, toolName string, args interface{}) error {
pkg/mcp/internal/session/session_manager.go:	return sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/session/session_manager.go:	updateErr := sm.UpdateSession(sessionID, func(s interface{}) {
pkg/mcp/internal/build/fixer_types.go:func createBuildErrorContextForAnalysis(err error, buildResult *coredocker.BuildResult, dockerfilePath string) map[string]interface{} {
pkg/mcp/internal/build/fixer_types.go:	context := map[string]interface{}{
pkg/mcp/internal/errors/runtime.go:	Fields    map[string]interface{}
pkg/mcp/internal/errors/runtime.go:func (e *ToolError) WithContext(key string, value interface{}) *ToolError {
pkg/mcp/internal/errors/runtime.go:		e.Context.Fields = make(map[string]interface{})
pkg/mcp/internal/errors/runtime.go:				Fields: make(map[string]interface{}),
pkg/mcp/internal/errors/runtime.go:func (b *ErrorBuilder) WithField(key string, value interface{}) *ErrorBuilder {
pkg/mcp/internal/errors/runtime.go:	logger interface{} // zerolog.Logger
pkg/mcp/internal/errors/runtime.go:func NewErrorHandler(logger interface{}) *ErrorHandler {
pkg/mcp/internal/build/docker_operation.go:func (op *DockerOperation) PrepareForRetry(ctx context.Context, fixAttempt interface{}) error {
pkg/mcp/internal/customizer/k8s_secret.go:	var secret map[string]interface{}
pkg/mcp/internal/build/build_executor.go:func (e *BuildExecutorService) ExecuteWithFixes(ctx context.Context, args AtomicBuildImageArgs, fixingMixin interface{}) (*AtomicBuildImageResult, error) {
pkg/mcp/internal/build/build_executor.go:	buildArgs := map[string]interface{}{
pkg/mcp/internal/build/build_executor.go:		pushArgs := map[string]interface{}{
pkg/mcp/internal/build/build_executor.go:func (e *BuildExecutorService) executeWithProgress(ctx context.Context, args AtomicBuildImageArgs, result *AtomicBuildImageResult, startTime time.Time, progress interface{}) error {
pkg/mcp/internal/build/common.go:	ScoreCompatibility(projectInfo interface{}) int
pkg/mcp/internal/build/common.go:	GetCurrentStage() (int, interface{})
pkg/mcp/internal/build/fixer_core.go:func (op *AtomicDockerBuildOperation) PrepareForRetry(ctx context.Context, lastAttempt interface{}) error {
pkg/mcp/internal/build/fixer_core.go:func (op *AtomicDockerBuildOperation) GetOperationInfo() map[string]interface{} {
pkg/mcp/internal/build/fixer_core.go:	return map[string]interface{}{
pkg/mcp/internal/build/fixer_core.go:		map[string]interface{}{
pkg/mcp/internal/build/fixer_core.go:	aiContext := map[string]interface{}{
pkg/mcp/internal/build/fixer_core.go:func createBuildErrorContext(toolName, operationType, errorType string, args interface{}, additionalData map[string]interface{}, files []string) map[string]interface{} {
pkg/mcp/internal/build/fixer_core.go:	errorContext := map[string]interface{}{
pkg/mcp/internal/build/docker_strategy.go:func (s *DockerBuildStrategy) ScoreCompatibility(info interface{}) int {
