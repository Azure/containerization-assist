package security_test

import (
	"bytes"
	"encoding/json"
	"strings"
	"testing"

	"github.com/Azure/container-kit/pkg/core/security"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSBOMGenerator_GenerateCycloneDXBOM(t *testing.T) {
	logger := zerolog.Nop()
	generator := security.NewSBOMGenerator(logger)

	packages := []Package{
		{
			Name:     "express",
			Version:  "4.18.2",
			Type:     "npm",
			License:  "MIT",
			PURL:     "pkg:npm/express@4.18.2",
			CPE:      "cpe:2.3:a:expressjs:express:4.18.2:*:*:*:*:*:*:*",
			Supplier: "Express Team",
			Checksums: map[string]string{
				"SHA256": "abc123def456",
			},
			Dependencies: []string{"body-parser@1.20.1", "cookie@0.5.0"},
			Metadata: map[string]string{
				"homepage": "https://expressjs.com",
				"vcs":      "https://github.com/expressjs/express",
			},
		},
		{
			Name:    "flask",
			Version: "2.2.3",
			Type:    "pip",
			License: "BSD-3-Clause",
			PURL:    "pkg:pypi/flask@2.2.3",
		},
	}

	bom := generator.GenerateCycloneDXBOM("test-app", packages)

	// Validate basic structure
	assert.Equal(t, "CycloneDX", bom.BOMFormat)
	assert.Equal(t, "1.4", bom.SpecVersion)
	assert.NotEmpty(t, bom.SerialNumber)
	assert.True(t, strings.HasPrefix(bom.SerialNumber, "urn:uuid:"))
	assert.Equal(t, 1, bom.Version)

	// Check metadata
	assert.NotEmpty(t, bom.Metadata.Timestamp)
	assert.Len(t, bom.Metadata.Tools, 1)
	assert.Equal(t, "container-kit", bom.Metadata.Tools[0].Vendor)
	assert.Equal(t, "security-scanner", bom.Metadata.Tools[0].Name)
	assert.NotNil(t, bom.Metadata.Component)
	assert.Equal(t, "test-app", bom.Metadata.Component.Name)

	// Check components
	assert.Len(t, bom.Components, 2)

	// Check express component
	express := bom.Components[0]
	assert.Equal(t, "library", express.Type)
	assert.Equal(t, "pkg:npm/express@4.18.2", express.BOMRef)
	assert.Equal(t, "express", express.Name)
	assert.Equal(t, "4.18.2", express.Version)
	assert.Equal(t, "required", express.Scope)
	assert.Equal(t, "pkg:npm/express@4.18.2", express.PURL)
	assert.Equal(t, "cpe:2.3:a:expressjs:express:4.18.2:*:*:*:*:*:*:*", express.CPE)

	// Check hashes
	assert.Len(t, express.Hashes, 1)
	assert.Equal(t, "SHA-256", express.Hashes[0].Algorithm)
	assert.Equal(t, "abc123def456", express.Hashes[0].Content)

	// Check license
	assert.Len(t, express.Licenses, 1)
	assert.NotNil(t, express.Licenses[0].License)
	assert.Equal(t, "MIT", express.Licenses[0].License.ID)

	// Check external references
	assert.Len(t, express.ExternalRefs, 2)
	websiteFound := false
	vcsFound := false
	for _, ref := range express.ExternalRefs {
		if ref.Type == "website" {
			websiteFound = true
			assert.Equal(t, "https://expressjs.com", ref.URL)
		}
		if ref.Type == "vcs" {
			vcsFound = true
			assert.Equal(t, "https://github.com/expressjs/express", ref.URL)
		}
	}
	assert.True(t, websiteFound)
	assert.True(t, vcsFound)

	// Check properties
	assert.Len(t, express.Properties, 1)
	assert.Equal(t, "supplier", express.Properties[0].Name)
	assert.Equal(t, "Express Team", express.Properties[0].Value)

	// Check flask component
	flask := bom.Components[1]
	assert.Equal(t, "library", flask.Type)
	assert.Equal(t, "flask", flask.Name)
	assert.Equal(t, "BSD-3-Clause", flask.Licenses[0].License.ID)

	// Check dependencies
	assert.GreaterOrEqual(t, len(bom.Dependencies), 1)

	// Find express dependencies
	for _, dep := range bom.Dependencies {
		if dep.Ref == "pkg:npm/express@4.18.2" {
			assert.Len(t, dep.DependsOn, 2)
			assert.Contains(t, dep.DependsOn, "pkg:npm/body-parser@1.20.1")
			assert.Contains(t, dep.DependsOn, "pkg:npm/cookie@0.5.0")
		}
	}
}

func TestSBOMGenerator_GetComponentType(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	tests := []struct {
		packageType string
		expected    string
	}{
		{"npm", "library"},
		{"pip", "library"},
		{"gem", "library"},
		{"go", "library"},
		{"maven", "library"},
		{"gradle", "library"},
		{"cargo", "library"},
		{"container", "container"},
		{"os", "operating-system"},
		{"unknown", "library"},
	}

	for _, tt := range tests {
		t.Run(tt.packageType, func(t *testing.T) {
			result := generator.getComponentType(tt.packageType)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestSBOMGenerator_NormalizeCycloneDXHashAlgo(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	tests := []struct {
		input    string
		expected string
	}{
		{"SHA256", "SHA-256"},
		{"sha256", "SHA-256"},
		{"SHA512", "SHA-512"},
		{"sha512", "SHA-512"},
		{"SHA1", "SHA-1"},
		{"sha1", "SHA-1"},
		{"MD5", "MD5"},
		{"md5", "MD5"},
		{"BLAKE2b", "BLAKE2b"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := generator.normalizeCycloneDXHashAlgo(tt.input)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestSBOMGenerator_CreateCycloneDXLicense(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	t.Run("SPDX license", func(t *testing.T) {
		license := generator.createCycloneDXLicense("Apache-2.0")
		assert.NotNil(t, license.License)
		assert.Equal(t, "Apache-2.0", license.License.ID)
		assert.Empty(t, license.License.Name)
	})

	t.Run("custom license", func(t *testing.T) {
		license := generator.createCycloneDXLicense("CustomLicense")
		assert.NotNil(t, license.License)
		assert.Empty(t, license.License.ID)
		assert.Equal(t, "CustomLicense", license.License.Name)
	})
}

func TestSBOMGenerator_DependencyToBomRef(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	tests := []struct {
		dep         string
		packageType string
		expected    string
	}{
		{"express@4.18.2", "npm", "pkg:npm/express@4.18.2"},
		{"lodash@^4.17.21", "npm", "pkg:npm/lodash@^4.17.21"},
		{"github.com/rs/zerolog@v1.29.0", "go", "pkg:go/github.com/rs/zerolog@v1.29.0"},
		{"flask==2.2.3", "pip", "pkg:pip/flask@2.2.3"},
		{"requests==2.28.2", "pip", "pkg:pip/requests@2.28.2"},
		{"package-without-version", "npm", "pkg:npm/package-without-version"},
	}

	for _, tt := range tests {
		t.Run(tt.dep, func(t *testing.T) {
			result := generator.dependencyToBomRef(tt.dep, tt.packageType)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestSBOMGenerator_ValidateCycloneDXBOM(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	t.Run("valid BOM", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat:    "CycloneDX",
			SpecVersion:  "1.4",
			SerialNumber: "urn:uuid:12345",
			Version:      1,
			Components: []CycloneDXComponent{
				{
					Type:   "library",
					BOMRef: "pkg:npm/test@1.0.0",
					Name:   "test",
				},
			},
		}

		err := generator.ValidateCycloneDXBOM(bom)
		assert.NoError(t, err)
	})

	t.Run("invalid BOM format", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat: "InvalidFormat",
		}
		err := generator.ValidateCycloneDXBOM(bom)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid BOM format")
	})

	t.Run("missing spec version", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat: "CycloneDX",
		}
		err := generator.ValidateCycloneDXBOM(bom)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "spec version is required")
	})

	t.Run("invalid version", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat:    "CycloneDX",
			SpecVersion:  "1.4",
			SerialNumber: "urn:uuid:12345",
			Version:      0,
		}
		err := generator.ValidateCycloneDXBOM(bom)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "version must be >= 1")
	})

	t.Run("duplicate BOM refs", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat:    "CycloneDX",
			SpecVersion:  "1.4",
			SerialNumber: "urn:uuid:12345",
			Version:      1,
			Components: []CycloneDXComponent{
				{
					Type:   "library",
					BOMRef: "pkg:npm/test@1.0.0",
					Name:   "test",
				},
				{
					Type:   "library",
					BOMRef: "pkg:npm/test@1.0.0", // Duplicate
					Name:   "test2",
				},
			},
		}
		err := generator.ValidateCycloneDXBOM(bom)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "duplicate bom-ref")
	})

	t.Run("invalid dependency ref", func(t *testing.T) {
		bom := &CycloneDXBOM{
			BOMFormat:    "CycloneDX",
			SpecVersion:  "1.4",
			SerialNumber: "urn:uuid:12345",
			Version:      1,
			Components: []CycloneDXComponent{
				{
					Type:   "library",
					BOMRef: "pkg:npm/test@1.0.0",
					Name:   "test",
				},
			},
			Dependencies: []CycloneDXDependency{
				{
					Ref:       "pkg:npm/test@1.0.0",
					DependsOn: []string{"pkg:npm/nonexistent@1.0.0"},
				},
			},
		}
		err := generator.ValidateCycloneDXBOM(bom)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "unknown ref")
	})
}

func TestSBOMGenerator_WriteCycloneDX(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	bom := &CycloneDXBOM{
		BOMFormat:    "CycloneDX",
		SpecVersion:  "1.4",
		SerialNumber: "urn:uuid:test-123",
		Version:      1,
		Metadata: CycloneDXMetadata{
			Timestamp: "2023-01-01T00:00:00Z",
			Tools: []CycloneDXTool{
				{
					Vendor: "test",
					Name:   "test-tool",
				},
			},
		},
		Components: []CycloneDXComponent{
			{
				Type:    "library",
				BOMRef:  "pkg:npm/test@1.0.0",
				Name:    "test",
				Version: "1.0.0",
			},
		},
	}

	var buf bytes.Buffer
	err := generator.WriteCycloneDX(bom, &buf)
	require.NoError(t, err)

	// Verify JSON output
	var decoded CycloneDXBOM
	err = json.Unmarshal(buf.Bytes(), &decoded)
	require.NoError(t, err)

	assert.Equal(t, bom.BOMFormat, decoded.BOMFormat)
	assert.Equal(t, bom.SpecVersion, decoded.SpecVersion)
	assert.Equal(t, bom.SerialNumber, decoded.SerialNumber)
	assert.Len(t, decoded.Components, 1)
	assert.Equal(t, bom.Components[0].Name, decoded.Components[0].Name)
}

func TestSBOMGenerator_ConvertSPDXToCycloneDX(t *testing.T) {
	logger := zerolog.Nop()
	generator := NewSBOMGenerator(logger)

	spdx := &SPDXDocument{
		SPDXVersion:       "SPDX-2.3",
		DataLicense:       "CC0-1.0",
		SPDXID:            "SPDXRef-DOCUMENT",
		Name:              "Test SBOM",
		DocumentNamespace: "https://example.com/sbom/test",
		CreationInfo: SPDXCreationInfo{
			Created:  "2023-01-01T00:00:00Z",
			Creators: []string{"Tool: test"},
		},
		Packages: []SPDXPackage{
			{
				SPDXID:           "SPDXRef-Package-0",
				Name:             "test-package",
				Version:          "1.0.0",
				DownloadLocation: "NOASSERTION",
				LicenseDeclared:  "MIT",
				CopyrightText:    "NOASSERTION",
				Checksums: []SPDXChecksum{
					{
						Algorithm: "SHA256",
						Value:     "abc123",
					},
				},
				ExternalRefs: []SPDXExternalRef{
					{
						Category: "PACKAGE-MANAGER",
						Type:     "purl",
						Locator:  "pkg:npm/test-package@1.0.0",
					},
					{
						Category: "SECURITY",
						Type:     "cpe23Type",
						Locator:  "cpe:2.3:a:test:test-package:1.0.0:*:*:*:*:*:*:*",
					},
				},
			},
			{
				SPDXID:           "SPDXRef-Package-1",
				Name:             "dependency",
				Version:          "2.0.0",
				DownloadLocation: "NOASSERTION",
				LicenseDeclared:  "Apache-2.0",
				CopyrightText:    "NOASSERTION",
			},
		},
		Relationships: []SPDXRelationship{
			{
				SPDXElementID:      "SPDXRef-DOCUMENT",
				RelationshipType:   "DESCRIBES",
				RelatedSPDXElement: "SPDXRef-Package-0",
			},
			{
				SPDXElementID:      "SPDXRef-Package-0",
				RelationshipType:   "DEPENDS_ON",
				RelatedSPDXElement: "SPDXRef-Package-1",
			},
		},
	}

	cyclonedx, err := generator.ConvertSPDXToCycloneDX(spdx)
	require.NoError(t, err)

	// Validate conversion
	assert.Equal(t, "CycloneDX", cyclonedx.BOMFormat)
	assert.Equal(t, "1.4", cyclonedx.SpecVersion)
	assert.NotEmpty(t, cyclonedx.SerialNumber)
	assert.Equal(t, 1, cyclonedx.Version)

	// Check components
	assert.Len(t, cyclonedx.Components, 2)

	// Check first component
	comp1 := cyclonedx.Components[0]
	assert.Equal(t, "library", comp1.Type)
	assert.Equal(t, "pkg:npm/test-package@1.0.0", comp1.BOMRef)
	assert.Equal(t, "test-package", comp1.Name)
	assert.Equal(t, "1.0.0", comp1.Version)
	assert.Equal(t, "pkg:npm/test-package@1.0.0", comp1.PURL)
	assert.Contains(t, comp1.CPE, "test-package")
	assert.Len(t, comp1.Hashes, 1)
	assert.Equal(t, "SHA-256", comp1.Hashes[0].Algorithm)
	assert.Equal(t, "abc123", comp1.Hashes[0].Content)
	assert.Len(t, comp1.Licenses, 1)
	assert.Equal(t, "MIT", comp1.Licenses[0].License.ID)

	// Check second component
	comp2 := cyclonedx.Components[1]
	assert.Equal(t, "dependency", comp2.Name)
	assert.Equal(t, "2.0.0", comp2.Version)
	assert.Equal(t, "Apache-2.0", comp2.Licenses[0].License.ID)

	// Check dependencies were converted
	assert.GreaterOrEqual(t, len(cyclonedx.Dependencies), 1)

	// Validate the converted BOM
	err = generator.ValidateCycloneDXBOM(cyclonedx)
	assert.NoError(t, err)
}
