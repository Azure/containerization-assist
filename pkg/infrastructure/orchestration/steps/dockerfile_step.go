// Package steps contains individual workflow step implementations.
package steps

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/Azure/containerization-assist/pkg/domain/workflow"
)

func init() {
	Register(NewDockerfileStep())
}

// DockerfileStep implements Dockerfile generation
type DockerfileStep struct{}

// NewDockerfileStep creates a new dockerfile step
func NewDockerfileStep() workflow.Step {
	return &DockerfileStep{}
}

// Name returns the step name
func (s *DockerfileStep) Name() string {
	return "verify_dockerfile"
}

// Execute verifies a Dockerfile was generated by the agent based on repository analysis
func (s *DockerfileStep) Execute(ctx context.Context, state *workflow.WorkflowState) (*workflow.StepResult, error) {
	// Verify that the Dockerfile was generated by the agent
	dockerfilePath := filepath.Join(state.AnalyzeResult.RepoPath, "Dockerfile")
	if _, err := os.Stat(dockerfilePath); os.IsNotExist(err) {
		return nil, fmt.Errorf("AI agent has not yet generated a Dockerfile at expected path: %s. Please ensure the AI agent creates a Dockerfile based on the repository analysis before running verify_dockerfile", dockerfilePath)
	}

	// Read the generated Dockerfile to extract metadata
	generatedContent, err := os.ReadFile(dockerfilePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read AI-generated Dockerfile at '%s': %v", dockerfilePath, err)
	}

	dockerfileResult := &DockerfileResult{
		Content:     string(generatedContent),
		Path:        "Dockerfile",
		BaseImage:   extractBaseImageFromDockerfile(string(generatedContent)),
		ExposedPort: extractPortFromDockerfile(string(generatedContent)),
	}

	state.Logger.Info("Verified AI-generated Dockerfile", "path", dockerfileResult.Path)

	// Convert to workflow type
	state.DockerfileResult = &workflow.DockerfileResult{
		Content:     dockerfileResult.Content,
		Path:        dockerfileResult.Path,
		BaseImage:   dockerfileResult.BaseImage,
		Metadata:    map[string]interface{}{"ai_generated": true},
		ExposedPort: dockerfileResult.ExposedPort,
	}

	// Return StepResult
	return &workflow.StepResult{
		Success: true,
		Data: map[string]interface{}{
			"path":         dockerfileResult.Path,
			"base_image":   dockerfileResult.BaseImage,
			"exposed_port": dockerfileResult.ExposedPort,
			"verified":     true,
		},
		Metadata: map[string]interface{}{
			"ai_generated": true,
		},
	}, nil
}

// extractBaseImageFromDockerfile extracts the base image from Dockerfile content
func extractBaseImageFromDockerfile(content string) string {
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if !strings.HasPrefix(strings.ToUpper(line), "FROM ") {
			continue
		}
		parts := strings.Fields(line)
		if len(parts) < 2 {
			continue
		}
		baseImage := parts[1]
		// Remove AS alias if present
		if len(parts) >= 4 && strings.ToUpper(parts[2]) == "AS" {
			return baseImage
		}
		return baseImage
	}
	return "unknown"
}

// extractPortFromDockerfile extracts the exposed port from Dockerfile content
func extractPortFromDockerfile(content string) int {
	lines := strings.Split(content, "\n")
	re := regexp.MustCompile(`EXPOSE\s+(\d+)`)

	for _, line := range lines {
		line = strings.TrimSpace(strings.ToUpper(line))
		matches := re.FindStringSubmatch(line)
		if len(matches) < 1 {
			continue
		}
		if port, err := strconv.Atoi(matches[1]); err == nil {
			return port
		}
	}
	return 0
}
