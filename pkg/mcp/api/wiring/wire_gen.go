// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wiring

import (
	"github.com/Azure/container-kit/pkg/mcp/api"
	"github.com/Azure/container-kit/pkg/mcp/application"
	"github.com/Azure/container-kit/pkg/mcp/domain/saga"
	"github.com/Azure/container-kit/pkg/mcp/domain/workflow"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/ai_ml/ml"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/messaging/events"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/messaging/progress"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/observability/tracing"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/orchestration/container"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/orchestration/kubernetes"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/orchestration/steps"
	"log/slog"
)

// Injectors from wire.go:

// InitializeDefaultServer creates a fully wired MCP server with default configuration
func InitializeDefaultServer(logger *slog.Logger) (api.MCPServer, error) {
	config, err := ProvideConfig()
	if err != nil {
		return nil, err
	}
	serverConfig := ProvideServerConfigFromUnified(config)
	optimizedSessionManager, err := ProvideSessionManager(serverConfig, logger)
	if err != nil {
		return nil, err
	}
	store := ProvideResourceStore(logger)
	sinkFactory := progress.NewSinkFactory(logger)
	progressEmitterFactory := ProvideProgressEmitterFactory(sinkFactory)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.NewRegistryStepProvider()
	client, err := ProvideSamplingClient(config, logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ProvideMLOptimizedBuildStep(domainAdapter, logger)
	step := ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := ProvideStepFactory(stepProvider, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := ProvideBaseOrchestrator(stepFactory, progressEmitterFactory, logger, tracer)
	workflowOrchestrator := ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := ProvideEventOrchestrator(baseOrchestrator, publisher)
	commandRunner := ProvideCommandRunner()
	containerManager := container.NewDockerContainerManager(commandRunner, logger)
	deploymentManager := kubernetes.NewKubernetesDeploymentManager(commandRunner, logger)
	sagaAwareOrchestrator := ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.NewErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.NewEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.NewStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(config, logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 serverConfig,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressEmitterFactory: progressEmitterFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	mcpServer := ProvideServer(dependencies)
	return mcpServer, nil
}

// InitializeServerWithConfig creates a fully wired MCP server with custom configuration
func InitializeServerWithConfig(logger *slog.Logger, config workflow.ServerConfig) (api.MCPServer, error) {
	optimizedSessionManager, err := ProvideSessionManager(config, logger)
	if err != nil {
		return nil, err
	}
	store := ProvideResourceStore(logger)
	sinkFactory := progress.NewSinkFactory(logger)
	progressEmitterFactory := ProvideProgressEmitterFactory(sinkFactory)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.NewRegistryStepProvider()
	configConfig := ProvideConfigFromServerConfig(config)
	client, err := ProvideSamplingClient(configConfig, logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ProvideMLOptimizedBuildStep(domainAdapter, logger)
	step := ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := ProvideStepFactory(stepProvider, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := ProvideBaseOrchestrator(stepFactory, progressEmitterFactory, logger, tracer)
	workflowOrchestrator := ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := ProvideEventOrchestrator(baseOrchestrator, publisher)
	commandRunner := ProvideCommandRunner()
	containerManager := container.NewDockerContainerManager(commandRunner, logger)
	deploymentManager := kubernetes.NewKubernetesDeploymentManager(commandRunner, logger)
	sagaAwareOrchestrator := ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.NewErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.NewEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.NewStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(configConfig, logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 config,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressEmitterFactory: progressEmitterFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	mcpServer := ProvideServer(dependencies)
	return mcpServer, nil
}

// InitializeBasicServer creates a server without ML capabilities for testing
func InitializeBasicServer(logger *slog.Logger) (api.MCPServer, error) {
	config, err := ProvideConfig()
	if err != nil {
		return nil, err
	}
	serverConfig := ProvideServerConfigFromUnified(config)
	optimizedSessionManager, err := ProvideSessionManager(serverConfig, logger)
	if err != nil {
		return nil, err
	}
	store := ProvideResourceStore(logger)
	sinkFactory := progress.NewSinkFactory(logger)
	progressEmitterFactory := ProvideProgressEmitterFactory(sinkFactory)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.NewRegistryStepProvider()
	client, err := ProvideSamplingClient(config, logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ProvideMLOptimizedBuildStep(domainAdapter, logger)
	step := ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := ProvideStepFactory(stepProvider, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := ProvideBaseOrchestrator(stepFactory, progressEmitterFactory, logger, tracer)
	workflowOrchestrator := ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := ProvideEventOrchestrator(baseOrchestrator, publisher)
	commandRunner := ProvideCommandRunner()
	containerManager := container.NewDockerContainerManager(commandRunner, logger)
	deploymentManager := kubernetes.NewKubernetesDeploymentManager(commandRunner, logger)
	sagaAwareOrchestrator := ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.NewErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.NewEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.NewStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(config, logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 serverConfig,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressEmitterFactory: progressEmitterFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	mcpServer := ProvideServer(dependencies)
	return mcpServer, nil
}

// InitializeWorkflowOrchestrator creates just the workflow orchestrator for testing
func InitializeWorkflowOrchestrator(logger *slog.Logger) (workflow.WorkflowOrchestrator, error) {
	stepProvider := steps.NewRegistryStepProvider()
	config, err := ProvideConfig()
	if err != nil {
		return nil, err
	}
	client, err := ProvideSamplingClient(config, logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ProvideMLOptimizedBuildStep(domainAdapter, logger)
	step := ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := ProvideStepFactory(stepProvider, step, logger)
	sinkFactory := progress.NewSinkFactory(logger)
	progressEmitterFactory := ProvideProgressEmitterFactory(sinkFactory)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := ProvideBaseOrchestrator(stepFactory, progressEmitterFactory, logger, tracer)
	workflowOrchestrator := ProvideWorkflowOrchestrator(baseOrchestrator)
	return workflowOrchestrator, nil
}

// InitializeTestDependencies creates application dependencies for testing
func InitializeTestDependencies(logger *slog.Logger, config workflow.ServerConfig) (*application.Dependencies, error) {
	optimizedSessionManager, err := ProvideSessionManager(config, logger)
	if err != nil {
		return nil, err
	}
	store := ProvideResourceStore(logger)
	sinkFactory := progress.NewSinkFactory(logger)
	progressEmitterFactory := ProvideProgressEmitterFactory(sinkFactory)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.NewRegistryStepProvider()
	configConfig := ProvideConfigFromServerConfig(config)
	client, err := ProvideSamplingClient(configConfig, logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ProvideMLOptimizedBuildStep(domainAdapter, logger)
	step := ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := ProvideStepFactory(stepProvider, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := ProvideBaseOrchestrator(stepFactory, progressEmitterFactory, logger, tracer)
	workflowOrchestrator := ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := ProvideEventOrchestrator(baseOrchestrator, publisher)
	commandRunner := ProvideCommandRunner()
	containerManager := container.NewDockerContainerManager(commandRunner, logger)
	deploymentManager := kubernetes.NewKubernetesDeploymentManager(commandRunner, logger)
	sagaAwareOrchestrator := ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.NewErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.NewEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.NewStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(configConfig, logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 config,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressEmitterFactory: progressEmitterFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	return dependencies, nil
}
