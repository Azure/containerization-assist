package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
)

type ErrorCode struct {
	Code        string
	Description string
	Severity    string
	Retryable   bool
}

var codeTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file was generated from codes.yaml

package errors

// Error codes - generated from codes.yaml
const (
{{- range .ErrorCodes }}
	Code{{ .CodeName }} Code = "{{ .Code }}" // {{ .Description }}
{{- end }}
)

// Error code metadata
var codeMetadata = map[Code]struct {
	Description string
	Severity    Severity
	Retryable   bool
}{
{{- range .ErrorCodes }}
	Code{{ .CodeName }}: {
		Description: "{{ .Description }}",
		Severity:    Severity{{ .SeverityName }},
		Retryable:   {{ .Retryable }},
	},
{{- end }}
}

// GetCodeMetadata returns metadata for an error code
func GetCodeMetadata(code Code) (description string, severity Severity, retryable bool, exists bool) {
	if meta, ok := codeMetadata[code]; ok {
		return meta.Description, meta.Severity, meta.Retryable, true
	}
	return "", SeverityUnknown, false, false
}

// IsRetryableCode returns true if the given error code is retryable
func IsRetryableCode(code Code) bool {
	if meta, ok := codeMetadata[code]; ok {
		return meta.Retryable
	}
	return false
}
`

type TemplateData struct {
	ErrorCodes []TemplateErrorCode
}

type TemplateErrorCode struct {
	Code         string
	CodeName     string
	Description  string
	Severity     string
	SeverityName string
	Retryable    bool
}

func main() {
	// Find the codes.yaml file
	yamlPath := "codes.yaml"
	if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
		// Try relative to this file
		yamlPath = "../../codes.yaml"
		if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
			log.Fatal("Could not find codes.yaml file")
		}
	}

	// Parse YAML manually (simple parser for our specific format)
	codes, err := parseCodesYAML(yamlPath)
	if err != nil {
		log.Fatalf("Failed to parse codes.yaml: %v", err)
	}

	// Prepare template data
	templateData := TemplateData{}
	for _, code := range codes {
		templateData.ErrorCodes = append(templateData.ErrorCodes, TemplateErrorCode{
			Code:         code.Code,
			CodeName:     toCamelCase(code.Code),
			Description:  code.Description,
			Severity:     code.Severity,
			SeverityName: toCamelCase(code.Severity),
			Retryable:    code.Retryable,
		})
	}

	// Parse template
	tmpl, err := template.New("codes").Parse(codeTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	// Generate output in the errors package directory
	outputPath := "../../codes_gen.go"

	file, err := os.Create(outputPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer file.Close()

	// Execute template
	if err := tmpl.Execute(file, templateData); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	fmt.Printf("Generated %s with %d error codes\n", outputPath, len(codes))
}

// Simple YAML parser for our specific format
func parseCodesYAML(filename string) ([]ErrorCode, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var codes []ErrorCode
	var currentCode *ErrorCode
	
	scanner := bufio.NewScanner(file)
	codeRegex := regexp.MustCompile(`^\s*-\s+code:\s*(.+)$`)
	descRegex := regexp.MustCompile(`^\s+description:\s*(.+)$`)
	severityRegex := regexp.MustCompile(`^\s+severity:\s*(.+)$`)
	retryableRegex := regexp.MustCompile(`^\s+retryable:\s*(true|false)$`)

	for scanner.Scan() {
		line := scanner.Text()
		
		if matches := codeRegex.FindStringSubmatch(line); len(matches) > 1 {
			// Save previous code if exists
			if currentCode != nil {
				codes = append(codes, *currentCode)
			}
			// Start new code
			currentCode = &ErrorCode{
				Code: strings.TrimSpace(matches[1]),
			}
		} else if matches := descRegex.FindStringSubmatch(line); len(matches) > 1 && currentCode != nil {
			currentCode.Description = strings.TrimSpace(matches[1])
		} else if matches := severityRegex.FindStringSubmatch(line); len(matches) > 1 && currentCode != nil {
			currentCode.Severity = strings.TrimSpace(matches[1])
		} else if matches := retryableRegex.FindStringSubmatch(line); len(matches) > 1 && currentCode != nil {
			currentCode.Retryable = matches[1] == "true"
		}
	}
	
	// Add the last code
	if currentCode != nil {
		codes = append(codes, *currentCode)
	}

	return codes, scanner.Err()
}

// toCamelCase converts SNAKE_CASE to CamelCase
func toCamelCase(s string) string {
	parts := strings.Split(strings.ToLower(s), "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}