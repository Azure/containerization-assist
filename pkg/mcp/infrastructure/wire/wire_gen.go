// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"github.com/Azure/container-kit/pkg/mcp/api"
	"github.com/Azure/container-kit/pkg/mcp/application"
	"github.com/Azure/container-kit/pkg/mcp/application/session"
	"github.com/Azure/container-kit/pkg/mcp/domain/events"
	"github.com/Azure/container-kit/pkg/mcp/domain/saga"
	"github.com/Azure/container-kit/pkg/mcp/domain/sampling"
	"github.com/Azure/container-kit/pkg/mcp/domain/workflow"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/container"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/kubernetes"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/ml"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/progress"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/prompts"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/resources"
	sampling2 "github.com/Azure/container-kit/pkg/mcp/infrastructure/sampling"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/steps"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/steps/optimized"
	"github.com/Azure/container-kit/pkg/mcp/infrastructure/tracing"
	"github.com/google/wire"
	"log/slog"
	"os"
	"strconv"
	"time"
)

// Injectors from wire.go:

// InitializeServer creates a fully wired MCP server
func InitializeServer(logger *slog.Logger) (api.MCPServer, error) {
	serverConfig := ProvideDefaultServerConfig()
	optimizedSessionManager := ProvideSessionManager(serverConfig, logger)
	store := ProvideResourceStore(logger)
	sinkFactory := ProvideProgressFactory(logger)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.ProvideStepProvider()
	client, err := ProvideSamplingClient(logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ml.ProvideOptimizedBuildStep(domainAdapter, logger)
	buildOptimizer := optimized.ProvideBuildOptimizer(optimizedBuildStep)
	step := optimized.ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := workflow.ProvideStepFactory(stepProvider, buildOptimizer, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := workflow.ProvideBaseOrchestrator(stepFactory, sinkFactory, logger, tracer)
	workflowOrchestrator := workflow.ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := workflow.ProvideEventOrchestrator(baseOrchestrator, publisher)
	containerManager := container.ProvideContainerManager(logger)
	deploymentManager := kubernetes.ProvideDeploymentManager(logger)
	sagaAwareOrchestrator := workflow.ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.ProvideErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.ProvideEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.ProvideStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 serverConfig,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressFactory:        sinkFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	mcpServer := ProvideServer(dependencies)
	return mcpServer, nil
}

// InitializeServerWithConfig creates a fully wired MCP server with custom config
func InitializeServerWithConfig(logger *slog.Logger, config workflow.ServerConfig) (api.MCPServer, error) {
	optimizedSessionManager := ProvideSessionManager(config, logger)
	store := ProvideResourceStore(logger)
	sinkFactory := ProvideProgressFactory(logger)
	publisher := events.NewPublisher(logger)
	sagaCoordinator := saga.NewSagaCoordinator(logger, publisher)
	stepProvider := steps.ProvideStepProvider()
	client, err := ProvideSamplingClient(logger)
	if err != nil {
		return nil, err
	}
	domainAdapter := provideDomainSampler(client)
	optimizedBuildStep := ml.ProvideOptimizedBuildStep(domainAdapter, logger)
	buildOptimizer := optimized.ProvideBuildOptimizer(optimizedBuildStep)
	step := optimized.ProvideOptimizedBuildStep(optimizedBuildStep)
	stepFactory := workflow.ProvideStepFactory(stepProvider, buildOptimizer, step, logger)
	tracer := tracing.NewTracerAdapter()
	baseOrchestrator := workflow.ProvideBaseOrchestrator(stepFactory, sinkFactory, logger, tracer)
	workflowOrchestrator := workflow.ProvideWorkflowOrchestrator(baseOrchestrator)
	eventAwareOrchestrator := workflow.ProvideEventOrchestrator(baseOrchestrator, publisher)
	containerManager := container.ProvideContainerManager(logger)
	deploymentManager := kubernetes.ProvideDeploymentManager(logger)
	sagaAwareOrchestrator := workflow.ProvideSagaOrchestrator(eventAwareOrchestrator, sagaCoordinator, containerManager, deploymentManager, logger)
	errorPatternRecognizer := ml.ProvideErrorPatternRecognizer(domainAdapter, logger)
	enhancedErrorHandler := ml.ProvideEnhancedErrorHandler(domainAdapter, publisher, logger)
	stepEnhancer := ml.ProvideStepEnhancer(enhancedErrorHandler, logger)
	manager, err := ProvidePromptManager(logger)
	if err != nil {
		return nil, err
	}
	dependencies := &application.Dependencies{
		Logger:                 logger,
		Config:                 config,
		SessionManager:         optimizedSessionManager,
		ResourceStore:          store,
		ProgressFactory:        sinkFactory,
		EventPublisher:         publisher,
		SagaCoordinator:        sagaCoordinator,
		WorkflowOrchestrator:   workflowOrchestrator,
		EventAwareOrchestrator: eventAwareOrchestrator,
		SagaAwareOrchestrator:  sagaAwareOrchestrator,
		ErrorPatternRecognizer: errorPatternRecognizer,
		EnhancedErrorHandler:   enhancedErrorHandler,
		StepEnhancer:           stepEnhancer,
		SamplingClient:         domainAdapter,
		PromptManager:          manager,
	}
	mcpServer := ProvideServer(dependencies)
	return mcpServer, nil
}

// wire.go:

// ConfigurationSet - Configuration and environment providers
var ConfigurationSet = wire.NewSet(
	ProvideDefaultServerConfig,
)

// ApplicationSet - Core application dependencies
var ApplicationSet = wire.NewSet(
	ProvideSessionManager,
	ProvideResourceStore,
)

// InfrastructureSet - Infrastructure layer dependencies
var InfrastructureSet = wire.NewSet(
	ProvideSamplingClient,
	ProvidePromptManager,
	provideDomainSampler, wire.Bind(new(sampling.UnifiedSampler), new(*sampling2.DomainAdapter)), steps.ProvideStepProvider, tracing.NewTracerAdapter,
)

// DomainSet - Domain services and events
var DomainSet = wire.NewSet(events.NewPublisher, saga.NewSagaCoordinator)

// WorkflowSet - Workflow orchestration (simplified for now)
var WorkflowSet = wire.NewSet(optimized.ProvideOptimizedBuildStep, optimized.ProvideBuildOptimizer, workflow.ProvideStepFactory, workflow.ProvideBaseOrchestrator, workflow.ProvideEventOrchestrator, workflow.ProvideSagaOrchestrator, workflow.ProvideWorkflowOrchestrator, ProvideProgressFactory, wire.Bind(new(workflow.ProgressTrackerFactory), new(*progress.SinkFactory)))

// MLSet - Machine learning and enhanced capabilities (optional)
var MLSet = wire.NewSet(ml.ProvideErrorPatternRecognizer, ml.ProvideEnhancedErrorHandler, ml.ProvideStepEnhancer, ml.ProvideOptimizedBuildStep)

// AppSet - Main application dependencies using wire.Struct
var AppSet = wire.NewSet(wire.Struct(
	new(application.Dependencies),
	"Logger", "Config", "SessionManager", "ResourceStore",
	"ProgressFactory", "EventPublisher", "SagaCoordinator",
	"WorkflowOrchestrator", "EventAwareOrchestrator", "SagaAwareOrchestrator",
	"ErrorPatternRecognizer", "EnhancedErrorHandler", "StepEnhancer",
	"SamplingClient", "PromptManager",
),
)

// ProviderSet - All providers for the MCP server
var ProviderSet = wire.NewSet(
	ConfigurationSet,
	ApplicationSet,
	InfrastructureSet,
	DomainSet,
	WorkflowSet,
	MLSet,
	AppSet,
	ProvideServer,
)

// ProvideServerConfig creates a server config from individual components
func ProvideServerConfig(
	workspaceDir string,
	storePath string,
	maxSessions int,
	sessionTTL time.Duration,
	transportType string,
) workflow.ServerConfig {
	config := workflow.DefaultServerConfig()
	config.WorkspaceDir = workspaceDir
	config.StorePath = storePath
	config.MaxSessions = maxSessions
	config.SessionTTL = sessionTTL
	config.TransportType = transportType
	return config
}

// ProvideDefaultServerConfig creates a server config with default values from environment
func ProvideDefaultServerConfig() workflow.ServerConfig {
	config := workflow.DefaultServerConfig()
	config.WorkspaceDir = ProvideWorkspaceDir()
	config.StorePath = ProvideStorePath()
	config.MaxSessions = ProvideMaxSessions()
	config.SessionTTL = ProvideSessionTTL()
	config.TransportType = ProvideTransportType()
	return config
}

func ProvideWorkspaceDir() string {
	if dir := os.Getenv("CONTAINER_KIT_WORKSPACE"); dir != "" {
		return dir
	}
	return "/tmp/container-kit"
}

func ProvideStorePath() string {
	if path := os.Getenv("CONTAINER_KIT_STORE_PATH"); path != "" {
		return path
	}
	return "/tmp/container-kit/sessions.db"
}

func ProvideMaxSessions() int {
	if sessions := os.Getenv("CONTAINER_KIT_MAX_SESSIONS"); sessions != "" {
		if n, err := strconv.Atoi(sessions); err == nil {
			return n
		}
	}
	return 10
}

func ProvideSessionTTL() time.Duration {
	if ttl := os.Getenv("CONTAINER_KIT_SESSION_TTL"); ttl != "" {
		if d, err := time.ParseDuration(ttl); err == nil {
			return d
		}
	}
	return 24 * time.Hour
}

func ProvideTransportType() string {
	if transport := os.Getenv("CONTAINER_KIT_TRANSPORT"); transport != "" {
		return transport
	}
	return "stdio"
}

func ProvideSessionManager(config workflow.ServerConfig, logger *slog.Logger) session.OptimizedSessionManager {
	return session.NewOptimizedSessionManager(logger, config.SessionTTL, config.MaxSessions)
}

func ProvideResourceStore(logger *slog.Logger) *resources.Store {
	return resources.NewStore(logger)
}

func ProvideProgressFactory(logger *slog.Logger) *progress.SinkFactory {
	return progress.NewSinkFactory(logger)
}

func ProvideSamplingClient(logger *slog.Logger) (*sampling2.Client, error) {

	if os.Getenv("SAMPLING_MAX_TOKENS") != "" || os.Getenv("SAMPLING_TEMPERATURE") != "" {
		return sampling2.NewClientFromEnv(logger)
	}
	return sampling2.NewClient(logger), nil
}

func ProvidePromptManager(logger *slog.Logger) (*prompts.Manager, error) {
	config := prompts.ManagerConfig{
		EnableHotReload: false,
		AllowOverride:   false,
	}
	return prompts.NewManager(logger, config)
}

// provideDomainSampler creates the domain adapter for sampling
func provideDomainSampler(client *sampling2.Client) *sampling2.DomainAdapter {
	return sampling2.NewDomainAdapter(client)
}

func ProvideServer(deps *application.Dependencies) api.MCPServer {
	return application.NewMCPServerFromDeps(deps)
}
