package build

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/rs/zerolog"
)

// SecurityValidator handles Dockerfile security validation
// Implements DockerfileValidator interface
type SecurityValidator struct {
	logger            zerolog.Logger
	secretPatterns    []*regexp.Regexp
	trustedRegistries []string
}

// NewSecurityValidator creates a new security validator
func NewSecurityValidator(logger zerolog.Logger, trustedRegistries []string) *SecurityValidator {
	return &SecurityValidator{
		logger:            logger.With().Str("component", "security_validator").Logger(),
		trustedRegistries: trustedRegistries,
		secretPatterns:    compileSecretPatterns(),
	}
}

// Validate performs security validation on Dockerfile
func (v *SecurityValidator) Validate(content string, options ValidationOptions) (*ValidationResult, error) {
	if !options.CheckSecurity {
		v.logger.Debug().Msg("Security validation disabled")
		return &ValidationResult{Valid: true}, nil
	}
	v.logger.Info().Msg("Starting Dockerfile security validation")
	result := &ValidationResult{
		Valid:    true,
		Errors:   make([]ValidationError, 0),
		Warnings: make([]ValidationWarning, 0),
		Info:     make([]string, 0),
	}
	lines := strings.Split(content, "\n")
	// Perform various security checks
	v.checkForRootUser(lines, result)
	v.checkForSecrets(lines, result)
	v.checkForSensitivePorts(lines, result)
	v.checkPackagePinning(lines, result)
	v.checkForSUIDBindaries(lines, result)
	v.checkBaseImageSecurity(lines, result)
	v.checkForInsecureDownloads(lines, result)
	// Update validation state
	if len(result.Errors) > 0 {
		result.Valid = false
	}
	return result, nil
}

// checkForRootUser checks if the container runs as root
func (v *SecurityValidator) checkForRootUser(lines []string, result *ValidationResult) {
	hasUser := false
	lastUserIsRoot := false
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		upper := strings.ToUpper(trimmed)
		if strings.HasPrefix(upper, "USER") {
			hasUser = true
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				user := parts[1]
				if user == "root" || user == "0" {
					lastUserIsRoot = true
					result.Errors = append(result.Errors, ValidationError{
						Line:    i + 1,
						Column:  0,
						Message: "Container explicitly set to run as root user. Use a non-root user for better security",
						Rule:    "root_user",
					})
				} else {
					lastUserIsRoot = false
				}
			}
		}
	}
	if !hasUser || lastUserIsRoot {
		result.Errors = append(result.Errors, ValidationError{
			Line:    0,
			Column:  0,
			Message: "Container runs as root user by default. Add 'USER <non-root-user>' instruction to run as non-root",
			Rule:    "root_user",
		})
	}
}

// checkForSecrets checks for hardcoded secrets
func (v *SecurityValidator) checkForSecrets(lines []string, result *ValidationResult) {
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip comments
		if strings.HasPrefix(trimmed, "#") {
			continue
		}
		// Check for secret patterns
		for _, pattern := range v.secretPatterns {
			if pattern.MatchString(line) {
				result.Errors = append(result.Errors, ValidationError{
					Line:    i + 1,
					Column:  0,
					Message: "Possible secret or sensitive data detected. Use build arguments or environment variables at runtime instead of hardcoding secrets",
					Rule:    "exposed_secret",
				})
				break
			}
		}
		// Check for common secret keywords
		upper := strings.ToUpper(line)
		if strings.Contains(upper, "PASSWORD=") ||
			strings.Contains(upper, "API_KEY=") ||
			strings.Contains(upper, "SECRET=") ||
			strings.Contains(upper, "TOKEN=") {
			result.Errors = append(result.Errors, ValidationError{
				Line:    i + 1,
				Column:  0,
				Message: "Sensitive environment variable detected. Use secrets management solution instead of hardcoding",
				Rule:    "exposed_secret",
			})
		}
	}
}

// checkForSensitivePorts checks for commonly attacked ports
func (v *SecurityValidator) checkForSensitivePorts(lines []string, result *ValidationResult) {
	sensitivePorts := map[int]string{
		22:    "SSH",
		23:    "Telnet",
		3389:  "RDP",
		5900:  "VNC",
		5432:  "PostgreSQL",
		3306:  "MySQL",
		6379:  "Redis",
		27017: "MongoDB",
	}
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		upper := strings.ToUpper(trimmed)
		if strings.HasPrefix(upper, "EXPOSE") {
			ports := extractPorts(trimmed)
			for _, port := range ports {
				if service, exists := sensitivePorts[port]; exists {
					result.Errors = append(result.Errors, ValidationError{
						Line:    i + 1,
						Column:  0,
						Message: fmt.Sprintf("Exposed sensitive port %d (%s). Ensure this port exposure is necessary and properly secured", port, service),
						Rule:    "sensitive_port",
					})
				}
			}
		}
	}
}

// checkPackagePinning checks if packages are version-pinned
func (v *SecurityValidator) checkPackagePinning(lines []string, result *ValidationResult) {
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Check apt-get install without version pinning
		if strings.Contains(trimmed, "apt-get install") &&
			!strings.Contains(trimmed, "apt-get update") {
			// Check if any package has version specified
			hasVersionPin := false
			if strings.Contains(trimmed, "=") {
				// Simple check for version pinning
				hasVersionPin = true
			}
			if !hasVersionPin && !strings.Contains(trimmed, "-y") {
				result.Errors = append(result.Errors, ValidationError{
					Line:    i + 1,
					Column:  0,
					Message: "Package installation without version pinning. Pin package versions for reproducible builds (e.g., package=1.2.3)",
					Rule:    "unpinned_packages",
				})
			}
		}
		// Check pip install without version pinning
		if strings.Contains(trimmed, "pip install") &&
			!strings.Contains(trimmed, "requirements") {
			if !strings.Contains(trimmed, "==") && !strings.Contains(trimmed, ">=") {
				result.Errors = append(result.Errors, ValidationError{
					Line:    i + 1,
					Column:  0,
					Message: "Python package installation without version pinning. Pin package versions (e.g., package==1.2.3)",
					Rule:    "unpinned_packages",
				})
			}
		}
	}
}

// checkForSUIDBindaries checks for SUID/SGID binary creation
func (v *SecurityValidator) checkForSUIDBindaries(lines []string, result *ValidationResult) {
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Check for chmod with SUID/SGID bits
		if strings.Contains(trimmed, "chmod") {
			if strings.Contains(trimmed, "+s") ||
				strings.Contains(trimmed, "4755") ||
				strings.Contains(trimmed, "4777") ||
				strings.Contains(trimmed, "2755") {
				result.Errors = append(result.Errors, ValidationError{
					Line:    i + 1,
					Column:  0,
					Message: "Setting SUID/SGID bits on files. Avoid using SUID/SGID binaries unless absolutely necessary",
					Rule:    "suid_binary",
				})
			}
		}
	}
}

// checkBaseImageSecurity checks base image security
func (v *SecurityValidator) checkBaseImageSecurity(lines []string, result *ValidationResult) {
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		upper := strings.ToUpper(trimmed)
		if strings.HasPrefix(upper, "FROM") {
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				image := parts[1]
				// Check for latest tag
				if strings.Contains(image, ":latest") || !strings.Contains(image, ":") {
					result.Errors = append(result.Errors, ValidationError{
						Line:    i + 1,
						Column:  0,
						Message: "Using 'latest' tag or untagged base image. Use specific version tags for base images",
						Rule:    "unpinned_base_image",
					})
				}
				// Check trusted registries
				if len(v.trustedRegistries) > 0 && !v.isFromTrustedRegistry(image) {
					result.Errors = append(result.Errors, ValidationError{
						Line:    i + 1,
						Column:  0,
						Message: "Base image from untrusted registry. Use base images from trusted registries only",
						Rule:    "untrusted_base_image",
					})
				}
			}
		}
	}
}

// checkForInsecureDownloads checks for insecure file downloads
func (v *SecurityValidator) checkForInsecureDownloads(lines []string, result *ValidationResult) {
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Check for wget/curl with http://
		if (strings.Contains(trimmed, "wget") || strings.Contains(trimmed, "curl")) &&
			strings.Contains(trimmed, "http://") &&
			!strings.Contains(trimmed, "localhost") &&
			!strings.Contains(trimmed, "127.0.0.1") {
			result.Errors = append(result.Errors, ValidationError{
				Line:    i + 1,
				Column:  0,
				Message: "Downloading files over insecure HTTP. Use HTTPS for all external downloads",
				Rule:    "insecure_download",
			})
		}
		// Check for ADD with remote URL
		upper := strings.ToUpper(trimmed)
		if strings.HasPrefix(upper, "ADD") && strings.Contains(trimmed, "http") {
			result.Errors = append(result.Errors, ValidationError{
				Line:    i + 1,
				Column:  0,
				Message: "Using ADD for remote file download. Use RUN with curl/wget for better control and verification",
				Rule:    "add_remote_file",
			})
		}
	}
}

// Helper functions
func (v *SecurityValidator) containsSecret(line string) bool {
	for _, pattern := range v.secretPatterns {
		if pattern.MatchString(line) {
			return true
		}
	}
	return false
}
func (v *SecurityValidator) isFromTrustedRegistry(image string) bool {
	for _, trusted := range v.trustedRegistries {
		if strings.HasPrefix(image, trusted) {
			return true
		}
	}
	// Check if it's an official image (no registry prefix)
	if !strings.Contains(image, "/") || strings.Count(image, "/") == 1 {
		return true
	}
	return false
}
func extractPorts(exposeLine string) []int {
	ports := make([]int, 0)
	parts := strings.Fields(exposeLine)
	for i := 1; i < len(parts); i++ {
		portStr := strings.TrimSuffix(parts[i], "/tcp")
		portStr = strings.TrimSuffix(portStr, "/udp")
		if port, err := strconv.Atoi(portStr); err == nil {
			ports = append(ports, port)
		}
	}
	return ports
}
func compileSecretPatterns() []*regexp.Regexp {
	patterns := []string{
		`(?i)(api[_-]?key|apikey)\s*[:=]\s*['"]\S+['"]`,
		`(?i)(secret|token)\s*[:=]\s*['"]\S+['"]`,
		`(?i)password\s*[:=]\s*['"]\S+['"]`,
		`(?i)bearer\s+[a-zA-Z0-9\-_]+`,
		`[a-zA-Z0-9]{32,}`, // Long random strings
		`-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----`,
	}
	compiled := make([]*regexp.Regexp, 0, len(patterns))
	for _, pattern := range patterns {
		if re, err := regexp.Compile(pattern); err == nil {
			compiled = append(compiled, re)
		}
	}
	return compiled
}

// SecurityPolicy defines a security policy for container builds
type SecurityPolicy struct {
	Name                 string                `json:"name"`
	Description          string                `json:"description"`
	Version              string                `json:"version"`
	EnforcementLevel     string                `json:"enforcement_level"` // strict, moderate, relaxed
	Rules                []SecurityRule        `json:"rules"`
	TrustedRegistries    []string              `json:"trusted_registries"`
	ForbiddenPackages    []string              `json:"forbidden_packages"`
	RequiredLabels       []string              `json:"required_labels"`
	MaxImageSizeMB       int                   `json:"max_image_size_mb"`
	AllowedBaseImages    []string              `json:"allowed_base_images"`
	ComplianceFrameworks []ComplianceFramework `json:"compliance_frameworks"`
}

// SecurityRule defines a specific security rule
type SecurityRule struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Severity    string   `json:"severity"` // critical, high, medium, low
	Category    string   `json:"category"`
	Enabled     bool     `json:"enabled"`
	Action      string   `json:"action"` // block, warn, info
	Patterns    []string `json:"patterns"`
}

// ComplianceFramework defines compliance requirements
type ComplianceFramework struct {
	Name         string                  `json:"name"` // CIS, NIST, PCI-DSS, etc.
	Version      string                  `json:"version"`
	Requirements []ComplianceRequirement `json:"requirements"`
}

// ComplianceRequirement defines a specific compliance requirement
type ComplianceRequirement struct {
	ID          string `json:"id"`
	Description string `json:"description"`
	Category    string `json:"category"`
	Check       string `json:"check"` // Function name or rule to check
}

// EnhancedSecurityValidator extends SecurityValidator with policy support
type EnhancedSecurityValidator struct {
	*SecurityValidator
	policies         map[string]*SecurityPolicy
	activePolicy     *SecurityPolicy
	complianceEngine *ComplianceEngine
	vulnerabilityDB  *VulnerabilityDatabase
}

// NewEnhancedSecurityValidator creates a new enhanced security validator
func NewEnhancedSecurityValidator(logger zerolog.Logger, trustedRegistries []string) *EnhancedSecurityValidator {
	return &EnhancedSecurityValidator{
		SecurityValidator: NewSecurityValidator(logger, trustedRegistries),
		policies:          make(map[string]*SecurityPolicy),
		complianceEngine:  NewComplianceEngine(logger),
		vulnerabilityDB:   NewVulnerabilityDatabase(logger),
	}
}

// LoadPolicy loads a security policy
func (v *EnhancedSecurityValidator) LoadPolicy(policy *SecurityPolicy) error {
	if policy.Name == "" {
		return fmt.Errorf("policy name is required")
	}
	v.policies[policy.Name] = policy
	v.logger.Info().Str("policy", policy.Name).Msg("Loaded security policy")
	return nil
}

// SetActivePolicy sets the active security policy
func (v *EnhancedSecurityValidator) SetActivePolicy(policyName string) error {
	policy, exists := v.policies[policyName]
	if !exists {
		return fmt.Errorf("policy not found: %s", policyName)
	}
	v.activePolicy = policy
	v.logger.Info().Str("policy", policyName).Msg("Set active security policy")
	return nil
}

// ValidateWithPolicy performs validation with the active security policy
func (v *EnhancedSecurityValidator) ValidateWithPolicy(content string, options ValidationOptions) (*SecurityValidationResult, error) {
	if v.activePolicy == nil {
		return nil, fmt.Errorf("no active security policy set")
	}

	// For now, just perform base validation until enhanced validation is fully implemented
	// TODO: Implement full enhanced validation with policy compliance
	return v.Validate(content, options)
}

// applyPolicyRules applies security policy rules
func (v *EnhancedSecurityValidator) applyPolicyRules(lines []string, result *SecurityValidationResult) {
	for _, rule := range v.activePolicy.Rules {
		if !rule.Enabled {
			continue
		}

		violations := v.checkRule(lines, rule)
		for _, violation := range violations {
			result.PolicyViolations = append(result.PolicyViolations, violation)

			// Add to errors or warnings based on action
			switch rule.Action {
			case "block":
				result.Errors = append(result.Errors, ValidationError{
					Line:    violation.Line,
					Column:  0,
					Message: violation.Message,
					Rule:    rule.ID,
				})
				result.Valid = false
			case "warn":
				result.Warnings = append(result.Warnings, ValidationWarning{
					Line:    violation.Line,
					Column:  0,
					Message: violation.Message,
					Rule:    rule.ID,
				})
			}
		}
	}
}

// checkRule checks a specific security rule
func (v *EnhancedSecurityValidator) checkRule(lines []string, rule SecurityRule) []PolicyViolation {
	violations := []PolicyViolation{}

	// Compile patterns for this rule
	patterns := make([]*regexp.Regexp, 0, len(rule.Patterns))
	for _, pattern := range rule.Patterns {
		if re, err := regexp.Compile(pattern); err == nil {
			patterns = append(patterns, re)
		}
	}

	// Check each line against patterns
	for i, line := range lines {
		for _, pattern := range patterns {
			if pattern.MatchString(line) {
				violations = append(violations, PolicyViolation{
					RuleID:      rule.ID,
					RuleName:    rule.Name,
					Severity:    rule.Severity,
					Line:        i + 1,
					Message:     fmt.Sprintf("%s: %s", rule.Name, rule.Description),
					Remediation: v.getRemediation(rule.ID),
				})
				break
			}
		}
	}

	return violations
}

// checkCompliance checks compliance with frameworks
func (v *EnhancedSecurityValidator) checkCompliance(lines []string, result *SecurityValidationResult) {
	for _, framework := range v.activePolicy.ComplianceFrameworks {
		compliant := true
		for _, req := range framework.Requirements {
			if !v.checkComplianceRequirement(lines, req) {
				compliant = false
				result.PolicyViolations = append(result.PolicyViolations, PolicyViolation{
					RuleID:      req.ID,
					RuleName:    fmt.Sprintf("%s - %s", framework.Name, req.ID),
					Severity:    "high",
					Line:        0,
					Message:     fmt.Sprintf("Non-compliant with %s: %s", framework.Name, req.Description),
					Remediation: v.getComplianceRemediation(framework.Name, req.ID),
				})
			}
		}
		result.ComplianceStatus[framework.Name] = compliant
	}
}

// checkComplianceRequirement checks a specific compliance requirement
func (v *EnhancedSecurityValidator) checkComplianceRequirement(lines []string, req ComplianceRequirement) bool {
	switch req.Check {
	case "no_root_user":
		return v.checkNoRootUser(lines)
	case "minimal_base_image":
		return v.checkMinimalBaseImage(lines)
	case "no_sudo_install":
		return v.checkNoSudoInstall(lines)
	case "healthcheck_defined":
		return v.checkHealthcheckDefined(lines)
	case "no_ssh_server":
		return v.checkNoSSHServer(lines)
	case "secrets_management":
		return v.checkSecretsManagement(lines)
	case "logging_configured":
		return v.checkLoggingConfigured(lines)
	case "resource_limits":
		return v.checkResourceLimits(lines)
	case "no_privileged_ports":
		return v.checkNoPrivilegedPorts(lines)
	case "signed_images":
		return v.checkSignedImages(lines)
	default:
		return true // Unknown check passes by default
	}
}

// assessRisk performs risk assessment
func (v *EnhancedSecurityValidator) assessRisk(result *SecurityValidationResult) {
	risk := &result.RiskAssessment

	// Count violations by severity
	for _, violation := range result.PolicyViolations {
		switch violation.Severity {
		case "critical":
			risk.CriticalRisks++
		case "high":
			risk.HighRisks++
		case "medium":
			risk.MediumRisks++
		case "low":
			risk.LowRisks++
		}
	}

	// Determine overall risk level
	if risk.CriticalRisks > 0 {
		risk.OverallRisk = "critical"
		risk.RiskScore = 100
	} else if risk.HighRisks > 2 {
		risk.OverallRisk = "high"
		risk.RiskScore = 80
	} else if risk.HighRisks > 0 || risk.MediumRisks > 5 {
		risk.OverallRisk = "medium"
		risk.RiskScore = 60
	} else if risk.MediumRisks > 0 || risk.LowRisks > 10 {
		risk.OverallRisk = "low"
		risk.RiskScore = 40
	} else {
		risk.OverallRisk = "minimal"
		risk.RiskScore = 20
	}

	// Add risk factors
	if len(result.Errors) > 0 {
		risk.RiskFactors = append(risk.RiskFactors, fmt.Sprintf("%d security errors found", len(result.Errors)))
	}
	if risk.CriticalRisks > 0 {
		risk.RiskFactors = append(risk.RiskFactors, fmt.Sprintf("%d critical security risks identified", risk.CriticalRisks))
	}

	// Add mitigation recommendations
	risk.Mitigations = v.generateMitigations(result)
}

// calculateSecurityScore calculates overall security score
func (v *EnhancedSecurityValidator) calculateSecurityScore(result *SecurityValidationResult) {
	score := 100

	// Deduct points for violations
	for _, violation := range result.PolicyViolations {
		switch violation.Severity {
		case "critical":
			score -= 20
		case "high":
			score -= 10
		case "medium":
			score -= 5
		case "low":
			score -= 2
		}
	}

	// Deduct for non-compliance
	for framework, compliant := range result.ComplianceStatus {
		if !compliant {
			score -= 15
			v.logger.Warn().Str("framework", framework).Msg("Non-compliant with framework")
		}
	}

	// Ensure score doesn't go below 0
	if score < 0 {
		score = 0
	}

	result.SecurityScore = score
}

// Helper methods
func (v *EnhancedSecurityValidator) getRemediation(ruleID string) string {
	// This would return specific remediation steps for each rule
	remediations := map[string]string{
		"no-root-user": "Add 'USER <non-root-user>' instruction to run container as non-root",
		"pin-versions": "Pin all package versions for reproducible builds",
		"no-secrets":   "Use secrets management solution instead of hardcoding secrets",
	}

	if remediation, exists := remediations[ruleID]; exists {
		return remediation
	}
	return "Review and fix the security issue"
}

func (v *EnhancedSecurityValidator) getComplianceRemediation(framework, reqID string) string {
	// This would return specific compliance remediation steps
	return fmt.Sprintf("Implement %s requirement %s", framework, reqID)
}

func (v *EnhancedSecurityValidator) generateMitigations(result *SecurityValidationResult) []string {
	mitigations := []string{}

	if result.RiskAssessment.CriticalRisks > 0 {
		mitigations = append(mitigations, "Address all critical security issues immediately")
	}
	if result.RiskAssessment.HighRisks > 0 {
		mitigations = append(mitigations, "Fix high-severity security issues before deployment")
	}
	if result.SecurityScore < 70 {
		mitigations = append(mitigations, "Improve security practices to achieve minimum security score of 70")
	}

	return mitigations
}

// Additional types for enhanced security validation

// EnhancedSecurityValidationResult extends ValidationResult with security-specific information
type EnhancedSecurityValidationResult struct {
	*ValidationResult
	PolicyName       string            `json:"policy_name"`
	PolicyVersion    string            `json:"policy_version"`
	ComplianceStatus map[string]bool   `json:"compliance_status"`
	PolicyViolations []PolicyViolation `json:"policy_violations"`
	SecurityScore    int               `json:"security_score"`
	RiskAssessment   SecurityRiskAssessment    `json:"risk_assessment"`
}

// PolicyViolation represents a security policy violation
type PolicyViolation struct {
	RuleID      string `json:"rule_id"`
	RuleName    string `json:"rule_name"`
	Severity    string `json:"severity"`
	Line        int    `json:"line"`
	Message     string `json:"message"`
	Remediation string `json:"remediation"`
}

// SecurityRiskAssessment contains risk analysis results
type SecurityRiskAssessment struct {
	OverallRisk   string   `json:"overall_risk"`
	RiskScore     int      `json:"risk_score"`
	CriticalRisks int      `json:"critical_risks"`
	HighRisks     int      `json:"high_risks"`
	MediumRisks   int      `json:"medium_risks"`
	LowRisks      int      `json:"low_risks"`
	RiskFactors   []string `json:"risk_factors"`
	Mitigations   []string `json:"mitigations"`
}

// ComplianceEngine handles compliance checking
type ComplianceEngine struct {
	logger zerolog.Logger
}

func NewComplianceEngine(logger zerolog.Logger) *ComplianceEngine {
	return &ComplianceEngine{
		logger: logger.With().Str("component", "compliance_engine").Logger(),
	}
}

// VulnerabilityDatabase handles vulnerability checking
type VulnerabilityDatabase struct {
	logger zerolog.Logger
}

func NewVulnerabilityDatabase(logger zerolog.Logger) *VulnerabilityDatabase {
	return &VulnerabilityDatabase{
		logger: logger.With().Str("component", "vulnerability_db").Logger(),
	}
}

// Compliance check implementations

// checkNoRootUser verifies container doesn't run as root
func (v *EnhancedSecurityValidator) checkNoRootUser(lines []string) bool {
	hasUser := false
	lastUserIsRoot := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		upper := strings.ToUpper(trimmed)

		if strings.HasPrefix(upper, "USER") {
			hasUser = true
			parts := strings.Fields(trimmed)
			if len(parts) >= 2 {
				user := parts[1]
				lastUserIsRoot = (user == "root" || user == "0")
			}
		}
	}

	return hasUser && !lastUserIsRoot
}

// checkMinimalBaseImage checks if using minimal base images
func (v *EnhancedSecurityValidator) checkMinimalBaseImage(lines []string) bool {
	minimalImages := []string{
		"alpine", "scratch", "distroless", "busybox", "-slim", "-minimal",
	}

	for _, line := range lines {
		if strings.HasPrefix(strings.ToUpper(strings.TrimSpace(line)), "FROM") {
			for _, minimal := range minimalImages {
				if strings.Contains(strings.ToLower(line), minimal) {
					return true
				}
			}
		}
	}

	return false
}

// checkNoSudoInstall checks that sudo is not installed
func (v *EnhancedSecurityValidator) checkNoSudoInstall(lines []string) bool {
	for _, line := range lines {
		if strings.Contains(line, "install") && strings.Contains(line, "sudo") {
			return false
		}
	}
	return true
}

// checkHealthcheckDefined verifies HEALTHCHECK instruction exists
func (v *EnhancedSecurityValidator) checkHealthcheckDefined(lines []string) bool {
	for _, line := range lines {
		if strings.HasPrefix(strings.ToUpper(strings.TrimSpace(line)), "HEALTHCHECK") {
			return true
		}
	}
	return false
}

// checkNoSSHServer checks that SSH server is not installed
func (v *EnhancedSecurityValidator) checkNoSSHServer(lines []string) bool {
	sshPackages := []string{"openssh-server", "ssh-server", "sshd"}

	for _, line := range lines {
		for _, pkg := range sshPackages {
			if strings.Contains(line, pkg) && strings.Contains(line, "install") {
				return false
			}
		}
	}
	return true
}

// checkSecretsManagement verifies no hardcoded secrets
func (v *EnhancedSecurityValidator) checkSecretsManagement(lines []string) bool {
	for _, line := range lines {
		upper := strings.ToUpper(line)
		// Check for hardcoded secrets
		if strings.Contains(upper, "PASSWORD=") ||
			strings.Contains(upper, "API_KEY=") ||
			strings.Contains(upper, "SECRET=") ||
			strings.Contains(upper, "TOKEN=") {
			// Allow if it's using ARG or ENV with placeholder
			if strings.Contains(upper, "ARG ") ||
				strings.Contains(line, "${") ||
				strings.Contains(line, "$(") {
				continue
			}
			return false
		}
	}
	return true
}

// checkLoggingConfigured checks if logging is properly configured
func (v *EnhancedSecurityValidator) checkLoggingConfigured(lines []string) bool {
	// Check for logging configuration
	loggingPatterns := []string{
		"LOG_", "LOGGING_", "log4j", "logback", "winston", "morgan",
		"/var/log", "stdout", "stderr",
	}

	for _, line := range lines {
		for _, pattern := range loggingPatterns {
			if strings.Contains(strings.ToLower(line), pattern) {
				return true
			}
		}
	}

	return false
}

// checkResourceLimits checks if resource limits are defined
func (v *EnhancedSecurityValidator) checkResourceLimits(lines []string) bool {
	// In Dockerfile, resource limits are typically set at runtime
	// Check for documentation or labels indicating limits
	for _, line := range lines {
		if strings.Contains(line, "LABEL") &&
			(strings.Contains(line, "memory") || strings.Contains(line, "cpu")) {
			return true
		}
	}
	return false
}

// checkNoPrivilegedPorts verifies no privileged ports (<1024) are exposed
func (v *EnhancedSecurityValidator) checkNoPrivilegedPorts(lines []string) bool {
	for _, line := range lines {
		if strings.HasPrefix(strings.ToUpper(strings.TrimSpace(line)), "EXPOSE") {
			ports := extractPorts(line)
			for _, port := range ports {
				if port < 1024 && port != 80 && port != 443 {
					return false
				}
			}
		}
	}
	return true
}

// checkSignedImages checks if base images use content trust
func (v *EnhancedSecurityValidator) checkSignedImages(lines []string) bool {
	for _, line := range lines {
		if strings.HasPrefix(strings.ToUpper(strings.TrimSpace(line)), "FROM") {
			// Check for digest reference (indicates signed image)
			if strings.Contains(line, "@sha256:") {
				return true
			}
		}
	}
	return false
}

// GetDefaultCISDockerBenchmark returns CIS Docker Benchmark compliance framework
func GetDefaultCISDockerBenchmark() *ComplianceFramework {
	return &ComplianceFramework{
		Name:    "CIS-Docker-Benchmark",
		Version: "1.4.0",
		Requirements: []ComplianceRequirement{
			{
				ID:          "4.1",
				Description: "Ensure a user for the container has been created",
				Category:    "Container Images and Build File",
				Check:       "no_root_user",
			},
			{
				ID:          "4.2",
				Description: "Ensure that containers use only trusted base images",
				Category:    "Container Images and Build File",
				Check:       "signed_images",
			},
			{
				ID:          "4.3",
				Description: "Ensure unnecessary packages are not installed",
				Category:    "Container Images and Build File",
				Check:       "minimal_base_image",
			},
			{
				ID:          "4.5",
				Description: "Ensure Content trust for Docker is Enabled",
				Category:    "Container Images and Build File",
				Check:       "signed_images",
			},
			{
				ID:          "4.6",
				Description: "Ensure HEALTHCHECK instructions have been added",
				Category:    "Container Images and Build File",
				Check:       "healthcheck_defined",
			},
			{
				ID:          "4.7",
				Description: "Ensure update instructions are not used alone",
				Category:    "Container Images and Build File",
				Check:       "no_root_user",
			},
			{
				ID:          "4.9",
				Description: "Ensure COPY is used instead of ADD",
				Category:    "Container Images and Build File",
				Check:       "minimal_base_image",
			},
			{
				ID:          "4.10",
				Description: "Ensure secrets are not stored in images",
				Category:    "Container Images and Build File",
				Check:       "secrets_management",
			},
		},
	}
}

// GetDefaultNISTFramework returns NIST 800-190 compliance framework
func GetDefaultNISTFramework() *ComplianceFramework {
	return &ComplianceFramework{
		Name:    "NIST-800-190",
		Version: "1.0",
		Requirements: []ComplianceRequirement{
			{
				ID:          "CP-1",
				Description: "Use minimal base images",
				Category:    "Container Protection",
				Check:       "minimal_base_image",
			},
			{
				ID:          "CP-2",
				Description: "Remove unnecessary tools and packages",
				Category:    "Container Protection",
				Check:       "no_sudo_install",
			},
			{
				ID:          "CP-3",
				Description: "Scan images for vulnerabilities",
				Category:    "Container Protection",
				Check:       "signed_images",
			},
			{
				ID:          "AC-1",
				Description: "Run containers with non-root users",
				Category:    "Access Control",
				Check:       "no_root_user",
			},
			{
				ID:          "AC-2",
				Description: "Limit container capabilities",
				Category:    "Access Control",
				Check:       "resource_limits",
			},
			{
				ID:          "AU-1",
				Description: "Enable logging for containers",
				Category:    "Audit and Accountability",
				Check:       "logging_configured",
			},
			{
				ID:          "SC-1",
				Description: "Protect sensitive data in containers",
				Category:    "System and Communications Protection",
				Check:       "secrets_management",
			},
			{
				ID:          "SC-2",
				Description: "Use secure communication channels",
				Category:    "System and Communications Protection",
				Check:       "no_ssh_server",
			},
		},
	}
}

// GetDefaultPCIDSSFramework returns PCI-DSS compliance framework
func GetDefaultPCIDSSFramework() *ComplianceFramework {
	return &ComplianceFramework{
		Name:    "PCI-DSS",
		Version: "4.0",
		Requirements: []ComplianceRequirement{
			{
				ID:          "2.2.2",
				Description: "Enable only necessary services",
				Category:    "Secure Configuration",
				Check:       "no_ssh_server",
			},
			{
				ID:          "2.2.5",
				Description: "Remove unnecessary functionality",
				Category:    "Secure Configuration",
				Check:       "minimal_base_image",
			},
			{
				ID:          "2.3",
				Description: "Encrypt all non-console administrative access",
				Category:    "Secure Configuration",
				Check:       "no_ssh_server",
			},
			{
				ID:          "6.2",
				Description: "Ensure all components are protected from known vulnerabilities",
				Category:    "Vulnerability Management",
				Check:       "signed_images",
			},
			{
				ID:          "7.1",
				Description: "Limit access to system components",
				Category:    "Access Control",
				Check:       "no_root_user",
			},
			{
				ID:          "8.2.1",
				Description: "Strong cryptography for authentication",
				Category:    "Authentication",
				Check:       "secrets_management",
			},
			{
				ID:          "10.1",
				Description: "Implement audit trails",
				Category:    "Logging and Monitoring",
				Check:       "logging_configured",
			},
			{
				ID:          "11.5",
				Description: "Deploy change detection mechanisms",
				Category:    "Security Testing",
				Check:       "signed_images",
			},
		},
	}
}

// LoadDefaultComplianceFrameworks loads all default compliance frameworks
func (v *EnhancedSecurityValidator) LoadDefaultComplianceFrameworks() {
	// Create default security policy with all frameworks
	defaultPolicy := &SecurityPolicy{
		Name:             "default-compliance",
		Description:      "Default compliance policy with CIS, NIST, and PCI-DSS",
		Version:          "1.0",
		EnforcementLevel: "strict",
		Rules: []SecurityRule{
			{
				ID:          "no-root",
				Name:        "No Root User",
				Description: "Containers must not run as root",
				Severity:    "high",
				Category:    "access-control",
				Enabled:     true,
				Action:      "block",
				Patterns:    []string{`USER\s+(root|0)`},
			},
			{
				ID:          "no-secrets",
				Name:        "No Hardcoded Secrets",
				Description: "No hardcoded passwords or API keys",
				Severity:    "critical",
				Category:    "secrets",
				Enabled:     true,
				Action:      "block",
				Patterns: []string{
					`(?i)(password|pwd|passwd)\s*=\s*['"][^'"]+['"]`,
					`(?i)(api[_-]?key|apikey)\s*=\s*['"][^'"]+['"]`,
					`(?i)(secret|token)\s*=\s*['"][^'"]+['"]`,
				},
			},
			{
				ID:          "use-minimal-base",
				Name:        "Use Minimal Base Images",
				Description: "Use minimal base images like alpine or distroless",
				Severity:    "medium",
				Category:    "image-security",
				Enabled:     true,
				Action:      "warn",
				Patterns:    []string{`FROM\s+(ubuntu|debian|centos)(?!.*slim|.*minimal)`},
			},
		},
		TrustedRegistries: []string{
			"docker.io",
			"gcr.io",
			"quay.io",
			"registry.hub.docker.com",
		},
		ComplianceFrameworks: []ComplianceFramework{
			*GetDefaultCISDockerBenchmark(),
			*GetDefaultNISTFramework(),
			*GetDefaultPCIDSSFramework(),
		},
	}

	// Load the default policy
	v.LoadPolicy(defaultPolicy)
	v.SetActivePolicy("default-compliance")
}
