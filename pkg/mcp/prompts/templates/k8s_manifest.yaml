name: "containerKit.k8sManifest"
version: "1.0.0"
description: "Generate production-ready Kubernetes deployment manifests"
category: "generation"
parameters:
  app_name:
    type: "string"
    description: "Application name"
    required: true
    pattern: "^[a-z0-9-]+$"
    max_length: 63
  image:
    type: "string"
    description: "Container image"
    required: true
    examples: ["nginx:latest", "myapp:v1.0.0", "ghcr.io/org/app:main"]
  namespace:
    type: "string"
    description: "Kubernetes namespace"
    default: "default"
    pattern: "^[a-z0-9-]+$"
  replicas:
    type: "number"
    description: "Number of replicas"
    default: 2
    range: [1, 100]
  port:
    type: "number"
    description: "Application port"
    default: 8080
    range: [1, 65535]
  service_type:
    type: "string"
    description: "Service type"
    default: "ClusterIP"
    options: ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"]
  resources:
    type: "object"
    description: "Resource requirements"
    default:
      requests:
        cpu: "100m"
        memory: "128Mi"
      limits:
        cpu: "500m"
        memory: "512Mi"
  environment:
    type: "string"
    description: "Deployment environment"
    default: "development"
    options: ["development", "staging", "production"]

template: |
  I'll generate production-ready Kubernetes manifests for your application.
  
  ## Deployment Configuration
  - **Application**: {{.app_name}}
  - **Image**: {{.image}}
  - **Namespace**: {{.namespace}}
  - **Replicas**: {{.replicas}}
  - **Port**: {{.port}}
  - **Service Type**: {{.service_type}}
  - **Environment**: {{.environment}}
  
  ## Resource Requirements
  ```yaml
  resources:
    requests:
      cpu: {{.resources.requests.cpu}}
      memory: {{.resources.requests.memory}}
    limits:
      cpu: {{.resources.limits.cpu}}
      memory: {{.resources.limits.memory}}
  ```
  
  ## Required Kubernetes Manifests
  Please generate the following manifests with production-ready configurations:
  
  ### 1. üì¶ Deployment
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: {{.app_name}}
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
      version: "1.0.0"
  spec:
    replicas: {{.replicas}}
    strategy:
      type: RollingUpdate
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0
    selector:
      matchLabels:
        app: {{.app_name}}
    template:
      metadata:
        labels:
          app: {{.app_name}}
          environment: {{.environment}}
      spec:
        containers:
        - name: {{.app_name}}
          image: {{.image}}
          ports:
          - containerPort: {{.port}}
            protocol: TCP
          resources:
            requests:
              cpu: {{.resources.requests.cpu}}
              memory: {{.resources.requests.memory}}
            limits:
              cpu: {{.resources.limits.cpu}}
              memory: {{.resources.limits.memory}}
          # Add appropriate health checks
          livenessProbe:
            httpGet:
              path: /health
              port: {{.port}}
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: {{.port}}
            initialDelaySeconds: 5
            periodSeconds: 5
          # Security context
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
              - ALL
  ```
  
  ### 2. üåê Service
  ```yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: {{.app_name}}-service
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
  spec:
    type: {{.service_type}}
    ports:
    - port: 80
      targetPort: {{.port}}
      protocol: TCP
      name: http
    selector:
      app: {{.app_name}}
  ```
  
  ### 3. üîí ServiceAccount
  ```yaml
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: {{.app_name}}-sa
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
  automountServiceAccountToken: false
  ```
  
  ### 4. üìù ConfigMap (if needed)
  ```yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: {{.app_name}}-config
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
  data:
    # Add your application configuration here
    app.env: "{{.environment}}"
    log.level: "info"
  ```
  
  {{if eq .environment "production"}}
  ### 5. üìä HorizontalPodAutoscaler
  ```yaml
  apiVersion: autoscaling/v2
  kind: HorizontalPodAutoscaler
  metadata:
    name: {{.app_name}}-hpa
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
  spec:
    scaleTargetRef:
      apiVersion: apps/v1
      kind: Deployment
      name: {{.app_name}}
    minReplicas: {{.replicas}}
    maxReplicas: 10
    metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  ```
  {{end}}
  
  ### 6. üõ°Ô∏è NetworkPolicy (Security)
  ```yaml
  apiVersion: networking.k8s.io/v1
  kind: NetworkPolicy
  metadata:
    name: {{.app_name}}-netpol
    namespace: {{.namespace}}
    labels:
      app: {{.app_name}}
      environment: {{.environment}}
  spec:
    podSelector:
      matchLabels:
        app: {{.app_name}}
    policyTypes:
    - Ingress
    - Egress
    ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: {{.namespace}}
      ports:
      - protocol: TCP
        port: {{.port}}
    egress:
    - {} # Allow all egress (customize as needed)
  ```
  
  ## Best Practices Included
  ‚úÖ **Security**: Non-root user, read-only filesystem, dropped capabilities
  ‚úÖ **Reliability**: Rolling updates, health checks, resource limits
  ‚úÖ **Observability**: Proper labels and metadata
  ‚úÖ **Scalability**: HPA for production environments
  ‚úÖ **Network Security**: NetworkPolicy for traffic control
  
  ## Deployment Commands
  ```bash
  # Apply all manifests
  kubectl apply -f deployment.yaml
  kubectl apply -f service.yaml
  kubectl apply -f serviceaccount.yaml
  kubectl apply -f configmap.yaml
  {{if eq .environment "production"}}
  kubectl apply -f hpa.yaml
  {{end}}
  kubectl apply -f networkpolicy.yaml
  
  # Verify deployment
  kubectl get pods -n {{.namespace}} -l app={{.app_name}}
  kubectl get svc -n {{.namespace}} -l app={{.app_name}}
  
  # Check rollout status
  kubectl rollout status deployment/{{.app_name}} -n {{.namespace}}
  ```
  
  ## Customization Notes
  - Adjust health check paths based on your application endpoints
  - Modify resource requests/limits based on actual usage
  - Update security contexts based on application requirements
  - Add environment-specific configurations to ConfigMap
  - Configure ingress if external access is needed
  
  Please generate complete, production-ready Kubernetes manifests based on this template.

metadata:
  tags: ["kubernetes", "manifests", "deployment", "production", "security"]
  complexity: "advanced"
  estimated_tokens: 2000
  last_updated: "2025-01-12"
  author: "container-kit"