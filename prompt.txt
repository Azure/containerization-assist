IMPLEMENTATION PROMPT — “Type-safe ports + tiny MCP registration + tool refactor”

You are assisting on a TypeScript MCP server codebase. Apply the following changes in a single PR with focused commits. Keep the style lightweight and idiomatic—no heavy DI containers or factories beyond what already exists. Avoid any as any.

Goals

Introduce tiny ports for Docker (later extendable to K8s/fs), with a minimal adapter.

Remove as any and replace loose typing with precise types (unknown + zod refinement, Result<T>).

Create a small, type-safe MCP registration helper that supports multiple server flavors without any.

Refactor the push-image tool to be tiny, fully typed, and testable by injecting a DockerPort.

Add eslint/tsconfig nudges that keep any out and improve safety.

Constraints & Style

Prefer interfaces + function params over classes; keep files small.

Use unknown at boundaries and refine with zod immediately.

Keep the MCP layer thin (orchestration, progress), push I/O to ports.

Avoid “enterprise DI”—just export small makeXAdapter() factories and pass them in.

Changes to Make (File-by-file)
1) Add a light Result helper

Create: src/types/result.ts

Export Ok<T>, Err<E>, and Result<T, E> with tiny constructors.

2) Narrow MCP types

Create: src/mcp/types.ts

TextContent / Content union (start with only text).

ToolContext (reuse existing shape; keep logger optional).

MCPTool<Schema extends z.ZodTypeAny, Out>: includes metadata.inputSchema: Schema and a typed handler.

MCPResponse<T> union:

success: { content: Content[]; value?: T }

error: { content: Content[]; error: string }

3) Type-safe registration helper (no any)

Create: src/exports/helpers.ts

Implement:

Minimal server surface types: ServerRegisterTool, ServerAddTool, ServerSetTool, ServerMapTools.

Type guards for each (encapsulate as any only inside the guards).

toJsonSchema() converting zod → JSON schema via zod-to-json-schema.

registerTool(server, tool, customName?) and registerAllTools(server, tools, nameMapping?).

Intent: Existing call sites can register tools across different server implementations with strong typing and no public any.

4) Introduce a Docker port and adapter

Create: src/ports/docker.ts

DockerPort with:

pushImage(repository: string, tag: string): Promise<Result<{ digest: string }>>

tagImage(source: string, repo: string, tag: string): Promise<Result<void>>

buildImage(opts: { contextDir: string; dockerfilePath?: string; args?: Record<string,string> }): Promise<Result<{ imageId: string; logs?: string[] }>>

Create: src/lib/docker-adapter.ts

makeDockerAdapter(logger?): DockerPort

Internally call existing createDockerClient and adapt to the Result API, mapping missing errors to friendly strings.

5) Remove as any from container wiring

Edit: src/app/container.ts (or equivalent)

Wherever we call createSDKToolRegistry(logger, null as any, sessionManager), change to pass undefined (or make 2nd param optional).

Update createSDKToolRegistry signature to make the server param optional and branch internally—no as any.

6) Rewrite push-image as a tiny, typed tool

Create: src/tools/push-image/schema.ts

pushImageSchema (zod) with:

sessionId?: string

imageId?: string (repo:tag or id)

registry?: string

credentials?: { username: string; password: string }

Create/Replace: src/tools/push-image/tool.ts

Factory makePushImage(docker: DockerPort): MCPTool<typeof pushImageSchema, PushImageResult>

PushImageResult = { success: true; registry: string; digest: string; pushedTag: string }

Handler:

Parse params using the zod schema’s inferred type.

Determine repo:tag (fall back based on imageId/registry).

Call docker.tagImage (if needed) and docker.pushImage.

Return { content: [{ type: 'text', text: '…' }], value } on success or { content: [{ type: 'text', text: '…' }], error } on failure.

Note: Do not instantiate Docker clients inside the tool. All I/O goes through the injected DockerPort.

7) Wire up adapter in the container

Edit: src/app/container.ts (or wherever tools are composed)

Build a single dockerPort = makeDockerAdapter(logger).

Register makePushImage(dockerPort) with the server via the new registerTool helper.

Tests

Create: tests/tools/push-image.test.ts

Provide a fake DockerPort object (no network/files).

Cases:

Push succeeds → returns digest and message content; no errors.

Tag failure → returns error; no push.

Push failure → returns error after tag success.

Missing imageId → schema should allow but handler should produce descriptive error (or adjust schema if you require it).

Assert content includes at least one { type: 'text' } message and structured value on success.

Lint & TS Config

Edit: .eslintrc.*

Enable:

@typescript-eslint/no-explicit-any: error

@typescript-eslint/no-unsafe-assignment: error

@typescript-eslint/no-unsafe-member-access: error

Add ignore exceptions where needed (but aim for zero).

Edit: tsconfig.json

Consider: "exactOptionalPropertyTypes": true, "noUncheckedIndexedAccess": true.

Acceptance Criteria (must pass before merge)

No remaining as any in the changed files.

push-image does not create Docker clients internally; it only uses DockerPort.

New helper registers tools on our current MCP server impl without compile errors.

Unit tests run in < 2s and pass without Docker installed.

Typecheck & lint pass.

Commit Plan

feat(types): add Result and MCP types (src/types/result.ts, src/mcp/types.ts)

feat(mcp): add type-safe registration helper (src/exports/helpers.ts)

feat(ports): introduce DockerPort + adapter (src/ports/docker.ts, src/lib/docker-adapter.ts)

refactor(container): remove as any from tool registry wiring

refactor(tool): rewrite push-image to use DockerPort and zod-typed params

test(tool): add unit tests for push-image with fake DockerPort

chore(config): tighten eslint and tsconfig rules

Notes to the Assistant

Keep code minimal and idiomatic—prefer functions over classes.

Don’t add frameworks or a DI library.

If any existing imports clash, update imports in all affected files.

Keep existing logger usage; don’t redesign logging.

When done, output:

A brief summary of major changes,

The list of created/updated files,

Test results (or a short guide to run them),

Any TODOs found while integrating.