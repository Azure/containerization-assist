[
  {
    "id": "node-package-cache",
    "category": "dockerfile",
    "pattern": "^COPY\\s+(package\\.json|.*\\*)\\s+",
    "recommendation": "Copy package.json and package-lock.json first, then install dependencies for better Docker layer caching",
    "example": "COPY package*.json ./\nRUN npm ci --only=production\nCOPY . .",
    "severity": "high",
    "tags": ["node", "caching", "optimization", "npm", "yarn", "pnpm"],
    "description": "Proper dependency caching improves build times significantly",
    "rationale": "Dependencies change less frequently than application code, enabling cache reuse",
    "tradeoffs": "Requires careful ordering of COPY instructions",
    "alternatives": ["docker buildkit cache mounts", "layer caching in CI"],
    "metrics": {
      "sizeImpact": "0",
      "buildTimeImpact": "-80%",
      "securityScore": "0"
    }
  },
  {
    "id": "node-npm-ci",
    "category": "dockerfile",
    "pattern": "RUN\\s+npm\\s+install(?!.*--frozen-lockfile)",
    "recommendation": "Use 'npm ci' instead of 'npm install' in production builds for faster, reliable installs",
    "example": "RUN npm ci --only=production && npm cache clean --force",
    "severity": "high",
    "tags": ["node", "npm", "production", "performance", "reproducibility"],
    "description": "npm ci installs directly from package-lock.json and is faster than npm install",
    "rationale": "npm ci ensures reproducible builds and is 2-10x faster than npm install",
    "tradeoffs": "Requires package-lock.json to be present and up-to-date",
    "alternatives": ["yarn install --frozen-lockfile", "pnpm install --frozen-lockfile"],
    "metrics": {
      "sizeImpact": "0",
      "buildTimeImpact": "-50%",
      "securityScore": "+1"
    }
  },
  {
    "id": "node-cache-clean",
    "category": "dockerfile",
    "pattern": "npm (ci|install)",
    "recommendation": "Clean npm cache after installation to reduce image size",
    "example": "RUN npm ci --only=production && npm cache clean --force",
    "severity": "low",
    "tags": ["node", "npm", "cleanup", "size"],
    "description": "npm cache can add significant size to final image"
  },
  {
    "id": "node-health-check",
    "category": "dockerfile",
    "pattern": "^EXPOSE\\s+\\d+(?!.*HEALTHCHECK)",
    "recommendation": "Add health check for Node.js applications",
    "example": "HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1",
    "severity": "high",
    "tags": ["node", "health", "monitoring", "kubernetes", "docker-swarm"],
    "description": "Health checks help container orchestrators manage application lifecycle",
    "rationale": "Enables automatic container restart on failure and proper load balancing",
    "tradeoffs": "Requires health endpoint implementation in application",
    "alternatives": ["TCP checks", "exec health checks", "external monitoring"],
    "metrics": {
      "sizeImpact": "+10KB",
      "buildTimeImpact": "0",
      "securityScore": "+2"
    }
  },
  {
    "id": "node-process-signals",
    "category": "dockerfile",
    "pattern": "CMD.*node",
    "recommendation": "Use proper signal handling for graceful shutdowns in Node.js",
    "example": "CMD [\"node\", \"--enable-source-maps\", \"dist/index.js\"]",
    "severity": "medium",
    "tags": ["node", "signals", "production"],
    "description": "Proper signal handling ensures graceful shutdowns and resource cleanup"
  },
  {
    "id": "node-source-maps",
    "category": "dockerfile",
    "pattern": "node.*\\.js",
    "recommendation": "Enable source maps in production Node.js containers for better debugging",
    "example": "CMD [\"node\", \"--enable-source-maps\", \"dist/index.js\"]",
    "severity": "low",
    "tags": ["node", "debugging", "production"],
    "description": "Source maps help with debugging production issues"
  },
  {
    "id": "node-yarn-cache",
    "category": "dockerfile",
    "pattern": "yarn install",
    "recommendation": "Use yarn install --frozen-lockfile for deterministic builds",
    "example": "COPY yarn.lock package.json ./\nRUN yarn install --frozen-lockfile --production",
    "severity": "medium",
    "tags": ["node", "yarn", "deterministic"],
    "description": "Frozen lockfile prevents unexpected dependency updates"
  },
  {
    "id": "express-port-env",
    "category": "dockerfile",
    "pattern": "EXPOSE 3000",
    "recommendation": "Use environment variable for port configuration in Express apps",
    "example": "ENV PORT=3000\nEXPOSE $PORT",
    "severity": "low",
    "tags": ["express", "configuration", "flexibility"],
    "description": "Environment-based port configuration increases deployment flexibility"
  },
  {
    "id": "node-memory-limit",
    "category": "dockerfile",
    "pattern": "CMD.*node",
    "recommendation": "Set Node.js memory limit to prevent OOM issues in containers",
    "example": "CMD [\"node\", \"--max-old-space-size=512\", \"dist/index.js\"]",
    "severity": "medium",
    "tags": ["node", "memory", "performance"],
    "description": "Setting memory limits prevents out-of-memory crashes in production"
  },
  {
    "id": "typescript-build-stage",
    "category": "dockerfile",
    "pattern": "FROM.*node.*typescript",
    "recommendation": "Use multi-stage builds for TypeScript applications to exclude dev dependencies",
    "example": "FROM node:18-alpine AS build\nRUN npm ci\nRUN npm run build\n\nFROM node:18-alpine AS production\nCOPY --from=build /app/dist ./dist",
    "severity": "medium",
    "tags": ["typescript", "multistage", "production"],
    "description": "Separating build and runtime stages reduces final image size"
  },
  {
    "id": "nestjs-production",
    "category": "dockerfile",
    "pattern": "nest.*build",
    "recommendation": "Optimize NestJS production builds with proper compilation flags",
    "example": "RUN npm run build\nCMD [\"node\", \"dist/main\"]",
    "severity": "medium",
    "tags": ["nestjs", "production", "typescript"],
    "description": "NestJS requires transpilation for production deployment"
  },
  {
    "id": "nextjs-standalone",
    "category": "dockerfile", 
    "pattern": "next.*build",
    "recommendation": "Use Next.js standalone output for optimal container deployment",
    "example": "# In next.config.js: output: 'standalone'\nCOPY --from=deps /app/.next/standalone ./\nCOPY --from=deps /app/.next/static ./.next/static\nCMD [\"node\", \"server.js\"]",
    "severity": "high",
    "tags": ["nextjs", "standalone", "optimization"],
    "description": "Standalone output reduces Next.js container size by 90%"
  },
  {
    "id": "node-security-updates",
    "category": "security",
    "pattern": "FROM node:",
    "recommendation": "Use specific Node.js versions and regularly update for security patches",
    "example": "FROM node:18.17.1-alpine",
    "severity": "high",
    "tags": ["node", "security", "versions"],
    "description": "Specific versions prevent unexpected changes and security vulnerabilities"
  },
  {
    "id": "node-non-root-user",
    "category": "security",
    "pattern": "FROM node:",
    "recommendation": "Node.js official images include 'node' user - use it instead of root",
    "example": "USER node\nWORKDIR /home/node/app",
    "severity": "high",
    "tags": ["node", "security", "user"],
    "description": "Node.js images provide a built-in non-root user"
  },
  {
    "id": "npm-audit-security",
    "category": "security",
    "pattern": "npm (install|ci)",
    "recommendation": "Run npm audit during build to catch security vulnerabilities",
    "example": "RUN npm ci --only=production && npm audit --audit-level high",
    "severity": "medium",
    "tags": ["npm", "security", "audit"],
    "description": "npm audit identifies known security vulnerabilities in dependencies"
  },
  {
    "id": "node-environment-production",
    "category": "dockerfile",
    "pattern": "FROM node:",
    "recommendation": "Set NODE_ENV=production for optimal Node.js performance",
    "example": "ENV NODE_ENV=production",
    "severity": "medium",
    "tags": ["node", "environment", "performance"],
    "description": "Production environment enables optimizations and disables dev features"
  },
  {
    "id": "pnpm-cache-optimization",
    "category": "dockerfile",
    "pattern": "pnpm install",
    "recommendation": "Use pnpm with proper caching for faster builds and smaller images",
    "example": "COPY pnpm-lock.yaml package.json ./\nRUN pnpm install --frozen-lockfile --prod",
    "severity": "medium",
    "tags": ["pnpm", "caching", "performance"],
    "description": "pnpm offers better caching and deduplication than npm"
  },
  {
    "id": "node-graceful-shutdown",
    "category": "dockerfile",
    "pattern": "CMD.*node",
    "recommendation": "Implement graceful shutdown handlers in Node.js applications",
    "example": "# In app code: process.on('SIGTERM', gracefulShutdown)\nCMD [\"node\", \"server.js\"]",
    "severity": "medium",
    "tags": ["node", "signals", "graceful-shutdown"],
    "description": "Graceful shutdowns prevent data loss and connection issues"
  },
  {
    "id": "node-dumb-init",
    "category": "dockerfile",
    "pattern": "CMD.*node",
    "recommendation": "Consider using dumb-init for proper signal handling in containers",
    "example": "RUN apk add --no-cache dumb-init\nENTRYPOINT [\"dumb-init\", \"--\"]\nCMD [\"node\", \"server.js\"]",
    "severity": "low",
    "tags": ["node", "init", "signals"],
    "description": "dumb-init ensures proper signal propagation to Node.js processes"
  },
  {
    "id": "node-logging-stdout",
    "category": "dockerfile",
    "pattern": "FROM node:",
    "recommendation": "Configure Node.js applications to log to stdout for container best practices",
    "example": "# Use console.log/console.error or winston with console transport",
    "severity": "medium",
    "tags": ["node", "logging", "stdout"],
    "description": "Container logs should go to stdout/stderr for proper log aggregation"
  }
]