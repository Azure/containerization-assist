{
  "id": "dockerfile-direct-analysis",
  "category": "containerization",
  "description": "Generate Dockerfile by directly analyzing repository files when automated detection fails",
  "version": "1.0",
  "parameters": [
    {
      "name": "repoPath",
      "type": "string",
      "required": true,
      "description": "Path to repository for analysis"
    },
    {
      "name": "detectedLanguage",
      "type": "string",
      "required": false,
      "description": "Language detected by automated analysis (if any)"
    },
    {
      "name": "moduleRoot",
      "type": "string",
      "required": false,
      "description": "Module root path for multi-module projects"
    },
    {
      "name": "optimization",
      "type": "string",
      "required": false,
      "description": "Optimization focus (performance, security, size, balanced)"
    }
  ],
  "template": "STOP! Do NOT generate a Dockerfile yet. You MUST first explore the repository at {{repoPath}} to understand its structure.\n\n{{#moduleRoot}}This is for module: {{moduleRoot}}\n{{/moduleRoot}}**MANDATORY STEPS IN ORDER:**\n\n1. **STEP 1 - EXPLORE THE REPOSITORY (REQUIRED):**\n   YOU MUST DO THIS FIRST:\n   - Run `ls -la {{repoPath}}` to list ALL files and directories\n   - If you see subdirectories, explore them with `ls -la {{repoPath}}/subdirectory`\n   - Find ALL project files (*.csproj, *.sln, package.json, pom.xml, etc.)\n   - Note the EXACT paths and filenames of all project files\n   - DO NOT PROCEED until you know the exact file structure\n\n2. **STEP 2 - READ THE PROJECT FILES:**\n   After finding the files, read them to understand the project:\n     * JavaScript/Node: package.json, tsconfig.json, .nvmrc\n     * Python: requirements.txt, setup.py, pyproject.toml, Pipfile, .python-version\n     * Java: pom.xml, build.gradle, build.gradle.kts, .java-version\n     * .NET: *.csproj, *.fsproj, *.vbproj, *.sln, global.json, Directory.Build.props, launchSettings.json\n     * Go: go.mod, go.sum\n     * Rust: Cargo.toml, rust-toolchain.toml\n     * PHP: composer.json, .php-version\n     * Ruby: Gemfile, .ruby-version\n   - Look for framework-specific files and configurations\n   - Examine source code structure and patterns\n\n3. **STEP 3 - For .NET projects specifically, analyze:**\n   - The exact TargetFramework or TargetFrameworks in .csproj files (e.g., net6.0, net7.0, net8.0, net472)\n   - Whether it uses Sdk=\"Microsoft.NET.Sdk.Web\" or other SDK types\n   - Package references to determine project type (ASP.NET Core, Blazor, gRPC, Worker Service, etc.)\n   - OutputType to determine if it's an executable or library\n   - Whether it's .NET Framework (Windows-only) or .NET Core/5+ (cross-platform)\n   - Any global.json file that specifies SDK version requirements\n\n4. **STEP 4 - Identify the exact technology stack:**\n   - Programming language and EXACT version requirements (don't assume latest)\n   - Framework being used and its version\n   - Build system and package manager\n   - Runtime dependencies and requirements\n   - Any specific configuration or deployment needs\n   - Development vs production requirements\n\n5. **STEP 5 - ONLY NOW generate a Dockerfile that:**\n   - Uses the CORRECT base image version matching the project requirements (not just latest)\n   - For .NET: Use the exact SDK version for build stage and matching runtime for final stage\n   - Follows best practices for the identified language/framework\n   - Implements multi-stage builds when beneficial for image size\n   - Includes proper security hardening (non-root user, minimal attack surface)\n   - Handles dependencies efficiently with proper layer caching\n   - Sets appropriate WORKDIR, EXPOSE ports, and ENTRYPOINT/CMD\n   {{#optimization}}- Optimizes specifically for {{optimization}}{{/optimization}}\n\n**Critical Instructions:**\n- ALWAYS read the actual project files to determine versions - NEVER assume latest versions\n- ALWAYS verify file paths exist before using COPY commands - use the exact filenames you found\n- For .NET: \n  * Match the exact TargetFramework version with the Docker base image version\n  * Use the actual .csproj filename you found (not a generic name)\n  * If the .csproj is in a subdirectory, adjust WORKDIR and COPY paths accordingly\n- For Java projects: NEVER use javac directly - always use the appropriate build tool (Maven/Gradle)\n- For Node.js: Check for .nvmrc or engines field in package.json for version requirements\n- For Python: Check for .python-version or python_requires in setup.py\n- Copy dependency/configuration files first, install dependencies, then copy source code\n- Use wrapper scripts (mvnw, gradlew) if they exist in the repository\n- Ensure the final Dockerfile can successfully build the application\n\n**Output Format:**\nReturn ONLY the raw Dockerfile content. Do not include:\n- Explanatory text before or after the Dockerfile\n- Markdown code blocks or formatting\n- Comments about your analysis process\n- Installation instructions\n\nStart your response directly with the FROM instruction and end with the last Dockerfile instruction."
}