{
  "id": "dockerfile-direct-analysis",
  "category": "containerization",
  "description": "Generate Dockerfile by directly analyzing repository files when automated detection fails",
  "version": "1.0",
  "parameters": [
    {
      "name": "repoPath",
      "type": "string",
      "required": true,
      "description": "Path to repository for analysis"
    },
    {
      "name": "detectedLanguage",
      "type": "string",
      "required": false,
      "description": "Language detected by automated analysis (if any)"
    },
    {
      "name": "moduleRoot",
      "type": "string",
      "required": false,
      "description": "Module root path for multi-module projects"
    },
    {
      "name": "optimization",
      "type": "string",
      "required": false,
      "description": "Optimization focus (performance, security, size, balanced)"
    },
    {
      "name": "framework",
      "type": "string",
      "required": false,
      "description": "Detected framework (e.g., aspnet-core, spring-boot)"
    },
    {
      "name": "frameworkVersion",
      "type": "string",
      "required": false,
      "description": "Detected framework version"
    },
    {
      "name": "buildSystem",
      "type": "string",
      "required": false,
      "description": "Build system type (maven, gradle, npm, etc.)"
    },
    {
      "name": "buildFile",
      "type": "string",
      "required": false,
      "description": "Build configuration file name"
    },
    {
      "name": "buildCommand",
      "type": "string",
      "required": false,
      "description": "Build command to use"
    },
    {
      "name": "dependencies",
      "type": "string",
      "required": false,
      "description": "Comma-separated list of key dependencies"
    },
    {
      "name": "ports",
      "type": "string",
      "required": false,
      "description": "Comma-separated list of ports to expose"
    }
  ],
  "template": "You are generating a Dockerfile for a repository at: {{repoPath}}\n{{#moduleRoot}}Module path: {{moduleRoot}}{{/moduleRoot}}\n\n**CONTEXT:**\n{{#detectedLanguage}}Language: {{detectedLanguage}}{{/detectedLanguage}}\n{{#framework}}Framework: {{framework}}{{/framework}}\n{{#frameworkVersion}}Framework Version: {{frameworkVersion}}{{/frameworkVersion}}\n{{#buildSystem}}Build System: {{buildSystem}}{{/buildSystem}}\n{{#buildFile}}Build File: {{buildFile}}{{/buildFile}}\n{{#buildCommand}}Build Command: {{buildCommand}}{{/buildCommand}}\n{{#dependencies}}Dependencies: {{dependencies}}{{/dependencies}}\n{{#ports}}Ports: {{ports}}{{/ports}}\n\n**IMPORTANT INSTRUCTIONS:**\n\nGenerate a production-ready Dockerfile based on the repository structure. The repository contains a project that needs to be containerized.\n\n**For .NET Projects (2024 Best Practices):**\n{{#frameworkVersion}}\n- IMPORTANT: Framework version {{frameworkVersion}} detected!\n- If version starts with 4 (like 4.8, 4.7, 4.5), this is .NET Framework - MUST use Windows containers:\n  - Build: mcr.microsoft.com/dotnet/framework/sdk:4.8-windowsservercore-ltsc2022\n  - Runtime: mcr.microsoft.com/dotnet/framework/aspnet:4.8-windowsservercore-ltsc2022\n- If version is 6.0, 7.0, 8.0 or higher, this is .NET Core/.NET - use Linux containers with modern practices:\n  - Build: mcr.microsoft.com/dotnet/sdk:8.0\n  - Runtime: mcr.microsoft.com/dotnet/aspnet:8.0-jammy-chiseled (preferred for security)\n  - Use built-in non-root user: USER $APP_UID\n  - Set environment variables: ASPNETCORE_HTTP_PORTS=8080, ASPNETCORE_URLS=http://+:8080\n  - Performance: DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1, DOTNET_RUNNING_IN_CONTAINER=1\n  - Production: ASPNETCORE_ENVIRONMENT=Production, DOTNET_EnableDiagnostics=0\n  - Expose port 8080 (new .NET 8+ default)\n{{/frameworkVersion}}\n{{^frameworkVersion}}\n- Check the .csproj file for TargetFramework or TargetFrameworkVersion\n- .NET Framework (v4.x) requires Windows containers\n- .NET Core/5+ can use Linux containers with chiseled images\n{{/frameworkVersion}}\n\n**For Java Projects:**\n{{#buildSystem}}\n- Build system: {{buildSystem}}\n{{#buildFile}}- Build file: {{buildFile}}{{/buildFile}}\n{{#buildCommand}}- Build command: {{buildCommand}}{{/buildCommand}}\n- Use appropriate base images: gradle:8-jdk17 or maven:3-amazoncorretto-17 for building\n- Support wrapper scripts (./gradlew, ./mvnw) when available\n- Use multi-stage builds with dependency caching\n{{/buildSystem}}\n\n**For Node.js/TypeScript:**\n- Use node:18-alpine or version from .nvmrc/package.json engines\n- Detect package manager (npm, yarn, pnpm) from lock files\n- Copy package files first for better caching\n\n**For Python:**\n- Use python:3.11-slim or version from .python-version\n- Support requirements.txt, pyproject.toml, Pipfile\n\n**For Go:**\n- Use golang:1.21-alpine for building, alpine for runtime\n- Multi-stage builds with CGO_ENABLED=0\n\n**Best Practices to Follow:**\n1. Use multi-stage builds to minimize final image size\n2. Copy dependency files first, then install dependencies (for layer caching)\n3. Copy source code after dependencies are installed\n4. Add security hardening (non-root user) where appropriate\n5. Set proper WORKDIR, EXPOSE, and CMD/ENTRYPOINT\n6. Use specific version tags, not :latest\n{{#optimization}}\n7. Optimize for: {{optimization}}{{/optimization}}\n{{#ports}}\n8. Expose detected ports: {{ports}}{{/ports}}\n\n**CRITICAL: Analyze the actual project structure and requirements. Generate a Dockerfile that will successfully build and run the application.**\n\n**Output Format:**\nReturn ONLY the raw Dockerfile content. Start directly with FROM and end with the last Dockerfile instruction. Do not include any explanatory text, markdown formatting, or comments about the analysis."
}