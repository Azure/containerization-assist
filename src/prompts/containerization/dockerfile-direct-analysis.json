{
  "id": "dockerfile-direct-analysis",
  "category": "containerization",
  "description": "Generate Dockerfile by directly analyzing repository files when automated detection fails",
  "version": "1.0",
  "parameters": [
    {
      "name": "repoPath",
      "type": "string",
      "required": true,
      "description": "Path to repository for analysis"
    },
    {
      "name": "detectedLanguage",
      "type": "string",
      "required": false,
      "description": "Language detected by automated analysis (if any)"
    },
    {
      "name": "moduleRoot",
      "type": "string",
      "required": false,
      "description": "Module root path for multi-module projects"
    },
    {
      "name": "optimization",
      "type": "string",
      "required": false,
      "description": "Optimization focus (performance, security, size, balanced)"
    }
  ],
  "template": "I need you to analyze the repository at {{repoPath}} and generate an optimized Dockerfile.\n\n{{#moduleRoot}}This is for module: {{moduleRoot}}\n{{/moduleRoot}}Please perform a thorough analysis:\n\n1. **Examine the repository structure and key files:**\n   - Use your file reading tools to explore the directory structure\n   - Read configuration files that indicate the technology stack:\n     * JavaScript/Node: package.json, tsconfig.json, .nvmrc\n     * Python: requirements.txt, setup.py, pyproject.toml, Pipfile, .python-version\n     * Java: pom.xml, build.gradle, build.gradle.kts, .java-version\n     * .NET: *.csproj, *.fsproj, *.vbproj, *.sln, global.json, Directory.Build.props, launchSettings.json\n     * Go: go.mod, go.sum\n     * Rust: Cargo.toml, rust-toolchain.toml\n     * PHP: composer.json, .php-version\n     * Ruby: Gemfile, .ruby-version\n   - Look for framework-specific files and configurations\n   - Examine source code structure and patterns\n\n2. **For .NET projects specifically, analyze:**\n   - The exact TargetFramework or TargetFrameworks in .csproj files (e.g., net6.0, net7.0, net8.0, net472)\n   - Whether it uses Sdk=\"Microsoft.NET.Sdk.Web\" or other SDK types\n   - Package references to determine project type (ASP.NET Core, Blazor, gRPC, Worker Service, etc.)\n   - OutputType to determine if it's an executable or library\n   - Whether it's .NET Framework (Windows-only) or .NET Core/5+ (cross-platform)\n   - Any global.json file that specifies SDK version requirements\n\n3. **Identify the exact technology stack:**\n   - Programming language and EXACT version requirements (don't assume latest)\n   - Framework being used and its version\n   - Build system and package manager\n   - Runtime dependencies and requirements\n   - Any specific configuration or deployment needs\n   - Development vs production requirements\n\n4. **Generate an appropriate Dockerfile that:**\n   - Uses the CORRECT base image version matching the project requirements (not just latest)\n   - For .NET: Use the exact SDK version for build stage and matching runtime for final stage\n   - Follows best practices for the identified language/framework\n   - Implements multi-stage builds when beneficial for image size\n   - Includes proper security hardening (non-root user, minimal attack surface)\n   - Handles dependencies efficiently with proper layer caching\n   - Sets appropriate WORKDIR, EXPOSE ports, and ENTRYPOINT/CMD\n   {{#optimization}}- Optimizes specifically for {{optimization}}{{/optimization}}\n\n**Critical Instructions:**\n- ALWAYS read the actual project files to determine versions - NEVER assume latest versions\n- For .NET: Match the exact TargetFramework version with the Docker base image version\n- For Java projects: NEVER use javac directly - always use the appropriate build tool (Maven/Gradle)\n- For Node.js: Check for .nvmrc or engines field in package.json for version requirements\n- For Python: Check for .python-version or python_requires in setup.py\n- Copy dependency/configuration files first, install dependencies, then copy source code\n- Use wrapper scripts (mvnw, gradlew) if they exist in the repository\n- Ensure the final Dockerfile can successfully build the application\n\n**Output Format:**\nReturn ONLY the raw Dockerfile content. Do not include:\n- Explanatory text before or after the Dockerfile\n- Markdown code blocks or formatting\n- Comments about your analysis process\n- Installation instructions\n\nStart your response directly with the FROM instruction and end with the last Dockerfile instruction."
}