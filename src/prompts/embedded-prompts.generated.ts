/**
 * Embedded prompts for critical functionality
 * Generated at: 2025-09-19T13:59:08.561Z
 * DO NOT EDIT - This file is generated by scripts/generate-prompt-manifest.cjs
 */

// Only critical prompts are embedded to reduce bundle size
const EMBEDDED_PROMPTS: Record<string, string> = {
  'repository-analysis':
    'id: repository-analysis\nversion: \'2.1.0\'\ndescription: Context-aware technology stack detection that adapts to project reality\ncategory: analysis\nformat: json\nparameters:\n  - name: fileList\n    type: string\n    description: List of files in the repository\n    required: true\n  - name: configFiles\n    type: string\n    description: Content of configuration files\n    required: true\n  - name: directoryTree\n    type: string\n    description: Directory structure of the repository\n    required: true\ntemplate: |\n  You are an experienced software architect who understands that every project is unique.\n  Your goal is to understand what this project actually does and how it\'s structured,\n  rather than forcing it into predefined categories.\n\n  Key principles:\n  - Identify the most likely primary technology based on actual evidence\n  - Consider the project\'s apparent purpose and scale\n  - Adapt recommendations to the specific context\n  - Focus on what would actually work for this specific project\n  - Acknowledge uncertainty when evidence is ambiguous\n\n  Analyze this repository to understand its technology stack and provide containerization guidance:\n\n  **File listing:**\n  {{fileList}}\n\n  **Configuration files:**\n  {{configFiles}}\n\n  **Directory structure:**\n  {{directoryTree}}\n\n  Based on the evidence, provide your analysis in JSON format. Include only fields that are\n  clearly determinable from the available information. Use null for uncertain values.\n\n  Focus on:\n  - What technology stack is most likely being used\n  - How the project appears to be built and run\n  - What containerization approach would fit this specific project\n  - Any special considerations based on the project structure\n\n  Return JSON matching this flexible structure:\n  {\n    "analysis_confidence": "high|medium|low",\n    "primary_technology": {\n      "language": "string",\n      "version": "string or null",\n      "ecosystem": "string or null"\n    },\n    "application_type": {\n      "category": "web|cli|library|desktop|service|monorepo|other",\n      "framework": "string or null",\n      "framework_version": "string or null"\n    },\n    "build_approach": {\n      "system": "string or null",\n      "entry_files": ["array of potential entry points"],\n      "build_commands": ["array of likely build commands"],\n      "test_approach": "string or null"\n    },\n    "runtime_characteristics": {\n      "likely_ports": [array of numbers],\n      "dependencies": ["key dependencies that affect containerization"],\n      "special_requirements": ["any unique needs this project might have"]\n    },\n    "containerization_guidance": {\n      "recommended_approach": "string describing the recommended strategy",\n      "base_image_suggestions": ["array of suitable base images"],\n      "considerations": ["array of project-specific considerations"]\n    },\n    "notes": "any important observations or uncertainties"\n  }\n\nexamples:\n  - input:\n      fileList: |\n        package.json\n        server.js\n        routes/index.js\n        public/index.html\n      configFiles: |\n        === package.json ===\n        {\n          "name": "my-app",\n          "version": "1.0.0",\n          "dependencies": {\n            "express": "^4.18.0"\n          },\n          "scripts": {\n            "start": "node server.js"\n          }\n        }\n      directoryTree: |\n        package.json\n        server.js\n        routes/\n          index.js\n        public/\n          index.html\n    output: |\n      {\n        "analysis_confidence": "high",\n        "primary_technology": {\n          "language": "javascript",\n          "version": null,\n          "ecosystem": "node.js"\n        },\n        "application_type": {\n          "category": "web",\n          "framework": "express",\n          "framework_version": "4.18.0"\n        },\n        "build_approach": {\n          "system": "npm",\n          "entry_files": ["server.js"],\n          "build_commands": ["npm install", "npm start"],\n          "test_approach": null\n        },\n        "runtime_characteristics": {\n          "likely_ports": [3000],\n          "dependencies": ["express"],\n          "special_requirements": ["static file serving from public directory"]\n        },\n        "containerization_guidance": {\n          "recommended_approach": "Simple single-stage build suitable for a basic Express app",\n          "base_image_suggestions": ["node:18-slim", "node:20-alpine"],\n          "considerations": ["Consider multi-stage if build process becomes more complex", "Static files in public/ directory need to be included"]\n        },\n        "notes": "Simple Express application with static file serving. Good candidate for straightforward containerization."\n      }\n\ntags:\n  - repository\n  - analysis\n  - adaptive\n  - context-aware',
  'build-image':
    'id: build-image\nversion: \'1.0.0\'\ndescription: AI-guided Docker image building with optimization recommendations\ncategory: containerization\nparameters:\n  - name: dockerfilePath\n    type: string\n    required: true\n    description: Path to the Dockerfile\n  - name: contextPath\n    type: string\n    required: true\n    description: Build context directory path\n  - name: imageName\n    type: string\n    required: true\n    description: Name for the Docker image\n  - name: baseImage\n    type: string\n    required: false\n    description: Base image being used\n  - name: buildArgs\n    type: object\n    required: false\n    description: Build arguments to pass\n  - name: platform\n    type: string\n    required: false\n    description: Target platform (e.g., linux/amd64)\n  - name: sessionAnalysis\n    type: object\n    required: false\n    description: Previous analysis results from session\ntemplate: |\n  Analyze and provide build optimization recommendations for a Docker image build.\n\n  Build Configuration:\n  - Dockerfile: {{dockerfilePath}}\n  - Context Path: {{contextPath}}\n  - Image Name: {{imageName}}\n\n  - Base Image: {{baseImage}}\n\n\n  - Target Platform: {{platform}}\n\n\n  - Build Arguments: {{buildArgs}}\n\n\n\n  Previous Analysis:\n  {{sessionAnalysis}}\n\n\n\n  Relevant Build Patterns:\n  {{knowledge}}\n\n\n\n  Build Policies:\n  {{policy}}\n\n\n  Provide a JSON response with the following structure:\n  ```json\n  {\n    "buildStrategy": {\n      "approach": "string (multi-stage|single-stage|builder-pattern)",\n      "reasoning": "string"\n    },\n    "optimizations": [\n      {\n        "type": "string (cache|layer|size|security)",\n        "recommendation": "string",\n        "impact": "string (high|medium|low)"\n      }\n    ],\n    "cacheStrategy": {\n      "mountCache": boolean,\n      "cacheFrom": ["string"],\n      "inlineCache": boolean\n    },\n    "securityChecks": {\n      "scanBeforePush": boolean,\n      "nonRootUser": boolean,\n      "signImage": boolean\n    },\n    "estimatedSize": "string (e.g., \'150MB\')",\n    "estimatedBuildTime": "string (e.g., \'2-3 minutes\')",\n    "warnings": ["string"],\n    "recommendations": ["string"]\n  }\n  ```\n\n  Focus on practical, actionable recommendations that improve build speed, image size, and security.\nformat: json\n',
  'dockerfile-generation':
    'id: dockerfile-generation\nversion: \'2.0.0\'\ndescription: Generate context-aware Dockerfiles optimized for specific requirements\ncategory: containerization\nformat: json\nparameters:\n  - name: language\n    type: string\n    required: true\n    description: Programming language\n  - name: languageVersion\n    type: string\n    required: false\n    description: Language version (if known)\n  - name: framework\n    type: string\n    required: false\n    description: Framework used\n  - name: frameworkVersion\n    type: string\n    required: false\n    description: Framework version\n  - name: buildSystemType\n    type: string\n    required: true\n    description: Build system or package manager\n  - name: entryPoint\n    type: string\n    required: true\n    description: How the application starts\n  - name: port\n    type: number\n    required: false\n    description: Service port (if applicable)\n  - name: environment\n    type: string\n    required: false\n    default: "production"\n    description: Target environment (development/staging/production)\n  - name: baseImage\n    type: string\n    required: false\n    description: Recommended base image (if specified, MUST be used)\n  - name: requirements\n    type: object\n    required: false\n    description: Specific requirements or features needed\n  - name: constraints\n    type: object\n    required: false\n    description: Limitations or restrictions to consider\n  - name: optimizeFor\n    type: string\n    required: false\n    default: "balanced"\n    description: Primary optimization goal (size/speed/security/compatibility/balanced)\n  - name: repoSummary\n    type: string\n    required: false\n    description: Repository summary for context\n  - name: analysisContext\n    type: object\n    required: false\n    description: Repository analysis results to inform decisions\ntemplate: |\n  You are a Docker containerization expert. Generate production-ready Dockerfiles that balance:\n  - Security best practices\n  - Image size optimization\n  - Build performance\n  - Runtime efficiency\n  - Specific user requirements\n\n  ## DECISION FRAMEWORK:\n\n  ### 1. BASE IMAGE SELECTION TREE:\n  ```\n  What type of application?\n  ├─ Static Binary (Go, Rust) → scratch or distroless\n  ├─ JVM-based → openjdk:*-alpine or eclipse-temurin\n  ├─ Node.js → node:*-alpine (prod) or node:* (dev)\n  ├─ Python → python:*-slim or python:*-alpine\n  ├─ .NET → mcr.microsoft.com/dotnet/aspnet or runtime\n  └─ Other → Evaluate specific ecosystem needs\n  ```\n\n  ### 2. BUILD STRATEGY MATRIX:\n  | Language Type | Build Needed | Recommended Pattern |\n  |--------------|--------------|--------------------|\n  | Compiled     | Always       | Multi-stage build  |\n  | Transpiled   | Yes          | Multi-stage build  |\n  | Interpreted  | Dependencies | Optional multi-stage|\n  | Scripts      | No           | Single stage       |\n\n  ### 3. SECURITY REQUIREMENTS (MANDATORY for production):\n  ✅ ALWAYS create and use non-root user (RUN useradd -m -u 1001 appuser && USER appuser)\n  ✅ ALWAYS use .dockerignore to exclude .git, .env, secrets, etc.\n  ✅ PREFER multi-stage builds to exclude build tools from runtime\n  ✅ PREFER distroless or minimal base images when possible\n  ✅ NEVER include hardcoded secrets or credentials\n  ✅ ALWAYS specify HEALTHCHECK for container orchestration\n\n  ### 4. OPTIMIZATION PRIORITIES:\n  - Layer Caching: Order COPY by change frequency\n  - Size: Remove build deps, clean caches\n  - Speed: Parallel RUN when possible\n  - Security: Scan for vulnerabilities\n\n  ### 5. CONTEXTUAL ADAPTATION:\n  - Production: Security > Size > Speed\n  - Development: Speed > Convenience > Size\n  - CI/CD: Cache efficiency > Build time\n  - Edge/IoT: Size > Everything\n\n  ## Generate Dockerfile for this application:\n\n  **Context:**\n  - Technology: {{language}} {{languageVersion}} with {{framework}} {{frameworkVersion}}\n  - Build System: {{buildSystemType}}\n  - Entry Point: {{entryPoint}}\n  - Environment: {{environment}}\n  {{#port}}\n  - Service Port: {{port}}\n  {{/port}}\n  {{#baseImage}}\n  - **IMPORTANT: You MUST use this base image**: {{baseImage}}\n  {{/baseImage}}\n  {{#requirements}}\n  **Specific Requirements:**\n  {{requirements}}\n  {{/requirements}}\n  {{#constraints}}\n  **Constraints:**\n  {{constraints}}\n  {{/constraints}}\n  {{#optimizeFor}}\n  **Optimize For:** {{optimizeFor}}\n  {{/optimizeFor}}\n  {{#repoSummary}}\n  **Project Summary:** {{repoSummary}}\n  {{/repoSummary}}\n  {{#analysisContext}}\n  **Repository Analysis:** {{analysisContext}}\n  {{/analysisContext}}\n\n  ## Required Analysis Before Generation:\n\n  1. **Technology Stack Assessment:**\n     - Does this require compilation? → Multi-stage needed\n     - Are there native dependencies? → Full base image may be needed\n     - Is this CPU/Memory intensive? → Consider runtime limits\n\n  2. **Security Requirements:**\n     - Is this internet-facing? → Minimal attack surface critical\n     - Handles sensitive data? → Enhanced security measures\n     - Compliance requirements? → Specific base images/scanning\n\n  3. **Operational Context:**\n     - Deployment target (K8s, ECS, etc.) → Platform-specific optimizations\n     - Team expertise level → Balance optimization vs maintainability\n     - Update frequency → Cache strategy importance\n\n  ## Language-Specific Build Patterns:\n\n  ### Java with Maven:\n  **IMPORTANT: Microsoft-First Approach (preferred for security & reduced attack surface):**\n  - Build: `mcr.microsoft.com/openjdk/jdk:21-azurelinux` (or :17-azurelinux, :11-azurelinux)\n  - Runtime: `mcr.microsoft.com/openjdk/jre:21-distroless` (minimal attack surface)\n  - Alternative: `eclipse-temurin:21-jre-alpine` if Microsoft images unavailable\n  - Install Maven/Gradle in build stage for better control\n  - Use Maven wrapper (mvnw) when available\n\n  ```dockerfile\n  # Build stage - Microsoft Azure Linux\n  FROM mcr.microsoft.com/openjdk/jdk:21-azurelinux AS builder\n  WORKDIR /app\n\n  # Install tar and Maven (Gradle: use gradle.org/releases)\n  RUN microdnf install -y tar wget && \\\n      wget -q https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz && \\\n      tar -xzf apache-maven-3.9.6-bin.tar.gz -C /opt && \\\n      rm apache-maven-3.9.6-bin.tar.gz && \\\n      ln -s /opt/apache-maven-3.9.6 /opt/maven\n  ENV PATH=/opt/maven/bin:$PATH\n\n  # Check for Maven wrapper, use if available\n  COPY pom.xml mvnw* ./\n  COPY .mvn .mvn 2>/dev/null || true\n  RUN if [ -f mvnw ]; then chmod +x mvnw && ./mvnw dependency:go-offline -B; \\\n      else mvn dependency:go-offline -B; fi\n\n  COPY src ./src\n  RUN if [ -f mvnw ]; then ./mvnw package -DskipTests; \\\n      else mvn package -DskipTests; fi\n\n  # Runtime stage - Microsoft distroless (minimal attack surface)\n  FROM mcr.microsoft.com/openjdk/jre:21-distroless\n  WORKDIR /app\n  COPY --from=builder /app/target/*.jar app.jar\n  EXPOSE 8080\n  # Note: Distroless doesn\'t have shell, use exec form\n  ENTRYPOINT ["java", "-XX:+UseContainerSupport", "-XX:MaxRAMPercentage=75", "-jar", "app.jar"]\n  ```\n\n  ### Node.js Application:\n  ```dockerfile\n  FROM node:20-alpine AS builder\n  WORKDIR /app\n  COPY package*.json ./\n  RUN npm ci\n  COPY . .\n  RUN npm run build\n\n  FROM node:20-alpine\n  WORKDIR /app\n  RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001\n  COPY package*.json ./\n  RUN npm ci --omit=dev && npm cache clean --force\n  COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist\n  USER nodejs\n  EXPOSE 3000\n  HEALTHCHECK --interval=30s --timeout=3s CMD node healthcheck.js\n  CMD ["node", "dist/server.js"]\n  ```\n\n  ### Python Application:\n  ```dockerfile\n  FROM python:3.11-slim\n  WORKDIR /app\n  RUN apt-get update && apt-get install -y --no-install-recommends \\\n      gcc && rm -rf /var/lib/apt/lists/* && \\\n      useradd -m -u 1001 appuser\n  COPY requirements.txt .\n  RUN pip install --no-cache-dir -r requirements.txt\n  COPY --chown=appuser:appuser . .\n  USER appuser\n  EXPOSE 8000\n  HEALTHCHECK --interval=30s --timeout=3s CMD python healthcheck.py\n  CMD ["uvicorn", "main:app", "--host", "0.0.0.0"]\n  ```\n\n  ### Go Application:\n  ```dockerfile\n  FROM golang:1.21-alpine AS builder\n  WORKDIR /app\n  COPY go.* ./\n  RUN go mod download\n  COPY . .\n  RUN CGO_ENABLED=0 go build -o server\n\n  FROM scratch\n  COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n  COPY --from=builder /etc/passwd /etc/passwd\n  COPY --from=builder --chown=1001:1001 /app/server /server\n  USER 1001\n  EXPOSE 8080\n  ENTRYPOINT ["/server"]\n  ```\n\n  Generate a production-ready Dockerfile that:\n  1. MUST include a non-root user (create with useradd/adduser and switch with USER)\n  2. MUST include HEALTHCHECK when the app has a health endpoint\n  3. MUST use multi-stage build for compiled languages:\n     - Choose appropriate build image based on language/build system\n     - Include proper build commands (mvn package, gradle build, npm run build, etc.)\n     - Use minimal runtime image for final stage\n     - NEVER assume artifacts exist - they must be built in the Dockerfile\n  4. SHOULD order COPY commands for optimal layer caching (dependencies first)\n  5. MUST NOT copy sensitive files (.git, .env, etc.) - assume .dockerignore exists\n\n  Return a JSON object with EXACTLY these three fields:\n  {\n    "content": "# Complete Dockerfile content with all instructions",\n    "metadata": {\n      "baseImage": "image:tag used as base",\n      "runtimeImage": "runtime image if multi-stage",\n      "exposedPorts": [3000],\n      "hasHealthCheck": true,\n      "isMultiStage": false,\n      "optimizationStrategy": "size|security|performance|balanced",\n      "securityLevel": "basic|standard|strict",\n      "estimatedSize": "~50MB"\n    },\n    "recommendations": [\n      "Consider using distroless for production",\n      "Enable BuildKit for faster builds"\n    ]\n  }\n\n  CRITICAL REQUIREMENTS:\n  1. Return ONLY valid JSON, no markdown code blocks, no explanations\n  2. The JSON MUST have exactly three top-level fields: "content", "metadata", "recommendations"\n  3. The "content" field MUST contain the complete Dockerfile as a string\n  4. Include proper line breaks and formatting in the Dockerfile content',
  'fix-dockerfile':
    "id: fix-dockerfile\nversion: '1.0.0'\ndescription: Fix issues in an existing Dockerfile based on analysis and error context\ncategory: containerization\nparameters:\n  - name: dockerfileContent\n    type: string\n    required: true\n    description: Current Dockerfile content to fix\n  - name: errors\n    type: array\n    required: false\n    description: Array of specific errors to address\n  - name: buildError\n    type: string\n    required: false\n    description: Build error message that occurred\n  - name: language\n    type: string\n    required: false\n    description: Programming language of the application\n  - name: framework\n    type: string\n    required: false\n    description: Framework used by the application\n  - name: frameworkVersion\n    type: string\n    required: false\n    description: Version of the framework being used\n  - name: analysis\n    type: string\n    required: false\n    description: Repository analysis context\n  - name: bestPractices\n    type: array\n    required: false\n    description: Knowledge-base best practices recommendations\n  - name: examples\n    type: array\n    required: false\n    description: Relevant code examples from knowledge base\n  - name: securityRecommendations\n    type: array\n    required: false\n    description: Security-specific recommendations from knowledge base\n  - name: knowledgeSuggestions\n    type: array\n    required: false\n    description: Detailed suggestions with reasons from knowledge base\ntemplate: |\n  Fix the provided Dockerfile to resolve build issues and improve best practices.\n\n  Current Dockerfile:\n  {{dockerfileContent}}\n\n\n  Build Error:\n  {{buildError}}\n\n\n\n  Specific Issues to Fix:\n  {{#each errors}}\n  - {{this}}\n  {{/each}}\n\n\n\n  Language: {{language}}\n\n\n\n  Framework: {{framework}}\n\n\n\n  Framework Version: {{frameworkVersion}}\n\n\n\n  Repository Context:\n  {{analysis}}\n\n\n  Best Practices (from knowledge base):\n  {{#.}}- {{.}}\n  {{/.}}\n\n  Relevant Examples:\n  {{#.}}- {{.}}\n  {{/.}}\n\n  Security Recommendations:\n  {{#.}}- {{.}}\n  {{/.}}\n\n  Knowledge-Based Suggestions:\n  {{#.}}- {{recommendation}} ({{reason}})\n  {{/.}}\n\n  Requirements:\n  1. Fix any syntax errors and build failures\n  2. Apply containerization best practices\n  {{#.}}3. {{.}}\n  {{/.}}\n  3. Ensure proper build caching and layer optimization\n  4. Use security best practices (non-root user, minimal packages)\n  {{#.}}   - {{.}}\n  {{/.}}\n  5. Optimize for image size where possible\n  6. Maintain the original functionality and intent\n  {{#.}}7. Consider: {{recommendation}} ({{reason}})\n  {{/.}}\n\n  Return only the corrected Dockerfile content without explanation or code fences.\nformat: text\n",
  'generate-k8s-manifests':
    'id: generate-k8s-manifests\nversion: \'2.0.0\'\ndescription: Generate Kubernetes manifests for containerized applications with adaptive best practices\ncategory: orchestration\nformat: text\nparameters:\n  - name: appName\n    type: string\n    required: true\n    description: Application name for the deployment\n  - name: imageId\n    type: string\n    required: true\n    description: Docker image to deploy\n  - name: namespace\n    type: string\n    required: false\n    default: "default"\n    description: Kubernetes namespace\n  - name: port\n    type: number\n    required: false\n    description: Primary service port\n  - name: replicas\n    type: number\n    required: false\n    default: 3\n    description: Number of replicas to deploy\n  - name: environment\n    type: string\n    required: false\n    default: "production"\n    description: Target environment (development, staging, production)\n  - name: appType\n    type: string\n    required: false\n    description: Application type (web, api, worker, etc.)\n  - name: resources\n    type: object\n    required: false\n    description: Resource limits and requests specification\n  - name: securityLevel\n    type: string\n    required: false\n    default: "standard"\n    description: Security level (basic, standard, strict)\n  - name: highAvailability\n    type: boolean\n    required: false\n    default: false\n    description: Enable high availability features\n  - name: deploymentContext\n    type: string\n    required: false\n    description: Deployment context and environment details\n  - name: requirements\n    type: string\n    required: false\n    description: Specific requirements for the deployment\n  - name: constraints\n    type: string\n    required: false\n    description: Constraints or limitations to consider\n  - name: existingResources\n    type: string\n    required: false\n    description: Existing Kubernetes resources to consider\ntemplate: |\n  You are a Kubernetes deployment expert who creates manifests based on actual requirements.\n\n  ## ADAPTIVE APPROACH:\n  - Start with what\'s needed, not what\'s possible\n  - Add complexity only when justified\n  - Consider the operational context\n  - Balance best practices with practicality\n\n  ## CONTEXTUAL DECISIONS:\n  - Not every app needs HPA (some have predictable load)\n  - Not every app needs strict resource limits (may cause issues)\n  - Not every app can provide health endpoints\n  - Security contexts depend on cluster policies\n  - ConfigMaps/Secrets depend on config complexity\n\n  Generate Kubernetes manifests for this application:\n\n  **Application:**\n  - Name: {{appName}}\n  - Image: {{imageId}}\n  - Namespace: {{namespace}}\n  {{#port}}\n  - Port: {{port}}\n  {{/port}}\n  - Replicas: {{replicas}}\n  - Environment: {{environment}}\n  {{#appType}}\n  - Type: {{appType}}\n  {{/appType}}\n\n  {{#deploymentContext}}\n  **Deployment Context:**\n  {{deploymentContext}}\n  {{/deploymentContext}}\n\n  {{#requirements}}\n  **Specific Requirements:**\n  {{requirements}}\n  {{/requirements}}\n\n  {{#constraints}}\n  **Constraints/Limitations:**\n  {{constraints}}\n  {{/constraints}}\n\n  {{#existingResources}}\n  **Existing Resources to Consider:**\n  {{existingResources}}\n  {{/existingResources}}\n\n  ## Generate Kubernetes manifests that:\n\n  1. **Meet the specific requirements** outlined above\n  2. **Follow security best practices** appropriate for {{securityLevel}} level:\n     - Basic: Non-root user, resource limits\n     - Standard: Security contexts, network policies\n     - Strict: Pod security standards, admission controllers\n  3. **Include appropriate resources** based on application type:\n     - Always: Deployment, Service\n     - Web apps: Ingress (if external access needed)\n     - Stateful apps: StatefulSet instead of Deployment\n     - Background jobs: Job or CronJob\n     - High availability: PodDisruptionBudget, anti-affinity rules\n  4. **Apply environment-specific configurations**:\n     - Development: Relaxed security, easy debugging\n     - Staging: Production-like but with more observability\n     - Production: Security, reliability, monitoring\n\n  ## Resource Templates by Application Type:\n\n  ### Web Application ({{environment}} environment):\n  ```yaml\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: {{appName}}\n    namespace: {{namespace}}\n    labels:\n      app: {{appName}}\n      environment: {{environment}}\n  spec:\n    replicas: {{replicas}}\n    selector:\n      matchLabels:\n        app: {{appName}}\n    template:\n      metadata:\n        labels:\n          app: {{appName}}\n          environment: {{environment}}\n      spec:\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1001\n          fsGroup: 1001\n        containers:\n        - name: {{appName}}\n          image: {{imageId}}\n          ports:\n          - containerPort: {{port}}\n            protocol: TCP\n          resources:\n            requests:\n              memory: "128Mi"\n              cpu: "100m"\n            limits:\n              memory: "512Mi"\n              cpu: "500m"\n          livenessProbe:\n            httpGet:\n              path: /health\n              port: {{port}}\n            initialDelaySeconds: 30\n            periodSeconds: 10\n          readinessProbe:\n            httpGet:\n              path: /ready\n              port: {{port}}\n            initialDelaySeconds: 5\n            periodSeconds: 5\n  ---\n  apiVersion: v1\n  kind: Service\n  metadata:\n    name: {{appName}}-service\n    namespace: {{namespace}}\n    labels:\n      app: {{appName}}\n  spec:\n    selector:\n      app: {{appName}}\n    ports:\n    - port: 80\n      targetPort: {{port}}\n      protocol: TCP\n    type: ClusterIP\n  ```\n\n  ### Background Worker:\n  ```yaml\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: {{appName}}-worker\n    namespace: {{namespace}}\n  spec:\n    replicas: {{replicas}}\n    selector:\n      matchLabels:\n        app: {{appName}}\n        component: worker\n    template:\n      metadata:\n        labels:\n          app: {{appName}}\n          component: worker\n      spec:\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1001\n        containers:\n        - name: worker\n          image: {{imageId}}\n          resources:\n            requests:\n              memory: "256Mi"\n              cpu: "200m"\n            limits:\n              memory: "1Gi"\n              cpu: "1000m"\n  ```\n\n  ## High Availability Features (if enabled):\n\n  ### Pod Disruption Budget:\n  ```yaml\n  apiVersion: policy/v1\n  kind: PodDisruptionBudget\n  metadata:\n    name: {{appName}}-pdb\n    namespace: {{namespace}}\n  spec:\n    minAvailable: 2\n    selector:\n      matchLabels:\n        app: {{appName}}\n  ```\n\n  ### Horizontal Pod Autoscaler:\n  ```yaml\n  apiVersion: autoscaling/v2\n  kind: HorizontalPodAutoscaler\n  metadata:\n    name: {{appName}}-hpa\n    namespace: {{namespace}}\n  spec:\n    scaleTargetRef:\n      apiVersion: apps/v1\n      kind: Deployment\n      name: {{appName}}\n    minReplicas: {{replicas}}\n    maxReplicas: 10\n    metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n  ```\n\n  ## Security Configurations:\n\n  ### Network Policy (for strict security):\n  ```yaml\n  apiVersion: networking.k8s.io/v1\n  kind: NetworkPolicy\n  metadata:\n    name: {{appName}}-netpol\n    namespace: {{namespace}}\n  spec:\n    podSelector:\n      matchLabels:\n        app: {{appName}}\n    policyTypes:\n    - Ingress\n    - Egress\n    ingress:\n    - from:\n      - namespaceSelector:\n          matchLabels:\n            name: ingress-nginx\n      ports:\n      - protocol: TCP\n        port: {{port}}\n    egress:\n    - {}  # Allow all egress (customize as needed)\n  ```\n\n  ## Instructions:\n  1. **Analyze the requirements** and determine which resources are actually needed\n  2. **Choose appropriate resource configurations** based on app type and environment\n  3. **Include security measures** appropriate for the specified security level\n  4. **Add high availability features** only if explicitly requested\n  5. **Customize resource limits** based on application type and requirements\n  6. **Include health checks** only if the application supports them\n  7. **Generate clean, well-commented YAML** that follows Kubernetes best practices\n\n  Generate the manifests as a single YAML document with resources separated by `---`.\n  Include comments explaining key decisions and configurations.',
  'k8s-generation':
    'id: k8s-generation\nversion: \'3.0.0\'\ndescription: Generate Kubernetes manifests tailored to specific application needs\ncategory: orchestration\nformat: yaml\nparameters:\n  - name: image\n    type: string\n    description: Container image reference\n    required: true\n  - name: port\n    type: number\n    description: Application port (if it exposes one)\n    required: false\n  - name: appType\n    type: string\n    description: Type of application (web, api, worker, job, etc.)\n    required: false\n  - name: deploymentContext\n    type: string\n    description: Where/how this will be deployed\n    required: false\n  - name: requirements\n    type: string\n    description: Specific needs or features required\n    required: false\n  - name: constraints\n    type: string\n    description: Limitations or restrictions to work within\n    required: false\n  - name: existingResources\n    type: string\n    description: Existing K8s resources this needs to work with\n    required: false\ntemplate: |\n  You are a Kubernetes deployment expert who creates manifests based on actual requirements.\n\n  ADAPTIVE APPROACH:\n  - Start with what\'s needed, not what\'s possible\n  - Add complexity only when justified\n  - Consider the operational context\n  - Balance best practices with practicality\n\n  CONTEXTUAL DECISIONS:\n  - Not every app needs HPA (some have predictable load)\n  - Not every app needs strict resource limits (may cause issues)\n  - Not every app can provide health endpoints\n  - Security contexts depend on cluster policies\n  - ConfigMaps/Secrets depend on config complexity\n  Generate Kubernetes manifests for this application:\n\n  **Application:**\n  - Image: {{image}}\n  {{#port}}- Port: {{port}}{{/port}}\n  {{#appType}}- Type: {{appType}}{{/appType}}\n\n  {{#deploymentContext}}\n  **Context:**\n  {{deploymentContext}}\n  {{/deploymentContext}}\n\n  {{#requirements}}\n  **Specific Requirements:**\n  {{requirements}}\n  {{/requirements}}\n\n  {{#constraints}}\n  **Constraints/Limitations:**\n  {{constraints}}\n  {{/constraints}}\n\n  {{#existingResources}}\n  **Existing Resources to Consider:**\n  {{existingResources}}\n  {{/existingResources}}\n\n  Generate Kubernetes manifests that:\n  1. Meet the specific requirements\n  2. Work within stated constraints\n  3. Follow appropriate practices for this context\n  4. Include brief comments explaining key decisions\n\nexamples:\n  - input:\n      image: "myapp:v1.2.3"\n      port: "3000"\n      appType: "web api"\n      deploymentContext: "Production cluster with Istio service mesh"\n      requirements: "High availability, gradual rollouts"\n    output: |\n      ---\n      # Deployment with rolling updates and pod disruption budget for HA\n      apiVersion: apps/v1\n      kind: Deployment\n      metadata:\n        name: myapp\n        labels:\n          app: myapp\n          version: v1.2.3\n      spec:\n        replicas: 3  # HA requirement\n        strategy:\n          type: RollingUpdate\n          rollingUpdate:\n            maxSurge: 1\n            maxUnavailable: 0  # Gradual rollout, maintain availability\n        selector:\n          matchLabels:\n            app: myapp\n        template:\n          metadata:\n            labels:\n              app: myapp\n              version: v1.2.3\n          spec:\n            containers:\n            - name: myapp\n              image: myapp:v1.2.3\n              ports:\n              - containerPort: 3000\n                name: http\n              # Basic readiness check, Istio handles advanced routing\n              readinessProbe:\n                httpGet:\n                  path: /\n                  port: 3000\n                initialDelaySeconds: 10\n                periodSeconds: 5\n              resources:\n                requests:\n                  memory: "256Mi"\n                  cpu: "100m"\n                limits:\n                  memory: "512Mi"\n                  cpu: "500m"\n      ---\n      # Service for Istio to discover\n      apiVersion: v1\n      kind: Service\n      metadata:\n        name: myapp\n        labels:\n          app: myapp\n      spec:\n        selector:\n          app: myapp\n        ports:\n        - port: 3000\n          targetPort: 3000\n          name: http  # Named port for Istio\n      ---\n      # PodDisruptionBudget for HA during cluster operations\n      apiVersion: policy/v1\n      kind: PodDisruptionBudget\n      metadata:\n        name: myapp\n      spec:\n        minAvailable: 2  # Always keep 2 pods running\n        selector:\n          matchLabels:\n            app: myapp\n\n  - input:\n      image: "batch-processor:latest"\n      appType: "cronjob"\n      deploymentContext: "Dev cluster for data processing"\n      requirements: "Run every 6 hours, complete within 2 hours"\n    output: |\n      ---\n      # CronJob for periodic batch processing\n      apiVersion: batch/v1\n      kind: CronJob\n      metadata:\n        name: batch-processor\n      spec:\n        schedule: "0 */6 * * *"  # Every 6 hours\n        concurrencyPolicy: Forbid  # Don\'t overlap runs\n        successfulJobsHistoryLimit: 3\n        failedJobsHistoryLimit: 3\n        jobTemplate:\n          spec:\n            activeDeadlineSeconds: 7200  # 2 hour timeout\n            template:\n              spec:\n                restartPolicy: OnFailure\n                containers:\n                - name: processor\n                  image: batch-processor:latest\n                  # No resource limits in dev, let it use what it needs\n                  # No probes needed for batch job\n                  # No service needed - doesn\'t expose ports\ntags:\n  - kubernetes\n  - adaptive\n  - context-aware\n  - manifests',
};

export default EMBEDDED_PROMPTS;

/**
 * Check if a prompt is embedded
 */
export function isEmbedded(id: string): boolean {
  return id in EMBEDDED_PROMPTS;
}

/**
 * Get embedded prompt content
 */
export function getEmbedded(id: string): string | undefined {
  return EMBEDDED_PROMPTS[id];
}

/**
 * Get all embedded prompt IDs
 */
export function getEmbeddedIds(): string[] {
  return Object.keys(EMBEDDED_PROMPTS);
}
