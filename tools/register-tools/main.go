package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	output  = flag.String("output", "pkg/mcp/internal/tools/registry_generated.go", "Output file for generated registration")
	verbose = flag.Bool("verbose", false, "Verbose output")
	dryRun  = flag.Bool("dry-run", false, "Show what would be generated without writing")
)

// ToolInfo represents a discovered tool implementation
type ToolInfo struct {
	Name        string // Struct name (e.g., "BuildImageTool")
	Package     string // Package path (e.g., "pkg/mcp/internal/build")
	PackageName string // Package name (e.g., "build")
	ImportPath  string // Full import path
	ToolName    string // Registration name (e.g., "build_image")
	FilePath    string // Source file path
}

// RegistrationData contains all data needed for code generation
type RegistrationData struct {
	PackageName string
	Imports     []string
	Tools       []ToolInfo
	Timestamp   string
}

const registrationTemplate = `// Code generated by tools/register-tools. DO NOT EDIT.
// Generated at: {{.Timestamp}}

package {{.PackageName}}

import (
	"fmt"
	
	mcptypes "github.com/Azure/container-copilot/pkg/mcp/types"
{{range .Imports}}	"{{.}}"
{{end}}
)

// Auto-generated tool registry
var generatedToolRegistry = map[string]func() mcptypes.Tool{
{{range .Tools}}	"{{.ToolName}}": func() mcptypes.Tool { return &{{if ne .PackageName "tools"}}{{.PackageName}}.{{end}}{{.Name}}{} },
{{end}}
}

// RegisterAllTools registers all discovered tools with the given registry
func RegisterAllTools(registry mcptypes.ToolRegistry) error {
	for name, factory := range generatedToolRegistry {
		tool := factory()
		if err := registry.Register(name, func() mcptypes.Tool { return tool }); err != nil {
			return fmt.Errorf("failed to register tool %s: %w", name, err)
		}
		fmt.Printf("ðŸ”§ Registered tool: %s\n", name)
	}
	return nil
}

// GetAllToolNames returns a list of all registered tool names
func GetAllToolNames() []string {
	names := make([]string, 0, len(generatedToolRegistry))
	for name := range generatedToolRegistry {
		names = append(names, name)
	}
	return names
}

// GetToolCount returns the number of registered tools
func GetToolCount() int {
	return len(generatedToolRegistry)
}
`

func main() {
	flag.Parse()

	fmt.Println("MCP Tool Registration Generator")
	fmt.Println("==============================")

	if *dryRun {
		fmt.Println("ðŸ” DRY RUN MODE - No files will be written")
		fmt.Println()
	}

	// Discover all tool implementations
	fmt.Println("ðŸ” Discovering tool implementations...")
	tools, err := discoverTools()
	if err != nil {
		log.Fatalf("Failed to discover tools: %v", err)
	}

	fmt.Printf("ðŸ“Š Found %d tool implementations\n", len(tools))

	if *verbose {
		for _, tool := range tools {
			fmt.Printf("   - %s (%s)\n", tool.Name, tool.ToolName)
		}
	}

	// Generate registration code
	fmt.Println("ðŸ”§ Generating registration code...")
	code, err := generateRegistrationCode(tools)
	if err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	if *dryRun {
		fmt.Println("ðŸ“„ Generated code preview:")
		fmt.Println(strings.Repeat("=", 50))
		fmt.Println(code)
		fmt.Println(strings.Repeat("=", 50))
		return
	}

	// Write output file
	moduleRoot, err := getModuleRoot()
	if err != nil {
		log.Fatalf("Failed to find module root: %v", err)
	}

	outputPath := *output
	if !filepath.IsAbs(outputPath) {
		outputPath = filepath.Join(moduleRoot, outputPath)
	}

	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	if err := os.WriteFile(outputPath, []byte(code), 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	fmt.Printf("âœ… Generated registration file: %s\n", *output)
	fmt.Printf("ðŸ“ˆ Registered %d tools with zero boilerplate\n", len(tools))
}

func discoverTools() ([]ToolInfo, error) {
	var tools []ToolInfo

	// Get the Go module root directory
	moduleRoot, err := getModuleRoot()
	if err != nil {
		return nil, fmt.Errorf("failed to find module root: %w", err)
	}

	// Search for tool implementations in the MCP internal packages
	searchPaths := []string{
		filepath.Join(moduleRoot, "pkg/mcp/internal/tools"),
		filepath.Join(moduleRoot, "pkg/mcp/internal/build"),     // Build tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/deploy"),    // Deploy tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/scan"),      // Scan tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/analyze"),   // Analyze tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/session"),   // Session management tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/server"),    // Server management tools
		filepath.Join(moduleRoot, "pkg/mcp/internal/conversation"), // Conversation tools
	}

	for _, searchPath := range searchPaths {
		if _, err := os.Stat(searchPath); os.IsNotExist(err) {
			if *verbose {
				fmt.Printf("   Skipping non-existent path: %s\n", searchPath)
			}
			continue
		}

		pathTools, err := discoverToolsInPath(searchPath)
		if err != nil {
			return nil, fmt.Errorf("failed to discover tools in %s: %w", searchPath, err)
		}

		tools = append(tools, pathTools...)
	}

	return tools, nil
}

func discoverToolsInPath(searchPath string) ([]ToolInfo, error) {
	var tools []ToolInfo

	err := filepath.WalkDir(searchPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Skip test files
		if strings.HasSuffix(path, "_test.go") {
			return nil
		}

		fileTools, err := discoverToolsInFile(path)
		if err != nil {
			if *verbose {
				fmt.Printf("   âš ï¸  Failed to parse %s: %v\n", path, err)
			}
			return nil // Continue processing other files
		}

		tools = append(tools, fileTools...)
		return nil
	})

	return tools, err
}

func discoverToolsInFile(filePath string) ([]ToolInfo, error) {
	var tools []ToolInfo

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	// Get module root to calculate relative package path
	moduleRoot, err := getModuleRoot()
	if err != nil {
		return nil, fmt.Errorf("failed to find module root: %w", err)
	}

	// Convert absolute file path to relative package path
	relPath, err := filepath.Rel(moduleRoot, filepath.Dir(filePath))
	if err != nil {
		return nil, fmt.Errorf("failed to get relative path: %w", err)
	}

	packagePath := strings.ReplaceAll(relPath, string(filepath.Separator), "/")
	importPath := "github.com/Azure/container-copilot/" + packagePath

	// Look for struct types that look like tools
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			if _, ok := typeSpec.Type.(*ast.StructType); !ok {
				continue
			}

			structName := typeSpec.Name.Name

			// Check if this looks like a tool (ends with "Tool")
			if strings.HasSuffix(structName, "Tool") {
				// Check if it has the required methods (simplified check)
				if hasToolMethods(file, structName) {
					toolName := convertToToolName(structName)

					// Extract the actual package name from the AST
					actualPackageName := file.Name.Name
					
					tools = append(tools, ToolInfo{
						Name:        structName,
						Package:     packagePath,
						PackageName: actualPackageName,
						ImportPath:  importPath,
						ToolName:    toolName,
						FilePath:    filePath,
					})

					if *verbose {
						fmt.Printf("   ðŸ”§ Found tool: %s -> %s\n", structName, toolName)
					}
				}
			}
		}
	}

	return tools, nil
}

func hasToolMethods(file *ast.File, structName string) bool {
	// For now, just check if it's a struct ending in "Tool"
	// Once Team A completes unified interfaces, we'll enforce proper methods
	// Look for any methods that indicate this is a tool implementation
	requiredMethods := map[string]bool{
		"Execute": false,
		// Relaxed requirements for current state
	}

	for _, decl := range file.Decls {
		funcDecl, ok := decl.(*ast.FuncDecl)
		if !ok || funcDecl.Recv == nil {
			continue
		}

		// Check if this method belongs to our struct
		recvType := getReceiverType(funcDecl.Recv)
		if recvType == structName || recvType == "*"+structName {
			methodName := funcDecl.Name.Name
			if _, required := requiredMethods[methodName]; required {
				requiredMethods[methodName] = true
			}
		}
	}

	// For now, just return true if it's a Tool struct
	// Once Team A completes interfaces, we'll enforce proper method signatures
	return true
}

func getReceiverType(recv *ast.FieldList) string {
	if len(recv.List) == 0 {
		return ""
	}

	field := recv.List[0]
	switch expr := field.Type.(type) {
	case *ast.Ident:
		return expr.Name
	case *ast.StarExpr:
		if ident, ok := expr.X.(*ast.Ident); ok {
			return "*" + ident.Name
		}
	}

	return ""
}

func convertToToolName(structName string) string {
	// Convert CamelCase to snake_case
	// BuildImageTool -> build_image_tool -> build_image
	var result strings.Builder

	for i, r := range structName {
		if i > 0 && 'A' <= r && r <= 'Z' {
			result.WriteByte('_')
		}
		result.WriteRune(r)
	}

	name := strings.ToLower(result.String())

	// Remove "_tool" suffix if present
	name = strings.TrimSuffix(name, "_tool")

	return name
}

func generateRegistrationCode(tools []ToolInfo) (string, error) {
	// Collect unique imports
	importSet := make(map[string]bool)
	for _, tool := range tools {
		if tool.ImportPath != "github.com/Azure/container-copilot/pkg/mcp/internal/tools" {
			importSet[tool.ImportPath] = true
		}
	}

	imports := make([]string, 0, len(importSet))
	for imp := range importSet {
		imports = append(imports, imp)
	}

	// Prepare template data
	data := RegistrationData{
		PackageName: "tools",
		Imports:     imports,
		Tools:       tools,
		Timestamp:   "Auto-generated at build time",
	}

	// Generate code from template
	tmpl, err := template.New("registration").Parse(registrationTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var output strings.Builder
	if err := tmpl.Execute(&output, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return output.String(), nil
}

// getModuleRoot finds the Go module root directory
func getModuleRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	// Walk up the directory tree looking for go.mod
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			// Reached the root directory
			break
		}
		dir = parent
	}

	return "", fmt.Errorf("go.mod not found")
}
