pkg/mcp/validation/chains/composite.go:	).(*CompositeValidator)
pkg/mcp/validation/migration.go:	switch v := oldResult.(type) {
pkg/mcp/validation/migration.go:		if valid, ok := v["valid"].(bool); ok {
pkg/mcp/validation/migration.go:		if errors, ok := v["errors"].([]interface{}); ok {
pkg/mcp/validation/migration.go:				if errMap, ok := errInterface.(map[string]interface{}); ok {
pkg/mcp/validation/migration.go:	if c, ok := errData["code"].(string); ok {
pkg/mcp/validation/migration.go:	if m, ok := errData["message"].(string); ok {
pkg/mcp/validation/migration.go:	if r, ok := errData["rule"].(string); ok {
pkg/mcp/validation/migration.go:	if l, ok := errData["line"].(int); ok {
pkg/mcp/validation/migration.go:	if col, ok := errData["column"].(int); ok {
pkg/mcp/validation/migration.go:	if strictMode, ok := legacy["strict_mode"].(bool); ok {
pkg/mcp/validation/migration.go:	if maxErrors, ok := legacy["max_errors"].(int); ok {
pkg/mcp/validation/migration.go:	if skipFields, ok := legacy["skip_fields"].([]string); ok {
pkg/mcp/validation/migration.go:	if failFast, ok := legacy["fail_fast"].(bool); ok {
pkg/mcp/validation/validators/context.go:		if vt, ok := options.Context["validation_type"].(string); ok {
pkg/mcp/validation/validators/context.go:	contextData, ok := data.(*ContextData)
pkg/mcp/validation/validators/context.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:			if path, ok := m["dockerfile_path"].(string); ok {
pkg/mcp/validation/validators/context.go:			if path, ok := m["context_path"].(string); ok {
pkg/mcp/validation/validators/context.go:			if instructions, ok := m["instructions"].([]interface{}); ok {
pkg/mcp/validation/validators/context.go:					if instMap, ok := inst.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:	files, ok := data.([]string)
pkg/mcp/validation/validators/context.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/context.go:			if f, ok := m["files"].([]string); ok {
pkg/mcp/validation/validators/context.go:		if size, ok := options.Context["context_size_mb"].(float64); ok && size > 100 {
pkg/mcp/validation/validators/context.go:	operations, ok := data.([]map[string]interface{})
pkg/mcp/validation/validators/context.go:		instruction := op["instruction"].(string)
pkg/mcp/validation/validators/context.go:		source := op["source"].(string)
pkg/mcp/validation/validators/context.go:		dest := op["destination"].(string)
pkg/mcp/validation/validators/context.go:		if l, ok := op["line"].(int); ok {
pkg/mcp/validation/validators/context.go:	switch v := data.(type) {
pkg/mcp/validation/validators/context.go:	if v, ok := m[key].(string); ok {
pkg/mcp/validation/validators/context.go:	if v, ok := m[key].(int); ok {
pkg/mcp/validation/validators/context.go:	if v, ok := m[key].(float64); ok {
pkg/mcp/validation/validators/network.go:		if nt, ok := options.Context["network_type"].(string); ok {
pkg/mcp/validation/validators/network.go:	ipStr, ok := data.(string)
pkg/mcp/validation/validators/network.go:		if version, ok := options.Context["ip_version"].(string); ok {
pkg/mcp/validation/validators/network.go:	switch v := data.(type) {
pkg/mcp/validation/validators/network.go:	hostname, ok := data.(string)
pkg/mcp/validation/validators/network.go:	cidrStr, ok := data.(string)
pkg/mcp/validation/validators/network.go:	macStr, ok := data.(string)
pkg/mcp/validation/validators/network.go:	str, ok := data.(string)
pkg/mcp/validation/validators/network.go:		switch data.(type) {
pkg/mcp/validation/validators/kubernetes.go:	switch v := data.(type) {
pkg/mcp/validation/validators/kubernetes.go:	if apiVersion, ok := manifest["apiVersion"].(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if kind, ok := manifest["kind"].(string); ok {
pkg/mcp/validation/validators/kubernetes.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:	if kind, ok := manifest["kind"].(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if spec, ok := manifest["spec"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if nameStr, ok := name.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if namespaceStr, ok := namespace.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if labelsMap, ok := labels.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if annotationsMap, ok := annotations.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if valueStr, ok := value.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if _, ok := value.(string); !ok {
pkg/mcp/validation/validators/kubernetes.go:		if replicasNum, ok := replicas.(int); ok {
pkg/mcp/validation/validators/kubernetes.go:		if selectorMap, ok := selector.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if portsList, ok := ports.([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if portMap, ok := port.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if typeStr, ok := serviceType.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if containersList, ok := containers.([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if imageStr, ok := image.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:		if labelsMap, ok := matchLabels.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if portInt, ok := portNum.(int); ok {
pkg/mcp/validation/validators/kubernetes.go:		if protocolStr, ok := protocol.(string); ok {
pkg/mcp/validation/validators/kubernetes.go:	if kind, ok := manifest["kind"].(string); ok && strings.ToLower(kind) == "pod" {
pkg/mcp/validation/validators/kubernetes.go:		if spec, ok := manifest["spec"].(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:			if containers, ok := spec["containers"].([]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:					if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:		if secCtx, ok := securityContext.(map[string]interface{}); ok {
pkg/mcp/validation/validators/kubernetes.go:				if privBool, ok := privileged.(bool); ok && privBool {
pkg/mcp/validation/validators/kubernetes.go:				if userID, ok := runAsUser.(int); ok && userID == 0 {
pkg/mcp/validation/validators/kubernetes.go:	if kind, ok := manifest["kind"].(string); ok {
pkg/mcp/validation/validators/security_scan.go:	switch v := data.(type) {
pkg/mcp/validation/validators/security_scan.go:		if sessionStr, ok := sessionID.(string); ok {
pkg/mcp/validation/validators/security_scan.go:		if pathStr, ok := scanPath.(string); ok {
pkg/mcp/validation/validators/security_scan.go:		if imageStr, ok := imageName.(string); ok {
pkg/mcp/validation/validators/format.go:		if ft, ok := options.Context["format_type"].(string); ok {
pkg/mcp/validation/validators/format.go:	emailStr, ok := data.(string)
pkg/mcp/validation/validators/format.go:	urlStr, ok := data.(string)
pkg/mcp/validation/validators/format.go:	switch v := data.(type) {
pkg/mcp/validation/validators/format.go:		if syntaxErr, ok := err.(*json.SyntaxError); ok {
pkg/mcp/validation/validators/format.go:	switch v := data.(type) {
pkg/mcp/validation/validators/format.go:	str, ok := data.(string)
pkg/mcp/validation/validators/security.go:		if st, ok := options.Context["security_type"].(string); ok {
pkg/mcp/validation/validators/security.go:	switch v := data.(type) {
pkg/mcp/validation/validators/security.go:	switch v := data.(type) {
pkg/mcp/validation/validators/security.go:	switch v := data.(type) {
pkg/mcp/validation/validators/security.go:		if compliance, ok := options.Context["compliance_standard"].(string); ok {
pkg/mcp/validation/validators/security.go:				if str, ok := value.(string); ok && len(str) > 0 && str != "***" && str != "<redacted>" {
pkg/mcp/validation/validators/security.go:		if nestedMap, ok := value.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:	switch v := data.(type) {
pkg/mcp/validation/validators/health.go:	if namespace, ok := data["namespace"].(string); !ok || namespace == "" {
pkg/mcp/validation/validators/health.go:	if pods, ok := data["pods"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:	if services, ok := data["services"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:	if status, ok := data["health_status"].(string); ok {
pkg/mcp/validation/validators/health.go:		if podMap, ok := pod.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:			if status, ok := podMap["status"].(string); ok {
pkg/mcp/validation/validators/health.go:					if ready, ok := podMap["ready"].(bool); ok && ready {
pkg/mcp/validation/validators/health.go:			if containers, ok := podMap["containers"].([]interface{}); ok {
pkg/mcp/validation/validators/health.go:		if containerMap, ok := container.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:			if restarts, ok := containerMap["restart_count"].(int); ok && restarts > h.thresholds.MaxRestartCount {
pkg/mcp/validation/validators/health.go:		if serviceMap, ok := service.(map[string]interface{}); ok {
pkg/mcp/validation/validators/health.go:			if endpoints, ok := serviceMap["endpoints"].(int); ok && endpoints == 0 {
pkg/mcp/validation/validators/health.go:	healthRatio, _ := metrics["health_ratio"].(float64)
pkg/mcp/validation/validators/health.go:	totalRestarts, _ := metrics["total_restarts"].(int)
pkg/mcp/validation/validators/docker.go:	content, ok := data.(string)
pkg/mcp/validation/validators/docker.go:	imageName, ok := data.(string)
pkg/mcp/validation/validators/image.go:		if vt, ok := options.Context["validation_type"].(string); ok {
pkg/mcp/validation/validators/image.go:	imageRef, ok := data.(string)
pkg/mcp/validation/validators/image.go:	images, ok := data.([]string)
pkg/mcp/validation/validators/image.go:		if m, ok := data.(map[string]interface{}); ok {
pkg/mcp/validation/validators/image.go:			if imgs, ok := m["images"].([]string); ok {
pkg/mcp/validation/validators/image.go:	switch v := data.(type) {
pkg/mcp/validation/validators/image.go:	switch v := data.(type) {
pkg/mcp/validation/validators/image.go:	imageRegex := regexp.MustCompile(`^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]))*(:[0-9]+)?\/)?([a-z0-9]+(?:[._-][a-z0-9]+)*\/)?([a-z0-9]+(?:[._-][a-z0-9]+)*)(?::([\w][\w.-]{0,127}))?(?:@([A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*:[[:xdigit:]]{32,}))?$`)
pkg/mcp/validation/validators/image.go:		if customRegistries, ok := options.Context["trusted_registries"].([]string); ok {
pkg/mcp/validation/validators/image.go:	if v, ok := m[key].(string); ok {
pkg/mcp/validation/validators/image.go:	if v, ok := m[key].(int); ok {
pkg/mcp/validation/validators/image.go:	if v, ok := m[key].(float64); ok {
pkg/mcp/validation/validators/deployment.go:	switch v := data.(type) {
pkg/mcp/validation/validators/deployment.go:		if imageStr, ok := imageRef.(string); ok {
pkg/mcp/validation/validators/deployment.go:		if namespaceStr, ok := namespace.(string); ok {
pkg/mcp/validation/validators/deployment.go:		if appNameStr, ok := appName.(string); ok {
pkg/mcp/validation/validators/deployment.go:	switch v := timeout.(type) {
pkg/mcp/validation/utils/migration_tools.go:		switch x := n.(type) {
pkg/mcp/validation/utils/migration_tools.go:		switch x := n.(type) {
pkg/mcp/validation/utils/migration_tools.go:			if ident, ok := x.Fun.(*ast.Ident); ok {
pkg/mcp/errors/rich/generic.go:	if gErr, ok := err.(*GenericRichError[TContext]); ok {
pkg/mcp/errors/rich/types.go:	if re, ok := target.(*RichError); ok {
pkg/mcp/errors/rich/builder.go:	if re, ok := err.(*RichError); ok {
pkg/mcp/validation/utils/pattern_analysis.go:		if importSpec, ok := n.(*ast.ImportSpec); ok && importSpec.Path != nil {
pkg/mcp/validation/utils/pattern_analysis.go:		switch x := n.(type) {
pkg/mcp/validation/utils/pattern_analysis.go:				switch t := x.Type.(type) {
pkg/mcp/validation/utils/pattern_analysis.go:		switch m := method.Type.(type) {
pkg/mcp/validation/utils/pattern_analysis.go:		switch x := n.(type) {
pkg/mcp/validation/utils/pattern_analysis.go:	switch t := expr.(type) {
pkg/mcp/errors/errors.go:	if mcpErr, ok := target.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/errors/errors.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/context/integration.go:	if sid, ok := contextInfo["session_id"].(string); ok {
pkg/mcp/internal/context/integration.go:	if sessionID, ok := ctx.Value("session_id").(string); ok {
pkg/mcp/internal/context/integration.go:		if buildData, ok := buildCtx.Data["docker_build"].(map[string]interface{}); ok {
pkg/mcp/internal/context/integration.go:			if images, ok := buildData["images_built"].(int); ok && images > 0 {
pkg/mcp/internal/config/manager.go:	switch v := configStruct.(type) {
pkg/mcp/internal/context/enrichers.go:			if buildImages, ok := buildData["docker_build"].(map[string]interface{})["images_built"].(int); ok {
pkg/mcp/internal/context/enrichers.go:				if deployManifests, ok := deployData["kubernetes"].(map[string]interface{})["manifests_count"].(int); ok {
pkg/mcp/internal/context/enrichers.go:		if secData, ok := secContext.Data["security_scans"].(map[string]interface{}); ok {
pkg/mcp/internal/context/enrichers.go:			if critical, ok := secData["critical_issues"].(int); ok && critical > 0 {
pkg/mcp/internal/context/enrichers.go:			if high, ok := secData["high_issues"].(int); ok && high > 0 {
pkg/mcp/internal/context/enrichers.go:		if perfData, ok := perfContext.Data["performance_metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/context/enrichers.go:			if cpu, ok := perfData["cpu_usage"].(float64); ok && cpu > 80 {
pkg/mcp/internal/context/enrichers.go:			if memory, ok := perfData["memory_usage"].(float64); ok && memory > 85 {
pkg/mcp/internal/context/enrichers.go:			if errorRate, ok := perfData["error_rate"].(float64); ok && errorRate > 0.05 {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	if _, ok := operations.(mcptypes.PipelineOperations); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:		if str, ok := v.(string); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:		switch val := v.(type) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator.go:		if b, ok := v.(bool); ok {
pkg/mcp/internal/context/providers.go:	if ss, ok := sessionState.(*session.SessionState); ok {
pkg/mcp/internal/context/providers.go:	if ss, ok := sessionState.(*session.SessionState); ok {
pkg/mcp/internal/context/providers.go:	if ss, ok := sessionState.(*session.SessionState); ok {
pkg/mcp/internal/context/providers.go:	if ss, ok := sessionState.(*session.SessionState); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:		if output, ok := event.Data.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:		if metrics, ok := event.Context["metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:		if str, ok := actual.(string); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:			if substr, ok := expected.(string); ok {
pkg/mcp/internal/orchestration/tool_coordinator.go:	switch v := actual.(type) {
pkg/mcp/internal/orchestration/tool_coordinator.go:	switch v := expected.(type) {
pkg/mcp/types/tools/migration.go:	if typed, ok := data.(TParams); ok {
pkg/mcp/types/tools/migration.go:	if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:	if typed, ok := data.(TResult); ok {
pkg/mcp/types/tools/migration.go:	if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:		if mapData, ok := value.(map[string]interface{}); ok {
pkg/mcp/types/tools/migration.go:	switch v := value.(type) {
pkg/mcp/types/tools/migration.go:	switch v := value.(type) {
pkg/mcp/types/tools/migration.go:	switch v := value.(type) {
pkg/mcp/types/tools/migration.go:	switch v := value.(type) {
pkg/mcp/types/tools/migration.go:	switch v := value.(type) {
pkg/mcp/types/tools/migration.go:		if mapData, ok := data.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/types_test.go:	inputMap, ok := example.Input.(map[string]interface{})
pkg/mcp/internal/orchestration/types_test.go:	outputMap, ok := example.Output.(map[string]interface{})
pkg/mcp/internal/errors/runtime.go:	if toolErr, ok := err.(*ToolError); ok {
pkg/mcp/internal/errors/runtime.go:	if toolErr, ok := err.(*ToolError); ok {
pkg/mcp/internal/orchestration/workflow_templates.go:	if str, ok := value.(string); ok {
pkg/mcp/internal/orchestration/workflow_templates.go:		if actualStr, ok := actual.(string); ok {
pkg/mcp/internal/orchestration/workflow_templates.go:			if expectedStr, ok := expected.(string); ok {
pkg/mcp/internal/orchestration/workflow_templates.go:	switch v := value.(type) {
pkg/mcp/utils/logging.go:		switch v := f.Value.(type) {
pkg/mcp/utils/logging.go:	switch v := field.Value.(type) {
pkg/mcp/types/tools/schema.go:	properties := schema["properties"].(map[string]interface{})
pkg/mcp/types/tools/schema.go:			if schemaMap, ok := fieldSchema.(map[string]interface{}); ok {
pkg/mcp/types/tools/schema.go:	schemaMap, ok := schema.(map[string]interface{})
pkg/mcp/types/tools/schema.go:	schemaMap, ok := schema.(map[string]interface{})
pkg/mcp/types/tools/schema.go:	expectedType, ok := schemaMap["type"].(string)
pkg/mcp/types/tools/schema.go:	switch v.(type) {
pkg/mcp/types/tools/constraints.go:	str, ok := value.(string)
pkg/mcp/types/tools/constraints.go:	switch v := value.(type) {
pkg/mcp/types/tools/constraints.go:	switch v := value.(type) {
pkg/mcp/types/tools/constraints.go:	switch v := value.(type) {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if buildArgs, ok := argsMap["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if vulnTypes, ok := argsMap["vuln_types"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if filePatterns, ok := argsMap["file_patterns"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if excludePatterns, ok := argsMap["exclude_patterns"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if environment, ok := argsMap["environment"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if environment, ok := argsMap["environment"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if buildArgs, ok := argsMap["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if ignoreRules, ok := argsMap["ignore_rules"].([]interface{}); ok {
pkg/mcp/internal/orchestration/no_reflect_orchestrator_impl.go:	if trustedRegistries, ok := argsMap["trusted_registries"].([]interface{}); ok {
pkg/mcp/internal/errors/core_error.go:	if coreErr, ok := target.(*CoreError); ok {
pkg/mcp/internal/errors/core_error.go:	if existingCore, ok := err.(*CoreError); ok {
pkg/mcp/types/mcp_clients_test.go:	if _, ok := clients.Analyzer.(*MockAIAnalyzer); !ok {
pkg/mcp/types/mcp_clients_test.go:	if _, ok := clients.Analyzer.(*stubAnalyzer); !ok {
pkg/mcp/internal/errors/orchestration.go:	if coreErr, ok := err.(*CoreError); ok {
pkg/mcp/internal/errors/orchestration.go:	if toolErr, ok := err.(*ToolError); ok {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		if l, ok := deps[len(deps)-1].(zerolog.Logger); ok {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		if workflowResult, ok := result.(*WorkflowResult); ok {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:		if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/workflow_orchestrator.go:				if artifactList, ok := artifactsData.([]ExecutionArtifact); ok {
pkg/mcp/utils/sanitization_utils.go:	if schemaType, ok := schema["type"].(string); ok && schemaType == "array" {
pkg/mcp/utils/sanitization_utils.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:			if propMap, ok := propSchema.(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:	if items, ok := schema["items"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:	if definitions, ok := schema["definitions"].(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:			if defMap, ok := defSchema.(map[string]interface{}); ok {
pkg/mcp/utils/sanitization_utils.go:	switch v := value.(type) {
pkg/mcp/internal/orchestration/error_router.go:			if count, ok := session.ErrorContext["retry_count"].(int); ok {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok && analyzer != nil {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetFixingMixin(interface{}) }); ok && fixingMixin != nil {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok {
pkg/mcp/internal/orchestration/analyzer_helper.go:	if setter, ok := tool.(interface{ SetAnalyzer(interface{}) }); ok && analyzer != nil {
pkg/mcp/internal/customizer/k8s_ingress.go:	metadataMap, ok := metadata.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_ingress.go:	annotationsMap, ok := existingAnnotations.(map[string]interface{})
pkg/mcp/internal/context/ai_context_aggregator.go:	if workflowList, ok := workflowIDs.([]string); ok {
pkg/mcp/internal/context/ai_context_aggregator.go:	if toolList, ok := toolStateIDs.([]string); ok {
pkg/mcp/internal/context/ai_context_aggregator.go:		if sessionState, ok := ctx.StateSnapshot.SessionState.(*session.SessionState); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if maxAttempts, ok := config["max_attempts"].(int); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if delayMs, ok := config["delay_ms"].(int); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if backoffType, ok := config["backoff_type"].(string); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if backoffMode, ok := config["backoff_mode"].(string); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if initialDelayMs, ok := config["initial_delay_ms"].(int); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if maxDelayMs, ok := config["max_delay_ms"].(int); ok {
pkg/mcp/internal/orchestration/retry_manager.go:	if multiplier, ok := config["multiplier"].(float64); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	coreTool, ok := tool.(core.Tool)
pkg/mcp/internal/orchestration/tool_registry.go:		if properties, ok := schemaMap["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:				if prop, ok := v.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	if schemaType, ok := schema["type"].(string); ok && schemaType == "array" {
pkg/mcp/internal/orchestration/tool_registry.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:			if propSchema, ok := propValue.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	if items, ok := schema["items"].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_registry.go:	if additionalProps, ok := schema["additionalProperties"].(map[string]interface{}); ok {
pkg/mcp/internal/customizer/k8s_helpers.go:		switch curr := current.(type) {
pkg/mcp/internal/customizer/k8s_helpers.go:			keyStr, ok := path[i].(string)
pkg/mcp/internal/customizer/k8s_helpers.go:			keyInt, ok := path[i].(int)
pkg/mcp/internal/customizer/k8s_helpers.go:	switch curr := current.(type) {
pkg/mcp/internal/customizer/k8s_helpers.go:		keyStr, ok := finalKey.(string)
pkg/mcp/internal/customizer/k8s_helpers.go:		keyInt, ok := finalKey.(int)
pkg/mcp/internal/customizer/k8s_helpers.go:	metadataMap, ok := metadata.(map[string]interface{})
pkg/mcp/internal/customizer/k8s_helpers.go:	labelsMap, ok := existingLabels.(map[string]interface{})
pkg/mcp/internal/orchestration/sprint_a_escalation_rules.go:		if sourceStr, ok := source.(string); ok {
pkg/mcp/internal/orchestration/tool_orchestrator.go:		if inputMap, ok := example.Input.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/tool_orchestrator.go:		if outputMap, ok := example.Output.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/template_registry.go:			} else if templateValueStr, ok := templateValue.(string); !ok || templateValueStr != value {
pkg/mcp/internal/orchestration/template_registry.go:			} else if templateValueStr, ok := templateValue.(string); !ok || templateValueStr != value {
pkg/mcp/internal/orchestration/template_registry.go:		if strValue, ok := value.(string); ok {
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(string); !ok {
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(int); !ok {
pkg/mcp/internal/orchestration/template_registry.go:			if _, ok := value.(int64); !ok {
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(float64); !ok {
pkg/mcp/internal/orchestration/template_registry.go:			if _, ok := value.(float32); !ok {
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(bool); !ok {
pkg/mcp/internal/orchestration/template_registry.go:		switch value.(type) {
pkg/mcp/internal/orchestration/template_registry.go:		if _, ok := value.(map[string]interface{}); !ok {
pkg/mcp/internal/orchestration/template_registry.go:	switch v := value.(type) {
pkg/mcp/internal/registry/aws_ecr_provider.go:	ecrPattern := regexp.MustCompile(`^(\d+)\.dkr\.ecr\.([a-z0-9-]+)\.amazonaws\.com`)
pkg/mcp/internal/registry/aws_ecr_provider.go:		if exitErr, ok := err.(*exec.ExitError); ok {
pkg/mcp/internal/registry/azure_cli_provider.go:	re := regexp.MustCompile(`^([^.]+)\.azurecr\.(io|cn|us)`)
pkg/mcp/internal/registry/azure_cli_provider.go:		if exitErr, ok := err.(*exec.ExitError); ok {
pkg/mcp/internal/registry/azure_cli_provider.go:	if accessToken, ok := response["accessToken"].(string); ok {
pkg/mcp/internal/registry/azure_cli_provider.go:	} else if tokenVal, ok := response["token"].(string); ok {
pkg/mcp/internal/registry/validator.go:	if transport, ok := rv.httpClient.Transport.(*http.Transport); ok {
pkg/mcp/internal/conversation/chat_tool.go:	chatArgs, ok := args.(ChatToolArgs)
pkg/mcp/internal/conversation/chat_tool.go:	chatArgs, ok := args.(ChatToolArgs)
pkg/mcp/internal/orchestration/communication_bridge.go:		if payloadStr, ok := message.Payload.(string); ok {
pkg/mcp/internal/scan/validators_unified.go:	typedArgs, ok := args.(AtomicScanSecretsArgs)
pkg/mcp/internal/scan/validators_unified.go:	scanArgs, ok := args.(AtomicScanImageSecurityArgs)
pkg/mcp/internal/session/list_sessions.go:	listArgs, ok := args.(ListSessionsArgs)
pkg/mcp/internal/session/list_sessions.go:	sm, ok := t.sessionManager.(*SessionManager)
pkg/mcp/internal/session/list_sessions.go:	listArgs, ok := args.(ListSessionsArgs)
pkg/mcp/internal/orchestration/checkpoint_manager.go:	if currentSession.Status != WorkflowStatus(lastState["status"].(string)) {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	if currentSession.CurrentStage != lastState["current_stage"].(string) {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	lastCompleted := lastState["completed_stages"].([]interface{})
pkg/mcp/internal/orchestration/checkpoint_manager.go:		lastCompletedStrs[i] = v.(string)
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].(string); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].([]interface{}); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:				if str, ok := v.(string); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:				if str, ok := v.(string); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:		if val, ok := sessionState[key].(string); ok {
pkg/mcp/internal/orchestration/checkpoint_manager.go:	if sharedContext, ok := sessionState["shared_context"].(map[string]interface{}); ok {
pkg/mcp/internal/server/unified_server_test.go:	properties := schema["properties"].(map[string]interface{})
pkg/mcp/internal/server/unified_server_test.go:	required := schema["required"].([]string)
pkg/mcp/internal/session/delete_session.go:	deleteArgs, ok := args.(DeleteSessionArgs)
pkg/mcp/internal/session/delete_session.go:	deleteArgs, ok := args.(DeleteSessionArgs)
pkg/mcp/internal/customizer/k8s_service.go:	specMap, ok := spec.(map[string]interface{})
pkg/mcp/internal/session/analytics.go:		state := sessionData.State.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:	sessionState := sessionInterface.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/analytics_test.go:		sessionState := sessionInterface.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:			if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/analytics_test.go:		sessionState := sessionInterface.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:			if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/analytics_test.go:	sessionState := sessionInterface.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/analytics_test.go:	sessionState := sessionInterface.(*SessionState)
pkg/mcp/internal/session/analytics_test.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/testutil/integration_test_suite.go:			if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/testutil/integration_test_suite.go:					return its.mockPipelineAdapter.AnalyzeRepository("test-session", repoPath.(string))
pkg/mcp/internal/testutil/integration_test_suite.go:			if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/testutil/integration_test_suite.go:					return its.mockPipelineAdapter.BuildDockerImage("test-session", imageName.(string), "/tmp/Dockerfile")
pkg/mcp/internal/server/telemetry.go:	if typed, ok := args.(GetTelemetryMetricsArgs); ok {
pkg/mcp/internal/server/telemetry.go:	if _, ok := args.(GetTelemetryMetricsArgs); !ok {
pkg/mcp/internal/core/server_lifecycle.go:	if setter, ok := s.transport.(interface{ SetHandler(interface{}) }); ok {
pkg/mcp/internal/core/server_lifecycle.go:	if stopper, ok := s.transport.(interface{ Stop(context.Context) error }); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:	if boltStore, ok := sm.store.(*BoltSessionStore); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:			if strValue, ok := value.(string); ok {
pkg/mcp/internal/session/session_manager.go:		if strValue, ok := value.(string); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:					if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:		if session, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/session_manager.go:	if sessionID, ok := ctx.Value("session_id").(string); ok {
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	spec := np["spec"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:		podSelector := spec["podSelector"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadata := np["metadata"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadataLabels := metadata["labels"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadata := np["metadata"].(map[string]interface{})
pkg/mcp/internal/customizer/k8s_networkpolicy.go:	metadataAnnotations := metadata["annotations"].(map[string]interface{})
pkg/mcp/internal/scan/common.go:		summary["by_type"].(map[string]int)[string(secret.Type)]++
pkg/mcp/internal/scan/common.go:		summary["by_severity"].(map[string]int)[string(secret.Severity)]++
pkg/mcp/internal/orchestration/execution_types.go:	if resultMap, ok := toolResult.(map[string]interface{}); ok {
pkg/mcp/internal/orchestration/execution_types.go:			if artifactList, ok := artifacts.([]ExecutionArtifact); ok {
pkg/mcp/internal/orchestration/execution_types.go:			if artifactInterfaces, ok := artifacts.([]interface{}); ok {
pkg/mcp/internal/orchestration/execution_types.go:					if artifact, ok := a.(ExecutionArtifact); ok {
pkg/mcp/internal/orchestration/execution_types.go:		if strValue, ok := value.(string); ok {
pkg/mcp/internal/orchestration/execution_types.go:		if strValue, ok := value.(string); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/scan/scan_secrets_tool.go:	typedArgs, ok := args.(AtomicScanSecretsArgs)
pkg/mcp/internal/scan/scan_secrets_tool.go:	typedArgs, ok := args.(AtomicScanSecretsArgs)
pkg/mcp/internal/scan/secret_scanner.go:			if progressReporter, ok := reporter.(interface {
pkg/mcp/internal/session/manage_session_labels.go:	session, ok := sessionInterface.(*SessionState)
pkg/mcp/internal/session/manage_session_labels.go:	addArgs, ok := args.(AddSessionLabelArgs)
pkg/mcp/internal/session/manage_session_labels.go:	removeArgs, ok := args.(RemoveSessionLabelArgs)
pkg/mcp/internal/session/manage_session_labels.go:	updateArgs, ok := args.(UpdateSessionLabelsArgs)
pkg/mcp/internal/session/manage_session_labels.go:	listArgs, ok := args.(ListSessionLabelsArgs)
pkg/mcp/internal/session/manage_session_labels.go:	addArgs, ok := args.(AddSessionLabelArgs)
pkg/mcp/internal/session/manage_session_labels.go:	removeArgs, ok := args.(RemoveSessionLabelArgs)
pkg/mcp/internal/session/manage_session_labels.go:	updateArgs, ok := args.(UpdateSessionLabelsArgs)
pkg/mcp/internal/session/manage_session_labels.go:	_, ok := args.(ListSessionLabelsArgs)
pkg/mcp/internal/transport/llm_e2e_test.go:			params, ok := req.Params.(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:			toolName, _ := params["name"].(string)
pkg/mcp/internal/transport/llm_e2e_test.go:			args, _ := params["arguments"].(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:				message, _ := args["message"].(string)
pkg/mcp/internal/transport/llm_e2e_test.go:		result := resp["result"].(map[string]interface{})
pkg/mcp/internal/transport/llm_e2e_test.go:		errObj := resp["error"].(map[string]interface{})
pkg/mcp/internal/core/gomcp_handlers.go:	result, ok := resultInterface.(*deploy.AtomicCheckHealthResult)
pkg/mcp/internal/transport/stdio_error_handler.go:	switch typedErr := err.(type) {
pkg/mcp/internal/transport/stdio_error_handler.go:		if errorMap, ok := response["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_handler.go:		if errorMap, ok := response["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_handler.go:	if errorResp, ok := errorResponse["error"].(map[string]interface{}); ok {
pkg/mcp/internal/server/unified_server.go:	message, ok := args["message"].(string)
pkg/mcp/internal/server/unified_server.go:	sessionID, _ := args["session_id"].(string)
pkg/mcp/internal/server/unified_server.go:	if workflowName, ok := args["workflow_name"].(string); ok {
pkg/mcp/internal/server/unified_server.go:		variables, _ := args["variables"].(map[string]string)
pkg/mcp/internal/server/unified_server.go:	if workflowSpec, ok := args["workflow_spec"].(map[string]interface{}); ok {
pkg/mcp/internal/server/unified_server.go:	sessionID, ok := args["session_id"].(string)
pkg/mcp/internal/server/unified_server.go:			properties := schema["properties"].(map[string]interface{})
pkg/mcp/internal/server/unified_server.go:		if strValue, ok := value.(string); ok {
pkg/mcp/internal/server/unified_server.go:	if result, ok := input.(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_mapping_test.go:				result, ok := msg["result"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:				error, ok := msg["error"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:		buildArgs, ok := decoded["build_args"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:				if errorMap, ok := errorResp["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_mapping_test.go:			errorObj, ok := decoded["error"].(map[string]interface{})
pkg/mcp/internal/transport/stdio_mapping_test.go:			if codeFloat, ok := errorObj["code"].(float64); ok {
pkg/mcp/internal/server/get_job_status_test.go:	if statusResult, ok := result.(*GetJobStatusResult); ok {
pkg/mcp/internal/server/get_job_status_test.go:				if statusResult, ok := result.(*GetJobStatusResult); ok {
pkg/mcp/internal/server/registry.go:	if typed, ok := args.(CheckRegistryHealthArgs); ok {
pkg/mcp/internal/server/registry.go:	if _, ok := args.(CheckRegistryHealthArgs); !ok {
pkg/mcp/internal/server/registry.go:	if typed, ok := args.(GetJobStatusArgs); ok {
pkg/mcp/internal/server/registry.go:	if _, ok := args.(GetJobStatusArgs); !ok {
pkg/mcp/internal/server/registry.go:	if typed, ok := args.(GetLogsArgs); ok {
pkg/mcp/internal/server/registry.go:	if _, ok := args.(GetLogsArgs); !ok {
pkg/mcp/internal/scan/scan_image_security_atomic.go:	if a, ok := analyzer.(ToolAnalyzer); ok {
pkg/mcp/internal/scan/scan_image_security_atomic.go:		if scanner, ok := scanResult.Context["scanner"].(string); ok {
pkg/mcp/internal/scan/scan_image_security_atomic.go:	scanArgs, ok := args.(AtomicScanImageSecurityArgs)
pkg/mcp/internal/scan/scan_image_security_atomic.go:	scanArgs, ok := args.(AtomicScanImageSecurityArgs)
pkg/mcp/internal/server/get_logs_test.go:	if logsResult, ok := result.(*GetLogsResult); ok {
pkg/mcp/internal/transport/stdio_helpers.go:		response["error"].(map[string]interface{})["data"] = data
pkg/mcp/internal/transport/stdio_helpers.go:		switch v := value.(type) {
pkg/mcp/internal/transport/stdio_helpers.go:		switch v := value.(type) {
pkg/mcp/internal/transport/stdio_helpers.go:		if v, ok := version.(string); !ok || v != "2.0" {
pkg/mcp/internal/transport/client.go:			if ch, ok := c.pendingReqs[uint64(resp.ID.(float64))]; ok {
pkg/mcp/internal/core/event_bus.go:	if sessionID, ok := data["session_id"].(string); ok {
pkg/mcp/internal/transport/stdio.go:	mgr, ok := s.gomcpManager.(interface{ StartServer() error })
pkg/mcp/internal/transport/stdio.go:	mgr, ok := s.gomcpManager.(interface{ Shutdown(context.Context) error })
pkg/mcp/internal/utils/ring_buffer.go:		if str, ok := value.(string); ok && containsIgnoreCase(str, pattern) {
pkg/mcp/internal/transport/stdio_error_test.go:			if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:				if errorField, ok := resultMap["error"].(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:	if resultMap, ok := result.(map[string]interface{}); ok {
pkg/mcp/internal/transport/stdio_error_test.go:		if errorField, ok := resultMap["error"].(map[string]interface{}); ok {
pkg/mcp/internal/session/label_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/label_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/label_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/label_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/session/label_manager.go:		if state, ok := s.(*SessionState); ok {
pkg/mcp/internal/pipeline/operations.go:	if mcpClients, ok := clients.(*mcptypes.MCPClients); ok {
pkg/mcp/internal/pipeline/operations.go:	if sessionState, ok := session.(*sessionsvc.SessionState); ok {
pkg/mcp/internal/pipeline/operations.go:		sess, ok := s.(*sessionsvc.SessionState)
pkg/mcp/internal/pipeline/operations.go:		if sessionState, ok := s.(*sessionsvc.SessionState); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		if imageRef, ok := argsMap["image_ref"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:			if dockerfilePath, ok := argsMap["dockerfile_path"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		if imageRef, ok := argsMap["image_ref"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		if imageRef, ok := argsMap["image_ref"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		if sourceRef, ok := argsMap["source_ref"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:			if targetRef, ok := argsMap["target_ref"].(string); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		imageRef, _ := argsMap["image_ref"].(string)
pkg/mcp/internal/pipeline/operations.go:		appName, _ := argsMap["app_name"].(string)
pkg/mcp/internal/pipeline/operations.go:		port, _ := argsMap["port"].(int)
pkg/mcp/internal/pipeline/operations.go:		cpuRequest, _ := argsMap["cpu_request"].(string)
pkg/mcp/internal/pipeline/operations.go:		memoryRequest, _ := argsMap["memory_request"].(string)
pkg/mcp/internal/pipeline/operations.go:		cpuLimit, _ := argsMap["cpu_limit"].(string)
pkg/mcp/internal/pipeline/operations.go:		memoryLimit, _ := argsMap["memory_limit"].(string)
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		if manifests, ok := argsMap["manifests"].([]string); ok {
pkg/mcp/internal/pipeline/operations.go:	if argsMap, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/pipeline/operations.go:		namespace, _ := argsMap["namespace"].(string)
pkg/mcp/internal/pipeline/operations.go:		labelSelector, _ := argsMap["label_selector"].(string)
pkg/mcp/internal/pipeline/operations.go:		if timeoutArg, ok := argsMap["timeout"].(time.Duration); ok {
pkg/mcp/internal/utils/mcperror_test.go:	data, ok := err.Data.(map[string]interface{})
pkg/mcp/internal/transport/http.go:	toolHandler, ok := handler.(ToolHandler)
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/mcperror.go:		if data, ok := mcpErr.Data.(map[string]interface{}); ok {
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/mcperror.go:	if mcpErr, ok := err.(*MCPError); ok {
pkg/mcp/internal/utils/validation_standardizer.go:	if sessionWithWorkspace, ok := session.(interface{ GetWorkspaceDir() string }); ok {
pkg/mcp/internal/utils/validation_standardizer.go:		if sessionStruct, ok := session.(*core.SessionState); ok {
pkg/mcp/internal/utils/schema_utils.go:		switch v := value.(type) {
pkg/mcp/internal/utils/schema_utils.go:				if m, ok := elem.(map[string]interface{}); ok {
pkg/mcp/internal/utils/schema_utils.go:		switch child := v.(type) {
pkg/mcp/internal/utils/schema_utils.go:				if m, ok := elem.(map[string]any); ok {
pkg/mcp/internal/pipeline/distributed_operations.go:		imageRef, _ := subOp.Args["image_ref"].(string)
pkg/mcp/internal/pipeline/distributed_operations.go:		imageRef, _ := subOp.Args["image_ref"].(string)
pkg/mcp/internal/pipeline/distributed_operations.go:		sourceRef, _ := subOp.Args["source_ref"].(string)
pkg/mcp/internal/pipeline/distributed_operations.go:		targetRef, _ := subOp.Args["target_ref"].(string)
pkg/mcp/internal/server/core.go:	if setter, ok := s.transport.(interface{ SetHandler(interface{}) }); ok {
pkg/mcp/internal/core/error_handling_test.go:				str, ok := input.(string)
pkg/mcp/internal/core/error_handling_test.go:				num, ok := input.(int)
pkg/mcp/internal/core/error_handling_test.go:				num, ok := input.(int)
pkg/mcp/internal/core/error_handling_test.go:				num, ok := input.(int)
pkg/mcp/internal/pipeline/performance_optimizations.go:		imageRef, _ := args["image_ref"].(string)
pkg/mcp/internal/pipeline/performance_optimizations.go:		imageRef, _ := args["image_ref"].(string)
pkg/mcp/internal/pipeline/performance_optimizations.go:		sourceRef, _ := args["source_ref"].(string)
pkg/mcp/internal/pipeline/performance_optimizations.go:		targetRef, _ := args["target_ref"].(string)
pkg/mcp/internal/pipeline/helpers.go:		if str, ok := value.(string); ok {
pkg/mcp/internal/pipeline/helpers.go:		if i, ok := value.(int); ok {
pkg/mcp/internal/pipeline/helpers.go:		if d, ok := value.(time.Duration); ok {
pkg/mcp/internal/pipeline/helpers.go:		if b, ok := value.(bool); ok {
pkg/mcp/internal/core/server.go:	if setter, ok := transportInstance.(interface{ SetGomcpManager(interface{}) }); ok {
pkg/mcp/internal/core/gomcp_manager.go:			if stopper, ok := gm.transport.(interface{ Stop(context.Context) error }); ok {
pkg/mcp/internal/core/server_lifecycle_test.go:	session1, ok := session1Interface.(*session.SessionState)
pkg/mcp/internal/core/server_lifecycle_test.go:	session2, ok := session2Interface.(*session.SessionState)
pkg/mcp/internal/core/schema_regression_test.go:	resultMap, ok := resp.Result.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:	toolsArray, ok := toolsInterface.([]interface{})
pkg/mcp/internal/core/schema_regression_test.go:		propertiesMap, ok := properties.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:		properties, ok := tool.InputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:			if sessionIDMap, ok := sessionID.(map[string]interface{}); ok {
pkg/mcp/internal/core/schema_regression_test.go:				sessionIDType, ok := sessionIDMap["type"].(string)
pkg/mcp/internal/core/schema_regression_test.go:				_, isMap := properties.(map[string]interface{})
pkg/mcp/internal/core/schema_regression_test.go:		switch v := value.(type) {
pkg/mcp/internal/core/schema_regression_test.go:			if schemaType, ok := v["type"].(string); ok && schemaType == "array" {
pkg/mcp/internal/pipeline/workflow_integration.go:		if session, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/core/request_logger.go:	if requestID, ok := ctx.Value(RequestIDKey{}).(string); ok {
pkg/mcp/internal/core/error_service.go:		if toolErr, ok := record.Error.(*errors.ToolError); ok {
pkg/mcp/internal/core/error_service.go:	if toolErr, ok := err.(*errors.ToolError); ok {
pkg/mcp/internal/core/tool_integration_test.go:				SessionID: tt.input["session_id"].(string),
pkg/mcp/internal/core/tool_integration_test.go:				args.DryRun = dryRun.(bool)
pkg/mcp/internal/core/tool_integration_test.go:				args.BaseImage = baseImage.(string)
pkg/mcp/internal/core/tool_integration_test.go:				args.Template = template.(string)
pkg/mcp/internal/core/tool_integration_test.go:				args.Optimization = optimization.(string)
pkg/mcp/internal/core/tool_integration_test.go:				args.IncludeHealthCheck = includeHealthCheck.(bool)
pkg/mcp/internal/core/tool_integration_test.go:				args.BuildArgs = buildArgs.(map[string]string)
pkg/mcp/internal/core/tool_integration_test.go:				args.Platform = platform.(string)
pkg/mcp/internal/core/conversation_test.go:	adapter, ok := adapterInterface.(interface {
pkg/mcp/internal/core/conversation_test.go:		session, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/core/conversation_test.go:		session, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/pipeline/security_hardening.go:	imageRef, ok := args["image_ref"].(string)
pkg/mcp/internal/pipeline/security_hardening.go:	imageRef, ok := args["image_ref"].(string)
pkg/mcp/internal/pipeline/security_hardening.go:	sourceRef, sourceOk := args["source_ref"].(string)
pkg/mcp/internal/pipeline/security_hardening.go:	targetRef, targetOk := args["target_ref"].(string)
pkg/mcp/internal/core/mcp_server_test.go:		sessionState, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/core/mcp_server_test.go:		retrieved, ok := retrievedInterface.(*session.SessionState)
pkg/mcp/internal/core/mcp_server_test.go:		sessionState, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/core/mcp_server_test.go:			if sess, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/core/mcp_server_test.go:		retrieved, ok := retrievedInterface.(*session.SessionState)
pkg/mcp/internal/core/mcp_server_test.go:		if repoAnalysis, ok := retrieved.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/core/telemetry_service.go:		if exec, ok := event.Data.(ToolExecution); ok {
pkg/mcp/internal/core/telemetry_service.go:		if perf, ok := event.Data.(PerformanceMetric); ok {
pkg/mcp/internal/transport/llm_mock.go:	message, _ := payload["message"].(string) //nolint:errcheck // Will use empty string if not present
pkg/mcp/internal/transport/llm_mock.go:		if fn, ok := funcResp.Metadata["_responseFunc"].(func(*types.PromptEnvelope) *types.LLMResponse); ok {
pkg/mcp/internal/core/gomcp_tools.go:				Docker: deps.MCPClients.Docker.(*docker.DockerCmdRunner),
pkg/mcp/internal/core/gomcp_tools.go:				Kind:   deps.MCPClients.Kind.(*kind.KindCmdRunner),
pkg/mcp/internal/core/gomcp_tools.go:				Kube:   deps.MCPClients.Kube.(*k8s.KubeCmdRunner),
pkg/mcp/internal/core/gomcp_tools.go:		if session, ok := sessionInterface.(*session.SessionState); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if analysisResult, ok := result.(*analyze.AtomicAnalysisResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if dockerfileResult, ok := result.(*analyze.GenerateDockerfileResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if buildResult, ok := result.(*build.AtomicBuildImageResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if pullResult, ok := result.(*build.AtomicPullImageResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if tagResult, ok := result.(*build.AtomicTagImageResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if pushResult, ok := result.(*build.AtomicPushImageResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if validateResult, ok := result.(*deploy.ValidateDeploymentResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if manifestsResult, ok := result.(*deploy.AtomicGenerateManifestsResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if validateResult, ok := result.(*analyze.AtomicValidateDockerfileResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if scanResult, ok := result.(*scan.AtomicScanImageSecurityResult); ok {
pkg/mcp/internal/core/gomcp_tools.go:			if scanResult, ok := result.(*scan.AtomicScanSecretsResult); ok {
pkg/mcp/internal/utils/workspace.go:		if exitError, ok := err.(*exec.ExitError); ok {
pkg/mcp/internal/utils/workspace.go:		if exitError, ok := err.(*exec.ExitError); ok {
pkg/mcp/internal/runtime/auto_registration.go:	if reg, ok := registry.(interface {
pkg/mcp/internal/runtime/validator_test.go:	assert.True(t, result.Context["merged"].(bool))
pkg/mcp/internal/core/server_conversation.go:	if transport, ok := s.transport.(types.LLMTransport); ok {
pkg/mcp/internal/core/server_shutdown_test.go:	session, ok := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/runtime/registry_test.go:	properties, ok := inputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	messageField, ok := properties["message"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	countField, ok := properties["count"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	itemsField, ok := properties["items"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	outputProps, ok := outputSchema["properties"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:	successField, ok := outputProps["success"].(map[string]interface{})
pkg/mcp/internal/runtime/registry_test.go:			testArgs := args.(TestArgs)
pkg/mcp/internal/runtime/registry_test.go:	resultTyped, ok := result.(TestResult)
pkg/mcp/internal/runtime/errors_test.go:	toolResult, ok := result.(*ToolError)
pkg/mcp/internal/runtime/validator.go:		if unifiedValidator, ok := validator.(interface {
pkg/mcp/internal/runtime/validator.go:	if unifiedValidator, ok := validator.(interface {
pkg/mcp/internal/runtime/validator.go:	if unifiedValidator, ok := runtimeValidator.(interface {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:			if state, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:			if state, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler_test.go:		retrieved, ok := retrievedInterface.(*session.SessionState)
pkg/mcp/internal/runtime/conversation/preference_helpers.go:	if val, ok := m[key].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:			if s, ok := v.(string); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:		if values, ok := selectedOption.Value.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:					if opt, ok := v.(string); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:					if healthCheck, ok := v.(bool); ok {
pkg/mcp/internal/runtime/conversation/preference_helpers.go:		if detailedStage, ok := state.Context["detailed_stage"].(string); ok &&
pkg/mcp/internal/runtime/conversation/preference_helpers.go:	if appName, ok := state.Context["app_name"].(string); ok {
pkg/mcp/internal/state/providers.go:	sessionState, ok := state.(*session.SessionState)
pkg/mcp/internal/state/providers.go:		if currentState, ok := current.(*session.SessionState); ok {
pkg/mcp/internal/state/providers.go:		if sessionState, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/state/providers.go:	conversationState, ok := state.(*BasicConversationState)
pkg/mcp/internal/state/providers.go:	workflowSession, ok := state.(WorkflowSessionInterface)
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:	if result, ok := state.Context["preflight_result"].(*observability.PreFlightResult); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if autopilot, ok := state.Context["autopilot_enabled"].(bool); ok && autopilot {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if skipConfirmations, ok := state.Context["skip_confirmations"].(bool); ok && skipConfirmations {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if lastFailed, ok := state.Context["last_failed_check"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:		if existing, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_preflight.go:			if sess, ok := s.(*core.SessionState); ok {
pkg/mcp/internal/state/observers.go:		if userID, ok := event.Metadata["user_id"].(string); ok {
pkg/mcp/internal/state/observers.go:		if sessionID, ok := event.Metadata["session_id"].(string); ok {
pkg/mcp/internal/analyze/additional_coverage_test.go:			if _, ok := analyzer.(*StubAnalyzer); !ok && tt.wantType == "StubAnalyzer" {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if branchStr, ok := branch.(string); ok && branchStr != "" {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if analysis, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:			if suggestions, ok := analysis["suggestions"].([]interface{}); ok && len(suggestions) > 0 {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					if str, ok := s.(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if dockerResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:				if validationData, ok := dockerResult["validation"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					if errors, ok := validationData["errors"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:							if errMap, ok := err.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:					if warnings, ok := validationData["warnings"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:							if warnMap, ok := warn.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if opt, ok := optimization.(string); ok && opt != "" {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if hc, ok := healthCheck.(bool); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if img, ok := baseImage.(string); ok && img != "" {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if opt, ok := optimization.(string); ok && opt != "" {
pkg/mcp/internal/runtime/conversation/prompt_manager_analysis.go:		if skip, ok := skipTree.(bool); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:	internalSession, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if repoAnalysis, ok := internalSession.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:			if ctx, ok := repoAnalysis["_context"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if history, ok := internalSession.Metadata["conversation_history"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:				if turnMap, ok := turnData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:					if stage, ok := turnMap["stage"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:					if ts, ok := turnMap["timestamp"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:					if toolCallsData, ok := turnMap["tool_calls"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:							if tcMap, ok := tcData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:								if params, ok := tcMap["parameters"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:								if duration, ok := tcMap["duration"].(float64); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if stage, ok := internalSession.Metadata["current_stage"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:		if sess, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_core.go:	if userID, ok := ctx.Value("user_id").(string); ok {
pkg/mcp/internal/state/unified_state_manager.go:	if sessionState, ok := state.(*core.SessionState); ok {
pkg/mcp/internal/state/unified_state_manager.go:		if sessionState, ok := current.(*core.SessionState); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if resumedFrom, ok := session.Metadata["resumed_from"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			oldSessionID, _ := resumedFrom["old_session_id"].(string)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			lastRepoURL, _ := resumedFrom["last_repo_url"].(string)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			scanSummary := scanSummaryData.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			if repoPath, ok := scanSummary["repo_path"].(string); ok && repoPath == result.CloneDir {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				if cachedAtStr, ok := scanSummary["cached_at"].(string); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:							Language:     scanSummary["language"].(string),
pkg/mcp/internal/analyze/analyze_repository_atomic.go:							Framework:    scanSummary["framework"].(string),
pkg/mcp/internal/analyze/analyze_repository_atomic.go:							Port:         int(scanSummary["port"].(float64)),
pkg/mcp/internal/analyze/analyze_repository_atomic.go:						if deps, ok := scanSummary["dependencies"].([]interface{}); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:								result.Analysis.Dependencies = append(result.Analysis.Dependencies, analysis.Dependency{Name: dep.(string)})
pkg/mcp/internal/analyze/analyze_repository_atomic.go:			sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:					if repoURL, ok := session.Metadata["repo_url"].(string); ok && repoURL != "" {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				newSessionState := newSessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	switch v := args.(type) {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	switch v := args.(type) {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:	switch v := args.(type) {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if intVal, ok := val.(float64); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if intVal, ok := val.(float64); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if floatVal, ok := val.(float64); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if boolVal, ok := val.(bool); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:		if slice, ok := val.([]interface{}); ok {
pkg/mcp/internal/analyze/analyze_repository_atomic.go:				if str, ok := item.(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_forms_test.go:	optimization, ok := response.Values["optimization"].(string)
pkg/mcp/internal/runtime/conversation/conversation_forms_test.go:	if completed, ok := state.Context["dockerfile_config_completed"].(bool); !ok || !completed {
pkg/mcp/internal/runtime/conversation/conversation_forms_test.go:	if skipped, ok := state.Context["repository_analysis_skipped"].(bool); !ok || !skipped {
pkg/mcp/internal/analyze/analyze_simple.go:	switch a := args.(type) {
pkg/mcp/internal/analyze/analyze_simple.go:	switch a := args.(type) {
pkg/mcp/internal/runtime/registry.go:	if properties, ok := schema["properties"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/registry.go:			if propMap, ok := prop.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_state.go:			if url, ok := cs.SessionState.Metadata["repo_url"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_state.go:			if repoAnalysis, ok := cs.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_state.go:			if built, ok := cs.SessionState.Metadata["image_built"].(bool); ok {
pkg/mcp/internal/runtime/conversation/conversation_state.go:			if ref, ok := cs.SessionState.Metadata["image_ref"].(string); ok {
pkg/mcp/internal/runtime/atomic_tool_base.go:		switch v := value.(type) {
pkg/mcp/internal/state/validators.go:	sessionState, ok := state.(*session.SessionState)
pkg/mcp/internal/state/validators.go:	conversationState, ok := state.(*BasicConversationState)
pkg/mcp/internal/state/validators.go:	workflowSession, ok := state.(WorkflowSessionInterface)
pkg/mcp/internal/state/mappings.go:	sessionState, ok := source.(*session.SessionState)
pkg/mcp/internal/state/mappings.go:	conversationState, ok := target.(*BasicConversationState)
pkg/mcp/internal/state/mappings.go:	workflowSession, ok := source.(WorkflowSessionInterface)
pkg/mcp/internal/state/mappings.go:	sourceMap, ok := source.(map[string]interface{})
pkg/mcp/internal/state/mappings.go:	targetMap, ok := target.(map[string]interface{})
pkg/mcp/internal/deploy/manifest_writer.go:	if opts, ok := data.(GenerationOptions); ok {
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	spec, ok := deployment["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	templateSpec, ok := template["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/generate_manifests_helpers.go:	if existing, ok := templateSpec["imagePullSecrets"].([]interface{}); ok {
pkg/mcp/internal/deploy/generate_manifests_helpers.go:			if secretMap, ok := secret.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:			if sessionState, ok := sessionInterface.(*session.SessionState); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					if repoAnalysis, ok := coreSession.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:						if sessionCtx, ok := repoAnalysis["_context"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:							if autopilotEnabled, exists := sessionCtx["autopilot_enabled"].(bool); exists && autopilotEnabled {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:			if resultMap, ok := lastToolCall.Result.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					failureAnalysis, _ = fa.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	internalSession, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if history, ok := internalSession.Metadata["conversation_history"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if turnMap, ok := turnData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:					if toolCallsData, ok := turnMap["tool_calls"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:							if tcMap, ok := tcData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:								if params, ok := tcMap["parameters"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if imageRef, ok := internalSession.Metadata["image_ref"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if imageName, ok := internalSession.Metadata["image_name"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if manifestPath, ok := internalSession.Metadata["manifest_path"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if imageRef, ok := internalSession.Metadata["image_ref"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:				if resultMap, ok := lastToolCall.Result.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:						failureAnalysisData, _ = fa.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if failureType, ok := failureAnalysisData["failure_type"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if retryRecommended, ok := failureAnalysisData["retry_recommended"].(bool); ok && retryRecommended {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if sess, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:	internalSession, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if imageRef, ok := internalSession.Metadata["image_ref"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if appName, ok := internalSession.Metadata["app_name"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if namespace, ok := internalSession.Metadata["namespace"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if dockerfilePath, ok := internalSession.Metadata["dockerfile_path"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if optimization, ok := internalSession.Metadata["optimization"].(string); ok {
pkg/mcp/internal/runtime/conversation/conversation_handler.go:		if sess, ok := s.(*session.SessionState); ok {
pkg/mcp/internal/analyze/configuration_analyzer.go:		regexp.MustCompile(`process\.env\.([A-Z_][A-Z0-9_]*)`),
pkg/mcp/internal/analyze/configuration_analyzer.go:		regexp.MustCompile(`env\.([A-Z_][A-Z0-9_]*)`),
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if url, ok := state.SessionState.Metadata["repo_url"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if completed, ok := state.Context["repository_analysis_completed"].(bool); ok && completed {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if content, ok := state.SessionState.Metadata["dockerfile_content"].(string); ok {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:		if completed, ok := state.Context["dockerfile_config_completed"].(bool); ok && completed {
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:   ` + "`kubectl port-forward -n " + state.Preferences.Namespace + " svc/" + state.Context["app_name"].(string) + "-service 8080:80`" + `
pkg/mcp/internal/runtime/conversation/prompt_manager_stages.go:   ` + "`kubectl logs -n " + state.Preferences.Namespace + " -l app=" + state.Context["app_name"].(string) + "`" + `
pkg/mcp/internal/runtime/conversation/autopilot_stage.go:	if autopilot, ok := state.Context["autopilot_enabled"].(bool); ok && autopilot {
pkg/mcp/internal/runtime/conversation/autopilot_stage.go:	if skipConfirmations, ok := state.Context["skip_confirmations"].(bool); ok && skipConfirmations {
pkg/mcp/internal/analyze/analyzer_test.go:			if typedAnalyzer, ok := analyzer.(mcptypes.AIAnalyzer); ok {
pkg/mcp/internal/analyze/analyzer_test.go:	callerAnalyzer, ok := analyzer.(*CallerAnalyzer)
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	validateArgs, ok := args.(AtomicValidateDockerfileArgs)
pkg/mcp/internal/analyze/validate_dockerfile_atomic.go:	validateArgs, ok := args.(AtomicValidateDockerfileArgs)
pkg/mcp/internal/deploy/manifest_validator_unified.go:		if totalFiles, ok := metrics["total_files"].(int); ok && totalFiles > 0 {
pkg/mcp/internal/deploy/manifest_validator_unified.go:			if validFiles, ok := metrics["valid_files"].(int); ok {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/rolling.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/retry/fix_providers.go:	dockerfilePath, ok := strategy.Parameters["dockerfile_path"].(string)
pkg/mcp/internal/retry/fix_providers.go:	dockerfilePath, ok := context["dockerfile_path"].(string)
pkg/mcp/internal/retry/fix_providers.go:	suggestedImages := strategy.Parameters["suggested_images"].([]string)
pkg/mcp/internal/retry/fix_providers.go:	alternativePorts := strategy.Parameters["alternative_ports"].([]int)
pkg/mcp/internal/retry/fix_providers.go:	configPath, ok := strategy.Parameters["config_path"].(string)
pkg/mcp/internal/retry/fix_providers.go:	configType, _ := strategy.Parameters["config_type"].(string)
pkg/mcp/internal/retry/fix_providers.go:	configPath, ok := strategy.Parameters["config_path"].(string)
pkg/mcp/internal/retry/fix_providers.go:	command, ok := strategy.Parameters["command"].(string)
pkg/mcp/internal/retry/fix_providers.go:	suggestions, _ := strategy.Parameters["package_suggestions"].([]string)
pkg/mcp/internal/retry/fix_providers.go:	re := regexp.MustCompile(`([^\s]+\.(json|yaml|yml|conf|config))`)
pkg/mcp/internal/retry/error_classifier.go:	if mcpErr, ok := err.(*errors.MCPError); ok {
pkg/mcp/internal/retry/error_classifier.go:	if mcpErr, ok := err.(*errors.MCPError); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:	_, ok := state.Context["build_dry_run_complete"].(bool)
pkg/mcp/internal/runtime/conversation/common_stage.go:	appName, _ := state.Context["app_name"].(string) //nolint:errcheck // Has default
pkg/mcp/internal/runtime/conversation/common_stage.go:	if scanResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:			if k8sManifests, ok := state.SessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:					if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:						if content, ok := manifestMap["content"].(string); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if repoAnalysis, ok := state.SessionState.Metadata["repo_analysis"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:			if projectName, ok := repoAnalysis["project_name"].(string); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if k8sManifests, ok := state.SessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:				if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:					if kind, ok := manifestMap["kind"].(string); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:	if healthResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if logs, ok := healthResult["logs"].(string); ok && logs != "" {
pkg/mcp/internal/runtime/conversation/common_stage.go:	if vulns, ok := scanResult["vulnerabilities"].([]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:			if vuln, ok := v.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/common_stage.go:		if severity, ok := vuln["severity"].(string); ok {
pkg/mcp/internal/analyze/analyze_repository.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository.go:	sessionID, _ := argsMap["session_id"].(string) //nolint:errcheck // Has default
pkg/mcp/internal/analyze/analyze_repository.go:	repoPath, ok := argsMap["repo_path"].(string)
pkg/mcp/internal/analyze/analyze_repository.go:		repoPath, ok = argsMap["path"].(string) // Try alternative field name
pkg/mcp/internal/analyze/analyze_repository.go:	result, ok := resultInterface.(*AtomicAnalysisResult)
pkg/mcp/internal/analyze/analyze_repository.go:	argsMap, ok := args.(map[string]interface{})
pkg/mcp/internal/analyze/analyze_repository.go:	if sessionID, _ := argsMap["session_id"].(string); sessionID == "" {
pkg/mcp/internal/analyze/analyze_repository.go:	if repoPath, ok := argsMap["repo_path"].(string); !ok || repoPath == "" {
pkg/mcp/internal/analyze/analyze_repository.go:		if path, ok := argsMap["path"].(string); !ok || path == "" {
pkg/mcp/internal/analyze/common.go:		summary["by_type"].(map[string]int)[string(finding.Type)]++
pkg/mcp/internal/analyze/common.go:		summary["by_severity"].(map[string]int)[string(finding.Severity)]++
pkg/mcp/internal/deploy/manifest_validator.go:		if metadataMap, ok := metadata.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:		if kindStr, ok := kind.(string); ok {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/manifest_validator.go:				if portsList, ok := ports.([]interface{}); ok && len(portsList) == 0 {
pkg/mcp/internal/deploy/manifest_validator.go:		if specMap, ok := spec.(map[string]interface{}); ok {
pkg/mcp/internal/analyze/analyzer_simple_test.go:	typedAnalyzer, ok := analyzer.(mcptypes.AIAnalyzer)
pkg/mcp/internal/analyze/analyzer_simple_test.go:	typedAnalyzer, ok := analyzer.(mcptypes.AIAnalyzer)
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		if healthMap, ok := healthResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:		if healthMap, ok := healthResult.(map[string]interface{}); ok && !getBoolFromMap(healthMap, "healthy", false) {
pkg/mcp/internal/deploy/deploy_kubernetes_validate.go:	deployArgs, ok := args.(AtomicDeployKubernetesArgs)
pkg/mcp/internal/build/build_image.go:		if analysis, ok := repoAnalysis.(*analysis.AnalysisResult); ok {
pkg/mcp/internal/build/build_image.go:	switch a := args.(type) {
pkg/mcp/internal/analyze/template_selector.go:	if lang, ok := repoAnalysis["primary_language"].(string); ok {
pkg/mcp/internal/analyze/template_selector.go:	if fw, ok := repoAnalysis["framework"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, ok := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, _ := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:	workDir, _ := session["work_dir"].(string)
pkg/mcp/internal/analyze/generate_dockerfile.go:	repoAnalysis, _ := session["repository_analysis"].(map[string]interface{})
pkg/mcp/internal/analyze/generate_dockerfile.go:	if lang, ok := repositoryData["primary_language"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if fw, ok := repositoryData["framework"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if depMap, ok := repositoryData["dependencies"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if fileList, ok := repositoryData["config_files"].([]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:			if file, ok := f.(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if lang, ok := repoAnalysis["primary_language"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if fw, ok := repoAnalysis["framework"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	typedArgs, ok := args.(GenerateDockerfileArgs)
pkg/mcp/internal/analyze/generate_dockerfile.go:		if mapArgs, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	typedArgs, ok := args.(GenerateDockerfileArgs)
pkg/mcp/internal/analyze/generate_dockerfile.go:		if mapArgs, ok := args.(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["session_id"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["base_image"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["template"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["optimization"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["include_health_check"].(bool); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["platform"].(string); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["dry_run"].(bool); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:	if v, ok := args["build_args"].(map[string]interface{}); ok {
pkg/mcp/internal/analyze/generate_dockerfile.go:			if strVal, ok := val.(string); ok {
pkg/mcp/internal/retry/coordinator.go:	if mcpErr, ok := err.(*errors.MCPError); ok {
pkg/mcp/internal/retry/coordinator.go:	result := rc.attemptPool.Get().(*AttemptResult)
pkg/mcp/internal/analyze/dependency_analyzer.go:			if dep, ok := finding.Metadata["dependency"].(string); ok {
pkg/mcp/internal/analyze/dependency_analyzer.go:			if manager, ok := finding.Metadata["manager"].(string); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:	if deployMap, ok := deployResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if newContent, ok := change["NewContent"].(string); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_apply.go:		if newContent, ok := change["NewContent"].(string); ok {
pkg/mcp/internal/build/context_sharer.go:		if toolContext, ok := toolData.(map[string]interface{}); ok {
pkg/mcp/internal/build/context_sharer.go:		if name, ok := toolName.(string); ok {
pkg/mcp/internal/build/context_sharer.go:		if name, ok := opName.(string); ok {
pkg/mcp/internal/build/context_sharer.go:		if name, ok := mcpTool.(string); ok {
pkg/mcp/internal/build/cross_tool_knowledge_base.go:		stats["total_insights"] = stats["total_insights"].(int) + len(insights)
pkg/mcp/internal/build/cross_tool_knowledge_base.go:		stats["total_patterns"] = stats["total_patterns"].(int) + len(patterns)
pkg/mcp/internal/observability/integration.go:	if sessionWithID, ok := session.(interface{ GetSessionID() string }); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	if built, ok := sessionState.Metadata["dockerfile_built"].(bool); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	if imageID, ok := sessionState.Metadata["dockerfile_image_id"].(string); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	if imageID, ok := sessionState.Metadata["image_id"].(string); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	if registry, ok := sessionState.Metadata["image_registry"].(string); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	if tag, ok := sessionState.Metadata["image_tag"].(string); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		details, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:		details, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:	registry, ok := state.Context["preferred_registry"].(string)
pkg/mcp/internal/runtime/conversation/build_stage.go:	registry, _ := state.Context["preferred_registry"].(string) //nolint:errcheck // Already validated above
pkg/mcp/internal/runtime/conversation/build_stage.go:		if resultMap, ok := dryResult.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:				dryResultMap, _ = resultField.(map[string]interface{})
pkg/mcp/internal/runtime/conversation/build_stage.go:			if success, ok := dryResultMap["success"].(bool); ok && !success {
pkg/mcp/internal/runtime/conversation/build_stage.go:				if errStr, ok := dryResultMap["error"].(string); ok {
pkg/mcp/internal/runtime/conversation/build_stage.go:	resultMap, _ := result.(map[string]interface{})
pkg/mcp/internal/observability/system_validator.go:		if exitErr, ok := err.(*exec.ExitError); ok {
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:			mockArgs := args.(*MockToolArgs)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:			mockArgs := args.(*MockToolArgs)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:	mockArgs, ok := args.(*MockToolArgs)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:	mockArgs, ok := args.(*MockToolArgs)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:			dryRunResult, ok := dryRunResp.(*MockToolResponse)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:			actualResult, ok := actualResp.(*MockToolResponse)
pkg/mcp/internal/tools/dry_run_comprehensive_test.go:	result, ok := resp.(*MockToolResponse)
pkg/mcp/internal/deploy/validator.go:	if docKind, ok := doc["kind"].(string); !ok || docKind != kind {
pkg/mcp/internal/deploy/validator.go:	metadata, ok := doc["metadata"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if name, ok := metadata["name"].(string); ok {
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if replicas, ok := spec["replicas"].(int); ok && replicas < 0 {
pkg/mcp/internal/deploy/validator.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:		containers, ok := templateSpec["containers"].([]interface{})
pkg/mcp/internal/deploy/validator.go:	cont, ok := container.(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	ports, ok := spec["ports"].([]interface{})
pkg/mcp/internal/deploy/validator.go:	p, ok := port.(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if portNum, ok := p["port"].(int); !ok || portNum < 1 || portNum > 65535 {
pkg/mcp/internal/deploy/validator.go:	if targetPort, ok := p["targetPort"].(int); ok && (targetPort < 1 || targetPort > 65535) {
pkg/mcp/internal/deploy/validator.go:	secretType, ok := doc["type"].(string)
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	rules, ok := spec["rules"].([]interface{})
pkg/mcp/internal/deploy/validator.go:	spec, ok := doc["spec"].(map[string]interface{})
pkg/mcp/internal/deploy/validator.go:	if metadata, ok := doc["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:	if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:		if replicas, ok := spec["replicas"].(int); ok && replicas == 1 {
pkg/mcp/internal/deploy/validator.go:		if template, ok := spec["template"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:			if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:				if containers, ok := templateSpec["containers"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:						if cont, ok := container.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:	if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:		if serviceType, ok := spec["type"].(string); ok && serviceType == "LoadBalancer" {
pkg/mcp/internal/deploy/validator.go:			if spec, ok := doc["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:				if template, ok := spec["template"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:					if templateSpec, ok := template["spec"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:						if containers, ok := templateSpec["containers"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator.go:								if cont, ok := container.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if manifests, ok := sessionState.Metadata["k8s_manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if pushed, ok := sessionState.Metadata["dockerfile_pushed"].(bool); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	k8sManifests := sessionState.Metadata["k8s_manifests"].(map[string]interface{})
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		if manifestMap, ok := manifestData.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:			if content, ok := manifestMap["content"].(string); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:			if kind, ok := manifestMap["kind"].(string); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:			if applied, ok := manifestMap["applied"].(bool); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:			if status, ok := manifestMap["status"].(string); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	appName, _ := state.Context["app_name"].(string) //nolint:errcheck // Will prompt if empty
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if envVars, ok := state.Context["environment_vars"].(map[string]string); ok && len(envVars) > 0 {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if resultData, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:		if manifests, ok := resultData["manifests"].(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:				contentStr, ok := content.(string)
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if toolResult, ok := resultStruct.(map[string]interface{}); ok {
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	waitForReady, _ := state.Context["wait_for_ready"].(bool)   //nolint:errcheck // Defaults to true
pkg/mcp/internal/runtime/conversation/deploy_stage.go:	if count, ok := state.Context["deployment_retry_count"].(int); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:	if aiAnalyzer, ok := analyzer.(core.AIAnalyzer); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/deploy/deploy_kubernetes_atomic.go:	deployArgs, ok := args.(AtomicDeployKubernetesArgs)
pkg/mcp/internal/analyze/language_analyzer.go:			if lang, ok := finding.Metadata["language"].(string); ok {
pkg/mcp/internal/analyze/language_analyzer.go:				if percent, ok := finding.Metadata["percentage"].(float64); ok {
pkg/mcp/internal/analyze/language_analyzer.go:			if framework, ok := finding.Metadata["framework"].(string); ok {
pkg/mcp/internal/analyze/language_analyzer.go:			if runtime, ok := finding.Metadata["runtime"].(string); ok {
pkg/mcp/internal/deploy/health_checker.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/deploy/health_checker.go:		kubernetesHealthResult = hc.convertHealthCheckResult(healthResult.(map[string]interface{}), namespace)
pkg/mcp/internal/deploy/health_checker.go:				kubernetesResult := hc.convertHealthCheckResult(healthResult.(map[string]interface{}), namespace)
pkg/mcp/internal/deploy/health_checker.go:	if appName, ok := session.Metadata["app_name"].(string); ok && appName != "" {
pkg/mcp/internal/deploy/health_checker.go:	if overall, ok := result["success"].(bool); ok {
pkg/mcp/internal/deploy/health_checker.go:	if summaryData, ok := result["summary"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:		if totalPods, ok := summaryData["total_pods"].(float64); ok {
pkg/mcp/internal/deploy/health_checker.go:		if readyPods, ok := summaryData["ready_pods"].(float64); ok {
pkg/mcp/internal/deploy/health_checker.go:		if failedPods, ok := summaryData["failed_pods"].(float64); ok {
pkg/mcp/internal/deploy/health_checker.go:		if healthyRatio, ok := summaryData["healthy_ratio"].(float64); ok {
pkg/mcp/internal/deploy/health_checker.go:	if pods, ok := result["pod_statuses"].([]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:			if podMap, ok := podInterface.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:	if services, ok := result["service_statuses"].([]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:			if serviceMap, ok := serviceInterface.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/health_checker.go:		if str, ok := val.(string); ok {
pkg/mcp/internal/deploy/health_checker.go:		if b, ok := val.(bool); ok {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/blue_green.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:			if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/deploy/recreate.go:		if reporter, ok := config.ProgressReporter.(interface {
pkg/mcp/internal/observability/progress_tracker.go:	if stage, ok := data["stage"].(string); ok && stage != "" {
pkg/mcp/internal/deploy/generate_manifests.go:	switch v := args.(type) {
pkg/mcp/internal/deploy/generate_manifests.go:	switch v := args.(type) {
pkg/mcp/internal/deploy/health_tool.go:	if progressReporter, ok := reporter.(interface {
pkg/mcp/internal/deploy/health_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/deploy/health_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/deploy/health_tool.go:	if progressReporter, ok := reporter.(interface{ ReportStage(float64, string) }); ok {
pkg/mcp/internal/deploy/health_tool.go:		t.updateSessionState(sessionInterface.(*core.SessionState), result)
pkg/mcp/internal/deploy/health_tool.go:		t.updateSessionState(sessionInterface.(*core.SessionState), result)
pkg/mcp/internal/deploy/health_tool.go:	typedArgs, ok := args.(AtomicCheckHealthArgs)
pkg/mcp/internal/deploy/health_tool.go:	typedArgs, ok := args.(AtomicCheckHealthArgs)
pkg/mcp/internal/observability/collector.go:			if compStr, ok := comp.(string); ok && strings.Contains(compStr, component) {
pkg/mcp/internal/observability/collector.go:			if compStr, ok := comp.(string); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_validate_unified.go:	deployArgs, ok := args.(AtomicDeployKubernetesArgs)
pkg/mcp/internal/deploy/validator_helpers.go:	if envFrom, ok := container["envFrom"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:			if envMap, ok := env.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:				if cmRef, ok := envMap["configMapRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:					if name, ok := cmRef["name"].(string); ok && !configMaps[name] {
pkg/mcp/internal/deploy/validator_helpers.go:				if secRef, ok := envMap["secretRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:					if name, ok := secRef["name"].(string); ok && !secrets[name] {
pkg/mcp/internal/deploy/validator_helpers.go:	if env, ok := container["env"].([]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:			if envMap, ok := envVar.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:				if valueFrom, ok := envMap["valueFrom"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:					if cmKeyRef, ok := valueFrom["configMapKeyRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:						if name, ok := cmKeyRef["name"].(string); ok && !configMaps[name] {
pkg/mcp/internal/deploy/validator_helpers.go:					if secKeyRef, ok := valueFrom["secretKeyRef"].(map[string]interface{}); ok {
pkg/mcp/internal/deploy/validator_helpers.go:						if name, ok := secKeyRef["name"].(string); ok && !secrets[name] {
pkg/mcp/internal/deploy/validator_helpers.go:	if volumeMounts, ok := container["volumeMounts"].([]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:	if matches, ok := grypeResult["matches"].([]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:			if matchMap, ok := match.(map[string]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:				if vuln, ok := matchMap["vulnerability"].(map[string]interface{}); ok {
pkg/mcp/internal/build/image_validator.go:					if severity, ok := vuln["severity"].(string); ok {
pkg/mcp/internal/deploy/health_validator_unified.go:	if metrics, ok := validationResult.Metadata.Context["health_metrics"].(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if apiVersion, ok := manifest["apiVersion"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if kind, ok := manifest["kind"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:		if name, ok := metadata["name"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:		if namespace, ok := metadata["namespace"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if apiVersion, ok := manifest["apiVersion"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if metadata, ok := manifest["metadata"].(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:		if name, ok := metadata["name"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	kind, _ := manifest["kind"].(string)
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	template, ok := spec["template"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	templateSpec, ok := template["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	containers, ok := templateSpec["containers"].([]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	ports, ok := spec["ports"].([]interface{})
pkg/mcp/internal/observability/manifest_validator.go:			if dataMap, ok := data.(map[string]interface{}); ok {
pkg/mcp/internal/observability/manifest_validator.go:	if secretType, ok := manifest["type"].(string); ok {
pkg/mcp/internal/observability/manifest_validator.go:	spec, ok := manifest["spec"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:		if rulesList, ok := rules.([]interface{}); ok && len(rulesList) == 0 {
pkg/mcp/internal/observability/manifest_validator.go:	metadata, ok := manifest["metadata"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:	labels, ok := metadata["labels"].(map[string]interface{})
pkg/mcp/internal/observability/manifest_validator.go:		next, ok := current[part].(map[string]interface{})
pkg/mcp/internal/observability/otel_config.go:	if endpoint, ok := updates["otlp_endpoint"].(string); ok && endpoint != "" {
pkg/mcp/internal/observability/otel_config.go:	if headers, ok := updates["otlp_headers"].(map[string]string); ok {
pkg/mcp/internal/observability/otel_config.go:	if sampleRate, ok := updates["trace_sample_rate"].(float64); ok {
pkg/mcp/internal/observability/otel_config.go:	if env, ok := updates["environment"].(string); ok && env != "" {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:		if manifestMap, ok := manifestResult.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:				if errorMap, ok := errorData.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:				if manifests, ok := manifestsData.([]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:						if manifestMap, ok := manifest.(map[string]interface{}); ok {
pkg/mcp/internal/deploy/deploy_kubernetes_manifest.go:		if manifestMap, ok := manifestResult.(map[string]interface{}); ok {
pkg/mcp/internal/observability/otel_middleware.go:			switch v := value.(type) {
pkg/mcp/internal/observability/otel_middleware.go:			switch v := value.(type) {
pkg/mcp/internal/observability/otel_middleware.go:		switch v := value.(type) {
pkg/mcp/internal/observability/otel_middleware.go:			switch v := value.(type) {
pkg/mcp/internal/observability/otel_middleware.go:		switch v := value.(type) {
pkg/mcp/internal/deploy/validate_deployment.go:	switch a := args.(type) {
pkg/mcp/internal/deploy/validate_deployment.go:	switch a := args.(type) {
pkg/mcp/internal/build/failure_predictor.go:		if version, ok := dockerVersion.(string); ok && version == "" {
pkg/mcp/internal/build/failure_predictor.go:		if mem, ok := memory.(int64); ok && mem < 1024*1024*1024 { // Less than 1GB
pkg/mcp/internal/build/error_router.go:		if contextMap, ok := sharedData.(map[string]interface{}); ok {
pkg/mcp/internal/build/error_router.go:		if maxRetriesInt, ok := maxRetries.(int); ok {
pkg/mcp/internal/build/error_router.go:		if autoFixBool, ok := autoFix.(bool); ok && autoFixBool {
pkg/mcp/internal/build/error_router.go:		if severityStr, ok := severity.(string); ok {
pkg/mcp/internal/build/error_router.go:				if ctxSeverity, hasSeverity := errorCtx.SharedContext["severity"].(string); hasSeverity {
pkg/mcp/internal/build/error_router.go:			if path, ok := errorCtx.ToolContext["dockerfile_path"].(string); ok {
pkg/mcp/internal/build/error_router.go:	if historyData, ok := data.([]map[string]interface{}); ok {
pkg/mcp/internal/build/error_router.go:	if routingData, ok := data.(map[string]interface{}); ok {
pkg/mcp/internal/build/integration_test.go:	retrievedMap := retrieved.(map[string]interface{})
pkg/mcp/internal/build/integration_test.go:		assert.Greater(t, metadata["security_score"].(int), 80)
pkg/mcp/internal/build/integration_test.go:		assert.True(t, workflowContext["security_passed"].(bool))
pkg/mcp/internal/build/integration_test.go:		assert.Greater(t, metrics["security_score"].(int), 80)
pkg/mcp/internal/build/integration_test.go:		assert.Equal(t, 0, metrics["vulnerabilities_found"].(int))
pkg/mcp/internal/build/push_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/push_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/push_image_atomic.go:		if pc, ok := progressCallback.(ProgressCallback); ok {
pkg/mcp/internal/build/push_image_atomic.go:	if pushResultTyped, ok := pushResult.(*coredocker.RegistryPushResult); ok {
pkg/mcp/internal/build/push_image_atomic.go:			if layersPushed, ok := pushResultTyped.Context["layers_pushed"].(int); ok {
pkg/mcp/internal/build/push_image_atomic.go:			if layersCached, ok := pushResultTyped.Context["layers_cached"].(int); ok {
pkg/mcp/internal/build/push_image_atomic.go:			if bytesTransferred, ok := pushResultTyped.Context["bytes_transferred"].(int64); ok {
pkg/mcp/internal/build/build_image_atomic.go:	buildArgs, ok := args.(AtomicBuildImageArgs)
pkg/mcp/internal/build/build_image_atomic.go:	buildArgs, ok := args.(AtomicBuildImageArgs)
pkg/mcp/internal/build/pull_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/pull_image_atomic.go:	pullArgs, ok := args.(AtomicPullImageArgs)
pkg/mcp/internal/build/pull_image_atomic.go:	pullArgs, ok := args.(AtomicPullImageArgs)
pkg/mcp/internal/build/build_executor.go:	session, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/build/build_executor.go:	session, ok := sessionInterface.(*session.SessionState)
pkg/mcp/internal/build/build_validator.go:		if exitErr, ok := err.(*exec.ExitError); ok && len(exitErr.Stderr) > 0 {
pkg/mcp/internal/build/ai_context_enhancer.go:	if inputMap, ok := inputData.(map[string]interface{}); ok {
pkg/mcp/internal/build/ai_context_enhancer.go:	if outputMap, ok := outputData.(map[string]interface{}); ok {
pkg/mcp/internal/build/ai_context_enhancer.go:		if success, ok := outputMap["success"].(bool); ok && success {
pkg/mcp/internal/build/ai_context_enhancer.go:		if imageRef, ok := outputMap["image_ref"].(string); ok && imageRef != "" {
pkg/mcp/internal/build/ai_context_enhancer.go:		if duration, ok := outputMap["duration"].(time.Duration); ok {
pkg/mcp/internal/build/ai_context_enhancer.go:	if aiContext, ok := data.(*AIToolContext); ok {
pkg/mcp/internal/build/tag_image_atomic.go:	tagArgs, ok := args.(AtomicTagImageArgs)
pkg/mcp/internal/build/tag_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/tag_image_atomic.go:	if tagResultTyped, ok := tagResult.(*docker.TagResult); ok {
pkg/mcp/internal/build/tag_image_atomic.go:	tagArgs, ok := args.(AtomicTagImageArgs)
pkg/mcp/internal/build/tag_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/tag_image_atomic.go:	sessionState := sessionInterface.(*sessiontypes.SessionState)
pkg/mcp/internal/build/analyzer_integration.go:			if failureMap, ok := failureCtx.(map[string]interface{}); ok {
pkg/mcp/internal/build/analyzer_integration.go:			if successMap, ok := successCtx.(map[string]interface{}); ok {
